/*
 * Team ID: eYRC#881-CS
 * Author List: Devesh Khandelwal, Simmi Mourya, Yatharth Aggarwal, Saurabh Gupta, e-Yantra Team
 * Filename: Eyrc_SYDS.c
 * Theme: Cargo Sorting â€“ eYRC Specific
 * Functions: , main()
 				port_init();
				timer5_init();
				timer1_init();
				velocity(unsigned char, unsigned char);
				motors_delay();
				pick_box();
				keep_box();
				check_color();
				blackline();
				turn_left();
				turn_right();
				center_right();
				center_left();

 * Global Variables: flag, Center_white_line, Left_white_line, Right_white_line, ADC_Value, ADC_Conversion, nod, temp1, current_node
 *	volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
 *	volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
 *	volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
 *	volatile unsigned long int green;     // variable to store the pulse count when read_green function is called
 *	
 *	unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder 
 *	unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
 *	unsigned int Degrees; //to accept angle in degrees for turning
 *
 *
 */

#define F_CPU 14745600
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>

#include <math.h> //included to support power function
#include "lcd.c"

#define NO_IND 4
typedef int bool;
#define true 1
#define false 0

int nod;
int temp1;
int current_node;

volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

const int threshold=0x0c;


void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;    //Setting PORTC 3 as output
 PORTC = PORTC & 0xF7;    //Setting PORTC 3 logic low to turnoff buzzer
}

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
}

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
}
void color_sensor_pin_config(void)
{
  DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
  PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
}


void port_init();
void timer5_init();
void velocity(unsigned char, unsigned char);
void motors_delay();

unsigned char ADC_Conversion(unsigned char);
unsigned char ADC_Value;
unsigned char flag = 0;
unsigned char Left_white_line = 0;
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;


//Function to configure LCD port
void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
 PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
}

//ADC pin configuration
void adc_pin_config (void)
{
 DDRF = 0x00; 
 PORTF = 0x00;
 DDRK = 0x00;
 PORTK = 0x00;
}

//Function to configure ports to enable robot's motion
void motion_pin_config (void) 
{
 DDRA = DDRA | 0x0F;
 PORTA = PORTA & 0xF0;
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
}
//ISR for color sensor
ISR(INT0_vect)
{
  pulse++; //increment on receiving pulse from the color sensor
}

//Function to Initialize PORTS
void port_init()
{
	buzzer_pin_config();
	servo1_pin_config(); //Configure PORTB 5 pin for servo motor 1 operation
 	servo2_pin_config(); //Configure PORTB 6 pin for servo motor 2 operation 
 	servo3_pin_config(); //Configure PORTB 7 pin for servo motor 3 operation  
	color_sensor_pin_config();  //color sensor pin configuration
  	lcd_port_config();
	adc_pin_config();
	motion_pin_config();	
}

// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM80=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}


void adc_init()
{
	ADCSRA = 0x00;
	ADCSRB = 0x00;		//MUX5 = 0
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	ACSR = 0x80;
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
	unsigned char a;
	if(Ch>7)
	{
		ADCSRB = 0x08;
	}
	Ch = Ch & 0x07;  			
	ADMUX= 0x20| Ch;	   		
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
	a=ADCH;
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
	ADCSRB = 0x00;
	return a;
}

//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
	
	ADC_Value = ADC_Conversion(channel);
	lcd_print(row, coloumn, ADC_Value, 3);
}
void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
  cli(); //Clears the global interrupt
  EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
  EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
  sei(); // Enables the global interrupt
}

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
	OCR5BL = (unsigned char)right_motor;
}

//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
 unsigned char PortARestore = 0;

 Direction &= 0x0F; 		// removing upper nibbel for the protection
 PortARestore = PORTA; 		// reading the PORTA original status
 PortARestore &= 0xF0; 		// making lower direction nibbel to 0
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = PortARestore; 		// executing the command
}

void forward (void) 
{
  motion_set (0x06);
}

void back (void) //both wheels backward
{
  motion_set(0x09);
}

void stop (void)
{
  motion_set (0x00);
}

void left (void) //Left wheel backward, Right wheel forward
{
  motion_set(0x05);
}

void right (void) //Left wheel forward, Right wheel backward
{
  motion_set(0x0A);
}

void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
}

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
}

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
 motion_set(0x01);
}

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
 motion_set(0x08);
}



//servo_free functions unlocks the servo motors from the any angle 
//and make them free by giving 100% duty cycle at the PWM. This function can be used to 
//reduce the power consumption of the motor if it is holding load against the gravity.


void init_devices (void)
{
 	cli(); //Clears the global interrupts
	port_init();
	adc_init();
	timer5_init();
	color_sensor_pin_interrupt_init();
	timer1_init();
	sei();   //Enables the global interrupts
}


//Filter Selection
void filter_red(void)    //Used to select red filter
{
  //Filter Select - red filter
  PORTD = PORTD & 0xBF; //set S2 low
  PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void) //Used to select green filter
{
  //Filter Select - green filter
  PORTD = PORTD | 0x40; //set S2 High
  PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void)  //Used to select blue filter
{
  //Filter Select - blue filter
  PORTD = PORTD & 0xBF; //set S2 low
  PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void) //select no filter
{
  //Filter Select - no filter
  PORTD = PORTD | 0x40; //set S2 High
  PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling

/*
 * Function Name: color_sensor_scaling
 * Logic: This function is used to select the scaled down version of the original frequency of the output generated by the color sensor,
           generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
 * Example Call: color_sensor_scaling();   
 *
 */

void color_sensor_scaling()  
{
  //Output Scaling 20% from datasheet
  //PORTD = PORTD & 0xEF;
  PORTD = PORTD | 0x10; //set S0 high
  //PORTD = PORTD & 0xDF; //set S1 low
  PORTD = PORTD | 0x20; //set S1 high
}


/*
 * Function Name: red_read
 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called red.
 * Output: None
 * Logic: function to select red filter and display the count generated by the sensor on LCD.
          The count will be more if the color is red. The count will be very less if its blue or green.
 * Example Call: red_read();
 *
 */

void red_read(void) 
{
  //Red
  filter_red(); //select red filter
  pulse=0; //reset the count to 0
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  red = pulse;  //store the count in variable called red
}


/*
 * Function Name: green_read
 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called green.
 * Output: None
 * Logic: function to select green filter and display the count generated by the sensor on LCD. 
          The count will be more if the color is green. The count will be very less if its blue or red.
 * Example Call: green_read();
 *
 */
void green_read(void) 
{
  //Green
  filter_green(); //select green filter
  pulse=0; //reset the count to 0
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  green = pulse;  //store the count in variable called green
  
}


/*
 * Function Name: green_read
 * Input: capture the pulses for 100 ms or 0.1 second, store the count in variable called green.
 * Output: None
 * Logic: function to select blue filter and display the count generated by the sensor on LCD. 
          The count will be more if the color is blue. The count will be very less if its red or green.
 * Example Call: blue_read();
 *
 */

void blue_read(void) 
{
  //Blue
  filter_blue(); //select blue filter
  pulse=0; //reset the count to 0
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  blue = pulse;  //store the count in variable called blue
  
}

/*
 * Function Name: check_color
 * Input: None
 * Output: Characters 'r','b','g','k' on the basis of defined conditions in logic.
 * Logic: Four different conditions for checking the colors.
          eg: if red color pulse is maximum(compared from green and blue pulses) then it detects a red color and returns 'r'
          similarly for other 3 colors.
 * Example Call: check_color();
   Authored by: Yatharth Aggarwal 
 *
 */
char check_color(void)
{
  
    _delay_ms(1000);  
	red_read();   //display the pulse count when red filter is selected
    green_read(); //display the pulse count when green filter is selected
    blue_read();  //display the pulse count when blue filter is selected
 
     if((red>green) && (red>blue) && (red>2500))
     {
        return 'R';
     }
     if((blue>green) && (blue>red) && (blue>3000))
     {
        return 'B';
     }
     if((green>red) && (green>blue) && (green>2800))
     {
        return 'G';

     }
     if((green<2000 && green>900) && (blue<2000 && blue>1000) && (red<2000 && red>1000))
     {
        return 'K';
     }
     else
     	return 'E';
}


void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
}


//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
 float PositionTiltServo = 0;
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
 OCR1BH = 0x00;
 OCR1BL = (unsigned char) PositionTiltServo;
}

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
 float PositionServo = 0;
 PositionServo = ((float)degrees / 1.86) + 35.0;
 OCR1CH = 0x00;
 OCR1CL = (unsigned char) PositionServo;
}

void servo_1_free (void) //makes servo 1 free rotating
{
 OCR1AH = 0x03; 
 OCR1AL = 0xFF; //Servo 1 off
}

void servo_2_free (void) //makes servo 2 free rotating
{
 OCR1BH = 0x03;
 OCR1BL = 0xFF; //Servo 2 off
}

void servo_3_free (void) //makes servo 3 free rotating
{
 OCR1CH = 0x03;
 OCR1CL = 0xFF; //Servo 3 off
} 


/*
 * Function Name: blackline
 * Variables: A node is defined when all three white line sensors detect black color, On every node detection the variable "nod" increases by one and 
 *	one more variable "temp1" stores the previous value of "nod":
 * eg: if nod=3 at current position and the very previous value of "nod" was 2 then "temp1"=2. This helps in detection of a node, 
 * when temp1< nod, a node has encountered, initially both were zero. The third variable stores the actual no. of node it has encounterd at particular
 * time. There's a reason, why we have taken another variable to store the node no. insted of using nod itself, because the sensor may read more than
 * one node when all three sensor detect black(sometimes of slow speed), so now it updates current_node only on basis of any new increment in nod.
 * Input: Left_white_line, Center_white_line, Right_white_line variabe values, which are actually the three white line sensor values
 	respectively.
 * Output: Corresponding motion according to the combination defined in logic.
 * Logic: Has seven different conditions inside on basis of 7 different combinations of sensor values.
 	The combination is commented just above each condition as 010, 101, 111, 000 etc.
 	0 corresponds for a white reigon and 1 corresponds for a black reigon.
 	eg: 010 represents: Left_white_line sensor color : white
 						Center_white_line sensor color : black
 						Right_white_line sensor color : white
 	0x0c is the threshold sensor value upto which the sensor reads a white color.
 * Example Call: backline();
 *Authored by: Simmi Mourya, Saurabh Gupta
 */

int blackline()
{	
	
	while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		
		//010
		if(Left_white_line<=0x0b && Center_white_line>=0x0b &&  Right_white_line<=0x0b)
		{	
			forward();
			velocity(180,180);
		}
		//000
		if(Left_white_line<=0x0b && Center_white_line<=0x0b && Right_white_line>=0x0b)
		{	
			velocity(180,80);
			_delay_ms(13);

			velocity(80,180	);
			_delay_ms(20);

		}
		//001
		if(Left_white_line<=0x0b && Center_white_line<=0x0b &&  Right_white_line>=0x0b)
		{
			
			velocity(180,45);
			_delay_ms(6);
		}
		//011
		if(Left_white_line<=0x0b && Center_white_line>=0x0b && Right_white_line>=0x0b)
		{	
			velocity(180,45);
			_delay_ms(6);

		}
		//100
		if(Left_white_line>=0x0b && Center_white_line<=0x0b &&  Right_white_line<=0x0b)
		{
			velocity(45,180	);
			_delay_ms(13);
		}
		//110
		if(Left_white_line>=0x0b && Center_white_line>=0x0b &&  Right_white_line<=0x0b)
		{
			velocity(45,180);
			_delay_ms(6);

		}
		//111
		if(Left_white_line>=0x0b && Center_white_line>=0x0b &&  Right_white_line>=0x0b)
		{	
			nod=temp1; 
			nod=temp+1;
			current_node= current_node+1;
			lcd_print(2, 18, temp, 3);
			lcd_print(2, 12, nod, 3);		 
			velocity(130,130);
			_delay_ms(450);
			velocity(0,0);
			return;
		}		
			

	}
}

/*
 * Function Name: turn_left
 * Input: Left_white_line,  which is actually the value of leftmost white line sensor.
 * Output: Helps in taking a restricted left turn on the basis of ceratin condition that is defined in logic.
 * Logic: Takes a left until its left sensor gets a black value.
 	0x0c is the threshold sensor value upto which the sensor reads a white color.
 * Example Call: turn_left();
 *Authored by: Devesh Khandelwal.
 */

void turn_left()
{
	left();
	while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		velocity(130,130);
		_delay_ms(6);
		if(Left_white_line>=0x0b)
		{
			velocity(0,0);

			return;
		}
		
	}
}

/*
 * Function Name: center_left
 * Input: Center_white_line,  which is actually the value of center white line sensor.
 * Output: Rotates the robot to take a restricted right turn.
 * Logic: Takes a right until its center sensor gets a black value.
 	0x0c is the threshold sensor value upto which the sensor reads a white color.
 * Example Call: center_left();
 *Authored by: Devesh Khandelwal.
 */

void center_left()
{
	soft_right_2();
	while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		velocity(0,130);
		_delay_ms(6);
		if(Center_white_line>=0x0b)
		{
			velocity(0,0);

			return;
		}
		
	}
}	


/*
 * Function Name: turn_right
 * Input: Right_white_line,  which is actually the value of rightmost white line sensor.
 * Output: Helps in taking a restricted right turn on the basis of ceratin condition that is defined in logic.
 * Logic: Takes a right until its right sensor gets a black value.
 	0x0c is the threshold sensor value upto which the sensor reads a white color.
 * Example Call: turn_right();
 *Authored by: Devesh Khandelwal.
 */

void turn_right()
{
	right();
	while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		velocity(130,130);
		_delay_ms(6);
		if(Right_white_line>=0x0b)
		{
			velocity(0,0);

			return;
		}
		
	}
}


/*
 * Function Name: center_right
 * Input: Center_white_line,  which is actually the value of center white line sensor.
 * Output: Rotates the robot to take a restricted left turn.
 * Logic: Takes a left until its center sensor gets a black value.
 	0x0c is the threshold sensor value upto which the sensor reads a white color.
 * Example Call: center_right();
 *Authored by: Devesh Khandelwal.
 */
void center_right()
{
	soft_left_2();
	while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
		
		velocity(130,0);
		_delay_ms(6);
		if(Center_white_line>=0x0b)
		{
			velocity(0,0);

			return;
		}
		
	}
}	

/*
 * Function Name: keep_box
 * Logic: Step by step implementation:
          1. as the arm would be in air 
          2. bring it down (set the box a little up from the surface)
          3. release the gripper only at a lesser angle first and then increase the angle later
          4. bring the gripper-arm back at original position
          5. free the servos
 * Example Call: keep_box();
   Authored by: Yatharth Aggarwal 
 *
 */
void keep_box()
{
   servo_1(53);
   _delay_ms(1000);		//bring it down (set the box a little up from the surface
   servo_3(35);
   _delay_ms(1800);		//release the gripper only at a lesser angle first and then increase the angle later
  

    servo_3(0);
   _delay_ms(1000);
   servo_1(0);			//bring the arm back	
   _delay_ms(1000);
   servo_3(90);
   _delay_ms(1000);	

}

/*
 * Function Name: pick_box
 * Logic: Step by step implementation:
          1. open the gripper
          2. lower the arm
          3. grip the box 
          4. raise the arm
 * Example Call: pick_box();
   Authored by: Yatharth Aggarwal 
 *
 */

void pick_box()
{
  servo_3(5);         //open the gripper
  _delay_ms(1000);
  servo_1(60);        //lower the arm
  _delay_ms(1000); 
 
  servo_3(50);        //grip the box 
  _delay_ms(1000);
  servo_1(0);         //raise the arm
  _delay_ms(1000);

}
void buzzer_on (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
 port_restore = port_restore | 0x08;
 PORTC = port_restore;
}

void buzzer_off (void)
{
 unsigned char port_restore = 0;
 port_restore = PINC;
 port_restore = port_restore & 0xF7;
 PORTC = port_restore;
}

/*
 * Function Name: main
 * Input: none
 * Output: Traverses and stores various values required values for later operations.
 * Logic: Firstly it commnads the robot to traverse the indiactor block arena by visiting each box one by one, it stores the colour
 		  of each block in an array (Indicator[4]) for later comparisons, by the help of RGB color sensor installed infront of robot.
 		  It reaches the main arena and again it visits each box one by one and stores each colour in different variables assigned.
 		  It traverses the whole arena first and after reaching every box,it records three basic informations:
 		  eg:
 		  Let's say it reaches T1 R( Terminal one right position) and  a block is kept there:
 		  Color_box = some color or empty
 		  Is_color = true (As compared to Indicator[1])
 		  Buzzer for 500ms.

 		  If 
 		  Is_color = false
 		  Check which value of array matches with that color.
 		  Assign_terminal: The destination terminal onto which the box should be kept.

 * Example Call: main();
 *Authored by: Devesh Khandelwal, Simmi Mourya.
 */
int main()
{	
	char I1,I2,I3,I4;
	char Pos[8];
	
	init_devices();
	lcd_set_4bit();
	lcd_init();
	servo_1(0);
	
	forward();
	velocity(180,180);
	_delay_ms(1000);
	stop();
	// Indicator Blocks.
	blackline();
	forward();
	velocity(150,150);
	_delay_ms(400);
	left();
	velocity(150,150);
	_delay_ms(200);
	turn_left();
	left();
	velocity(150,150);
	_delay_ms(200);
	stop();
	I3=check_color();

	right();
	velocity(150,150);
	_delay_ms(3000);
	turn_right();
	right();
	velocity(150,150);
	_delay_ms(200);	left();
	velocity(150,150);
	_delay_ms(1000);
	stop();
	I4=check_color();

	turn_left();
	blackline();
	forward();
	velocity(150,150);
	_delay_ms(400);
	left();
	velocity(150,150);
	_delay_ms(200);
	turn_left();
	left();
	velocity(150,150);
	_delay_ms(200);
	stop();
	I1=check_color();

	//turn_right();
	right();
	velocity(150,150);
	_delay_ms(3000);
	turn_right();
	right();
	velocity(150,150);
	_delay_ms(200);
	stop();
	I2=check_color();

	left();
	velocity(150,150);
	_delay_ms(1000);
	turn_left();

	// indicator done

	// Traversing

	// Center node

	blackline();

	// Part-1

 	turn_left();
	blackline();

	// T1

	turn_right();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(200);

	stop();
	Pos[0]=check_color();
	if(Pos[0]==I1)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}

	right();
	velocity(180,180);
	_delay_ms(4000);
	forward();
	
	stop();
	Pos[1]=check_color();
	if(Pos[1]==I1)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}	
	
	turn_right();
	
	// T3

	blackline();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(200);
	
	stop();
	Pos[2]=check_color();
	if(Pos[2]==I3)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}
	
	right();
	velocity(180,180);
	_delay_ms(4000);
	
	stop();
	Pos[3]=check_color();
	if(Pos[3]==I3)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}

	turn_right();
	blackline();
	turn_right();
	blackline();



	// Center node

	blackline();

	// Part 2

	// T2

	turn_left();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(200);

	stop();
	Pos[4]=check_color();
	if(Pos[4]==I2)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}

	right();
	velocity(180,180);
	_delay_ms(4000);

	stop();
	Pos[5]=check_color();
	if(Pos[5]==I2)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}
	turn_right();
	blackline();


	// T4

	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(200);

	stop();
	Pos[6]=check_color();
	if(Pos[6]==I4)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}

	right();
	velocity(180,180);
	_delay_ms(3000);

	stop();
	Pos[7]=check_color();
	if(Pos[7]==I4)
	{
		buzzer_on();
		_delay_ms(500);
		buzzer_off();
	}	
	
	turn_right();


	// till here traversing of terminal obne finshed
	// write three more similar to finish  whole traversing, finish it at terminal 4 left


	// T4-R to T4-L

	right();
	velocity(180,180);
	_delay_ms(100);

	forward();
	velocity(180,180);
	_delay_ms(300);

	stop();
	pick_box();
	back();
	velocity(180,180);
	_delay_ms(300);

	// T4-R to T1-R

	turn_right();
	blackline();
	turn_left();
	blackline();
	blackline();
	turn_right();
	blackline();
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(200);	
	forward();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);
	keep_box();
	buzzer_on();
	_delay_ms(500);
	buzzer_off();
	back();
	velocity(180,180);
	_delay_ms(300);

	// T1-R to T3-L

	turn_right();
	blackline();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(150);
	forward();
	velocity(180,180);
	_delay_ms(300);
	stop();
	pick_box();
	back();
	velocity(180,180);
	_delay_ms(300);


	// T3-L to T4-L
	turn_right();

	blackline();
	turn_right();
	blackline();
	blackline();
	turn_right();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(100);
	forward();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);
	keep_box();
	buzzer_on();
	_delay_ms(500);
	buzzer_off();
	back();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);



	// T4 - L to T4-R

	turn_right();
	right();
	velocity(180,180);
	_delay_ms(300);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(40);
	forward();
	velocity(180,180);
	_delay_ms(300);
	stop();
	velocity(0,0);

	pick_box();
	back();
	velocity(180,180);
	_delay_ms(300);
	forward();


	// T4-R to T3-L


	turn_left();
	blackline();
	turn_left();
	blackline();
	blackline();
	turn_left();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(100);
	velocity(0,0);
	forward();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);
	keep_box();
	buzzer_on();
	_delay_ms(500);
	buzzer_off();
	back();
	velocity(180,180);
	_delay_ms(300);

	// T3-L to T3-R

	right();
	velocity(180,180);
	_delay_ms(2650);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(50);
	forward();
	velocity(180,180);
	_delay_ms(300);
	stop();
	pick_box();
	back();
	velocity(180,180);
	_delay_ms(300);

	// T3-R to T4-R

	forward();
	turn_left();
	blackline();
	turn_right();
	blackline();
	blackline();
	turn_right();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(70);
	velocity(0,0);
	forward();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);
	keep_box();
	buzzer_on();
	_delay_ms(500);
	buzzer_off();
	back();
	velocity(180,180);
	_delay_ms(300);


	// T4-R to T2-R

	forward();
	turn_left();
	blackline();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_right();
	right();
	velocity(180,180);
	_delay_ms(80);
	velocity(0,0);
	forward();
	velocity(180,180);
	_delay_ms(300);
	stop();
	pick_box();
	back();
	velocity(180,180);
	_delay_ms(300);

	// T2-R to T3-R

	forward();
	turn_right();
	blackline();
	turn_right();
	blackline();
	blackline();
	turn_left();
	blackline();
	forward();
	velocity(180,180);
	_delay_ms(400);
	turn_left();
	left();
	velocity(180,180);
	_delay_ms(80);
	forward();
	velocity(0,0);
	forward();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);
	keep_box();
	buzzer_on();
	_delay_ms(500);
	buzzer_off();
	back();
	velocity(180,180);
	_delay_ms(300);
	velocity(0,0);

	
//When all boxes are sorted it gives a continouos beep for 5 seconds indiacting the completion of task.
	buzzer_on();
	_delay_ms(5000);
	buzzer_off();

	
}
