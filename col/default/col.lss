
col.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000122  00800200  00004a88  00004b1c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004a88  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000031  00800322  00800322  00004c3e  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00004c3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000655  00000000  00000000  00004c5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001595  00000000  00000000  000052b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000290  00000000  00000000  00006848  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001f03  00000000  00000000  00006ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000004d0  00000000  00000000  000089dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000609  00000000  00000000  00008eac  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
       4:	0c 94 93 0b 	jmp	0x1726	; 0x1726 <__vector_1>
       8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
       c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      14:	0c 94 de 0c 	jmp	0x19bc	; 0x19bc <__vector_5>
      18:	0c 94 b3 0c 	jmp	0x1966	; 0x1966 <__vector_6>
      1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
      e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
      e4:	11 24       	eor	r1, r1
      e6:	1f be       	out	0x3f, r1	; 63
      e8:	cf ef       	ldi	r28, 0xFF	; 255
      ea:	d1 e2       	ldi	r29, 0x21	; 33
      ec:	de bf       	out	0x3e, r29	; 62
      ee:	cd bf       	out	0x3d, r28	; 61
      f0:	00 e0       	ldi	r16, 0x00	; 0
      f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
      f4:	13 e0       	ldi	r17, 0x03	; 3
      f6:	a0 e0       	ldi	r26, 0x00	; 0
      f8:	b2 e0       	ldi	r27, 0x02	; 2
      fa:	e8 e8       	ldi	r30, 0x88	; 136
      fc:	fa e4       	ldi	r31, 0x4A	; 74
      fe:	00 e0       	ldi	r16, 0x00	; 0
     100:	0b bf       	out	0x3b, r16	; 59
     102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
     104:	07 90       	elpm	r0, Z+
     106:	0d 92       	st	X+, r0
     108:	a2 32       	cpi	r26, 0x22	; 34
     10a:	b1 07       	cpc	r27, r17
     10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
     10e:	13 e0       	ldi	r17, 0x03	; 3
     110:	a2 e2       	ldi	r26, 0x22	; 34
     112:	b3 e0       	ldi	r27, 0x03	; 3
     114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
     116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
     118:	a3 35       	cpi	r26, 0x53	; 83
     11a:	b1 07       	cpc	r27, r17
     11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
     11e:	0e 94 16 1e 	call	0x3c2c	; 0x3c2c <main>
     122:	0c 94 42 25 	jmp	0x4a84	; 0x4a84 <_exit>

00000126 <__bad_interrupt>:
     126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <lcd_set_4bit>:



//Function to Reset LCD
void lcd_set_4bit()
{
     12a:	0f 93       	push	r16
     12c:	1f 93       	push	r17
     12e:	df 93       	push	r29
     130:	cf 93       	push	r28
     132:	cd b7       	in	r28, 0x3d	; 61
     134:	de b7       	in	r29, 0x3e	; 62
     136:	c0 57       	subi	r28, 0x70	; 112
     138:	d0 40       	sbci	r29, 0x00	; 0
     13a:	0f b6       	in	r0, 0x3f	; 63
     13c:	f8 94       	cli
     13e:	de bf       	out	0x3e, r29	; 62
     140:	0f be       	out	0x3f, r0	; 63
     142:	cd bf       	out	0x3d, r28	; 61
     144:	fe 01       	movw	r30, r28
     146:	e3 59       	subi	r30, 0x93	; 147
     148:	ff 4f       	sbci	r31, 0xFF	; 255
     14a:	80 e0       	ldi	r24, 0x00	; 0
     14c:	90 e0       	ldi	r25, 0x00	; 0
     14e:	a0 e8       	ldi	r26, 0x80	; 128
     150:	bf e3       	ldi	r27, 0x3F	; 63
     152:	80 83       	st	Z, r24
     154:	91 83       	std	Z+1, r25	; 0x01
     156:	a2 83       	std	Z+2, r26	; 0x02
     158:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     15a:	8e 01       	movw	r16, r28
     15c:	07 59       	subi	r16, 0x97	; 151
     15e:	1f 4f       	sbci	r17, 0xFF	; 255
     160:	fe 01       	movw	r30, r28
     162:	e3 59       	subi	r30, 0x93	; 147
     164:	ff 4f       	sbci	r31, 0xFF	; 255
     166:	60 81       	ld	r22, Z
     168:	71 81       	ldd	r23, Z+1	; 0x01
     16a:	82 81       	ldd	r24, Z+2	; 0x02
     16c:	93 81       	ldd	r25, Z+3	; 0x03
     16e:	26 e6       	ldi	r18, 0x66	; 102
     170:	36 e6       	ldi	r19, 0x66	; 102
     172:	46 e6       	ldi	r20, 0x66	; 102
     174:	55 e4       	ldi	r21, 0x45	; 69
     176:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     17a:	dc 01       	movw	r26, r24
     17c:	cb 01       	movw	r24, r22
     17e:	f8 01       	movw	r30, r16
     180:	80 83       	st	Z, r24
     182:	91 83       	std	Z+1, r25	; 0x01
     184:	a2 83       	std	Z+2, r26	; 0x02
     186:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     188:	fe 01       	movw	r30, r28
     18a:	e7 59       	subi	r30, 0x97	; 151
     18c:	ff 4f       	sbci	r31, 0xFF	; 255
     18e:	60 81       	ld	r22, Z
     190:	71 81       	ldd	r23, Z+1	; 0x01
     192:	82 81       	ldd	r24, Z+2	; 0x02
     194:	93 81       	ldd	r25, Z+3	; 0x03
     196:	20 e0       	ldi	r18, 0x00	; 0
     198:	30 e0       	ldi	r19, 0x00	; 0
     19a:	40 e8       	ldi	r20, 0x80	; 128
     19c:	5f e3       	ldi	r21, 0x3F	; 63
     19e:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     1a2:	88 23       	and	r24, r24
     1a4:	44 f4       	brge	.+16     	; 0x1b6 <lcd_set_4bit+0x8c>
		__ticks = 1;
     1a6:	fe 01       	movw	r30, r28
     1a8:	e9 59       	subi	r30, 0x99	; 153
     1aa:	ff 4f       	sbci	r31, 0xFF	; 255
     1ac:	81 e0       	ldi	r24, 0x01	; 1
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	91 83       	std	Z+1, r25	; 0x01
     1b2:	80 83       	st	Z, r24
     1b4:	64 c0       	rjmp	.+200    	; 0x27e <lcd_set_4bit+0x154>
	else if (__tmp > 65535)
     1b6:	fe 01       	movw	r30, r28
     1b8:	e7 59       	subi	r30, 0x97	; 151
     1ba:	ff 4f       	sbci	r31, 0xFF	; 255
     1bc:	60 81       	ld	r22, Z
     1be:	71 81       	ldd	r23, Z+1	; 0x01
     1c0:	82 81       	ldd	r24, Z+2	; 0x02
     1c2:	93 81       	ldd	r25, Z+3	; 0x03
     1c4:	20 e0       	ldi	r18, 0x00	; 0
     1c6:	3f ef       	ldi	r19, 0xFF	; 255
     1c8:	4f e7       	ldi	r20, 0x7F	; 127
     1ca:	57 e4       	ldi	r21, 0x47	; 71
     1cc:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     1d0:	18 16       	cp	r1, r24
     1d2:	0c f0       	brlt	.+2      	; 0x1d6 <lcd_set_4bit+0xac>
     1d4:	43 c0       	rjmp	.+134    	; 0x25c <lcd_set_4bit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     1d6:	fe 01       	movw	r30, r28
     1d8:	e3 59       	subi	r30, 0x93	; 147
     1da:	ff 4f       	sbci	r31, 0xFF	; 255
     1dc:	60 81       	ld	r22, Z
     1de:	71 81       	ldd	r23, Z+1	; 0x01
     1e0:	82 81       	ldd	r24, Z+2	; 0x02
     1e2:	93 81       	ldd	r25, Z+3	; 0x03
     1e4:	20 e0       	ldi	r18, 0x00	; 0
     1e6:	30 e0       	ldi	r19, 0x00	; 0
     1e8:	40 e2       	ldi	r20, 0x20	; 32
     1ea:	51 e4       	ldi	r21, 0x41	; 65
     1ec:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     1f0:	dc 01       	movw	r26, r24
     1f2:	cb 01       	movw	r24, r22
     1f4:	8e 01       	movw	r16, r28
     1f6:	09 59       	subi	r16, 0x99	; 153
     1f8:	1f 4f       	sbci	r17, 0xFF	; 255
     1fa:	bc 01       	movw	r22, r24
     1fc:	cd 01       	movw	r24, r26
     1fe:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     202:	dc 01       	movw	r26, r24
     204:	cb 01       	movw	r24, r22
     206:	f8 01       	movw	r30, r16
     208:	91 83       	std	Z+1, r25	; 0x01
     20a:	80 83       	st	Z, r24
     20c:	1f c0       	rjmp	.+62     	; 0x24c <lcd_set_4bit+0x122>
     20e:	fe 01       	movw	r30, r28
     210:	eb 59       	subi	r30, 0x9B	; 155
     212:	ff 4f       	sbci	r31, 0xFF	; 255
     214:	80 e7       	ldi	r24, 0x70	; 112
     216:	91 e0       	ldi	r25, 0x01	; 1
     218:	91 83       	std	Z+1, r25	; 0x01
     21a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     21c:	fe 01       	movw	r30, r28
     21e:	eb 59       	subi	r30, 0x9B	; 155
     220:	ff 4f       	sbci	r31, 0xFF	; 255
     222:	80 81       	ld	r24, Z
     224:	91 81       	ldd	r25, Z+1	; 0x01
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <lcd_set_4bit+0xfc>
     22a:	fe 01       	movw	r30, r28
     22c:	eb 59       	subi	r30, 0x9B	; 155
     22e:	ff 4f       	sbci	r31, 0xFF	; 255
     230:	91 83       	std	Z+1, r25	; 0x01
     232:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     234:	de 01       	movw	r26, r28
     236:	a9 59       	subi	r26, 0x99	; 153
     238:	bf 4f       	sbci	r27, 0xFF	; 255
     23a:	fe 01       	movw	r30, r28
     23c:	e9 59       	subi	r30, 0x99	; 153
     23e:	ff 4f       	sbci	r31, 0xFF	; 255
     240:	80 81       	ld	r24, Z
     242:	91 81       	ldd	r25, Z+1	; 0x01
     244:	01 97       	sbiw	r24, 0x01	; 1
     246:	11 96       	adiw	r26, 0x01	; 1
     248:	9c 93       	st	X, r25
     24a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     24c:	fe 01       	movw	r30, r28
     24e:	e9 59       	subi	r30, 0x99	; 153
     250:	ff 4f       	sbci	r31, 0xFF	; 255
     252:	80 81       	ld	r24, Z
     254:	91 81       	ldd	r25, Z+1	; 0x01
     256:	00 97       	sbiw	r24, 0x00	; 0
     258:	d1 f6       	brne	.-76     	; 0x20e <lcd_set_4bit+0xe4>
     25a:	27 c0       	rjmp	.+78     	; 0x2aa <lcd_set_4bit+0x180>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     25c:	8e 01       	movw	r16, r28
     25e:	09 59       	subi	r16, 0x99	; 153
     260:	1f 4f       	sbci	r17, 0xFF	; 255
     262:	fe 01       	movw	r30, r28
     264:	e7 59       	subi	r30, 0x97	; 151
     266:	ff 4f       	sbci	r31, 0xFF	; 255
     268:	60 81       	ld	r22, Z
     26a:	71 81       	ldd	r23, Z+1	; 0x01
     26c:	82 81       	ldd	r24, Z+2	; 0x02
     26e:	93 81       	ldd	r25, Z+3	; 0x03
     270:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     274:	dc 01       	movw	r26, r24
     276:	cb 01       	movw	r24, r22
     278:	f8 01       	movw	r30, r16
     27a:	91 83       	std	Z+1, r25	; 0x01
     27c:	80 83       	st	Z, r24
     27e:	de 01       	movw	r26, r28
     280:	ad 59       	subi	r26, 0x9D	; 157
     282:	bf 4f       	sbci	r27, 0xFF	; 255
     284:	fe 01       	movw	r30, r28
     286:	e9 59       	subi	r30, 0x99	; 153
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	80 81       	ld	r24, Z
     28c:	91 81       	ldd	r25, Z+1	; 0x01
     28e:	8d 93       	st	X+, r24
     290:	9c 93       	st	X, r25
     292:	fe 01       	movw	r30, r28
     294:	ed 59       	subi	r30, 0x9D	; 157
     296:	ff 4f       	sbci	r31, 0xFF	; 255
     298:	80 81       	ld	r24, Z
     29a:	91 81       	ldd	r25, Z+1	; 0x01
     29c:	01 97       	sbiw	r24, 0x01	; 1
     29e:	f1 f7       	brne	.-4      	; 0x29c <lcd_set_4bit+0x172>
     2a0:	fe 01       	movw	r30, r28
     2a2:	ed 59       	subi	r30, 0x9D	; 157
     2a4:	ff 4f       	sbci	r31, 0xFF	; 255
     2a6:	91 83       	std	Z+1, r25	; 0x01
     2a8:	80 83       	st	Z, r24
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     2aa:	a8 e2       	ldi	r26, 0x28	; 40
     2ac:	b0 e0       	ldi	r27, 0x00	; 0
     2ae:	e8 e2       	ldi	r30, 0x28	; 40
     2b0:	f0 e0       	ldi	r31, 0x00	; 0
     2b2:	80 81       	ld	r24, Z
     2b4:	8e 7f       	andi	r24, 0xFE	; 254
     2b6:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     2b8:	a8 e2       	ldi	r26, 0x28	; 40
     2ba:	b0 e0       	ldi	r27, 0x00	; 0
     2bc:	e8 e2       	ldi	r30, 0x28	; 40
     2be:	f0 e0       	ldi	r31, 0x00	; 0
     2c0:	80 81       	ld	r24, Z
     2c2:	8d 7f       	andi	r24, 0xFD	; 253
     2c4:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
     2c6:	e8 e2       	ldi	r30, 0x28	; 40
     2c8:	f0 e0       	ldi	r31, 0x00	; 0
     2ca:	80 e3       	ldi	r24, 0x30	; 48
     2cc:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
     2ce:	a8 e2       	ldi	r26, 0x28	; 40
     2d0:	b0 e0       	ldi	r27, 0x00	; 0
     2d2:	e8 e2       	ldi	r30, 0x28	; 40
     2d4:	f0 e0       	ldi	r31, 0x00	; 0
     2d6:	80 81       	ld	r24, Z
     2d8:	84 60       	ori	r24, 0x04	; 4
     2da:	8c 93       	st	X, r24
     2dc:	fe 01       	movw	r30, r28
     2de:	e1 5a       	subi	r30, 0xA1	; 161
     2e0:	ff 4f       	sbci	r31, 0xFF	; 255
     2e2:	80 e0       	ldi	r24, 0x00	; 0
     2e4:	90 e0       	ldi	r25, 0x00	; 0
     2e6:	a0 ea       	ldi	r26, 0xA0	; 160
     2e8:	b0 e4       	ldi	r27, 0x40	; 64
     2ea:	80 83       	st	Z, r24
     2ec:	91 83       	std	Z+1, r25	; 0x01
     2ee:	a2 83       	std	Z+2, r26	; 0x02
     2f0:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     2f2:	8e 01       	movw	r16, r28
     2f4:	05 5a       	subi	r16, 0xA5	; 165
     2f6:	1f 4f       	sbci	r17, 0xFF	; 255
     2f8:	fe 01       	movw	r30, r28
     2fa:	e1 5a       	subi	r30, 0xA1	; 161
     2fc:	ff 4f       	sbci	r31, 0xFF	; 255
     2fe:	60 81       	ld	r22, Z
     300:	71 81       	ldd	r23, Z+1	; 0x01
     302:	82 81       	ldd	r24, Z+2	; 0x02
     304:	93 81       	ldd	r25, Z+3	; 0x03
     306:	26 e6       	ldi	r18, 0x66	; 102
     308:	36 e6       	ldi	r19, 0x66	; 102
     30a:	46 e6       	ldi	r20, 0x66	; 102
     30c:	55 e4       	ldi	r21, 0x45	; 69
     30e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     312:	dc 01       	movw	r26, r24
     314:	cb 01       	movw	r24, r22
     316:	f8 01       	movw	r30, r16
     318:	80 83       	st	Z, r24
     31a:	91 83       	std	Z+1, r25	; 0x01
     31c:	a2 83       	std	Z+2, r26	; 0x02
     31e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     320:	fe 01       	movw	r30, r28
     322:	e5 5a       	subi	r30, 0xA5	; 165
     324:	ff 4f       	sbci	r31, 0xFF	; 255
     326:	60 81       	ld	r22, Z
     328:	71 81       	ldd	r23, Z+1	; 0x01
     32a:	82 81       	ldd	r24, Z+2	; 0x02
     32c:	93 81       	ldd	r25, Z+3	; 0x03
     32e:	20 e0       	ldi	r18, 0x00	; 0
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	40 e8       	ldi	r20, 0x80	; 128
     334:	5f e3       	ldi	r21, 0x3F	; 63
     336:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     33a:	88 23       	and	r24, r24
     33c:	44 f4       	brge	.+16     	; 0x34e <lcd_set_4bit+0x224>
		__ticks = 1;
     33e:	fe 01       	movw	r30, r28
     340:	e7 5a       	subi	r30, 0xA7	; 167
     342:	ff 4f       	sbci	r31, 0xFF	; 255
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	90 e0       	ldi	r25, 0x00	; 0
     348:	91 83       	std	Z+1, r25	; 0x01
     34a:	80 83       	st	Z, r24
     34c:	64 c0       	rjmp	.+200    	; 0x416 <lcd_set_4bit+0x2ec>
	else if (__tmp > 65535)
     34e:	fe 01       	movw	r30, r28
     350:	e5 5a       	subi	r30, 0xA5	; 165
     352:	ff 4f       	sbci	r31, 0xFF	; 255
     354:	60 81       	ld	r22, Z
     356:	71 81       	ldd	r23, Z+1	; 0x01
     358:	82 81       	ldd	r24, Z+2	; 0x02
     35a:	93 81       	ldd	r25, Z+3	; 0x03
     35c:	20 e0       	ldi	r18, 0x00	; 0
     35e:	3f ef       	ldi	r19, 0xFF	; 255
     360:	4f e7       	ldi	r20, 0x7F	; 127
     362:	57 e4       	ldi	r21, 0x47	; 71
     364:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     368:	18 16       	cp	r1, r24
     36a:	0c f0       	brlt	.+2      	; 0x36e <lcd_set_4bit+0x244>
     36c:	43 c0       	rjmp	.+134    	; 0x3f4 <lcd_set_4bit+0x2ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     36e:	fe 01       	movw	r30, r28
     370:	e1 5a       	subi	r30, 0xA1	; 161
     372:	ff 4f       	sbci	r31, 0xFF	; 255
     374:	60 81       	ld	r22, Z
     376:	71 81       	ldd	r23, Z+1	; 0x01
     378:	82 81       	ldd	r24, Z+2	; 0x02
     37a:	93 81       	ldd	r25, Z+3	; 0x03
     37c:	20 e0       	ldi	r18, 0x00	; 0
     37e:	30 e0       	ldi	r19, 0x00	; 0
     380:	40 e2       	ldi	r20, 0x20	; 32
     382:	51 e4       	ldi	r21, 0x41	; 65
     384:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     388:	dc 01       	movw	r26, r24
     38a:	cb 01       	movw	r24, r22
     38c:	8e 01       	movw	r16, r28
     38e:	07 5a       	subi	r16, 0xA7	; 167
     390:	1f 4f       	sbci	r17, 0xFF	; 255
     392:	bc 01       	movw	r22, r24
     394:	cd 01       	movw	r24, r26
     396:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     39a:	dc 01       	movw	r26, r24
     39c:	cb 01       	movw	r24, r22
     39e:	f8 01       	movw	r30, r16
     3a0:	91 83       	std	Z+1, r25	; 0x01
     3a2:	80 83       	st	Z, r24
     3a4:	1f c0       	rjmp	.+62     	; 0x3e4 <lcd_set_4bit+0x2ba>
     3a6:	fe 01       	movw	r30, r28
     3a8:	e9 5a       	subi	r30, 0xA9	; 169
     3aa:	ff 4f       	sbci	r31, 0xFF	; 255
     3ac:	80 e7       	ldi	r24, 0x70	; 112
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	91 83       	std	Z+1, r25	; 0x01
     3b2:	80 83       	st	Z, r24
     3b4:	fe 01       	movw	r30, r28
     3b6:	e9 5a       	subi	r30, 0xA9	; 169
     3b8:	ff 4f       	sbci	r31, 0xFF	; 255
     3ba:	80 81       	ld	r24, Z
     3bc:	91 81       	ldd	r25, Z+1	; 0x01
     3be:	01 97       	sbiw	r24, 0x01	; 1
     3c0:	f1 f7       	brne	.-4      	; 0x3be <lcd_set_4bit+0x294>
     3c2:	fe 01       	movw	r30, r28
     3c4:	e9 5a       	subi	r30, 0xA9	; 169
     3c6:	ff 4f       	sbci	r31, 0xFF	; 255
     3c8:	91 83       	std	Z+1, r25	; 0x01
     3ca:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     3cc:	de 01       	movw	r26, r28
     3ce:	a7 5a       	subi	r26, 0xA7	; 167
     3d0:	bf 4f       	sbci	r27, 0xFF	; 255
     3d2:	fe 01       	movw	r30, r28
     3d4:	e7 5a       	subi	r30, 0xA7	; 167
     3d6:	ff 4f       	sbci	r31, 0xFF	; 255
     3d8:	80 81       	ld	r24, Z
     3da:	91 81       	ldd	r25, Z+1	; 0x01
     3dc:	01 97       	sbiw	r24, 0x01	; 1
     3de:	11 96       	adiw	r26, 0x01	; 1
     3e0:	9c 93       	st	X, r25
     3e2:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     3e4:	fe 01       	movw	r30, r28
     3e6:	e7 5a       	subi	r30, 0xA7	; 167
     3e8:	ff 4f       	sbci	r31, 0xFF	; 255
     3ea:	80 81       	ld	r24, Z
     3ec:	91 81       	ldd	r25, Z+1	; 0x01
     3ee:	00 97       	sbiw	r24, 0x00	; 0
     3f0:	d1 f6       	brne	.-76     	; 0x3a6 <lcd_set_4bit+0x27c>
     3f2:	27 c0       	rjmp	.+78     	; 0x442 <lcd_set_4bit+0x318>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     3f4:	8e 01       	movw	r16, r28
     3f6:	07 5a       	subi	r16, 0xA7	; 167
     3f8:	1f 4f       	sbci	r17, 0xFF	; 255
     3fa:	fe 01       	movw	r30, r28
     3fc:	e5 5a       	subi	r30, 0xA5	; 165
     3fe:	ff 4f       	sbci	r31, 0xFF	; 255
     400:	60 81       	ld	r22, Z
     402:	71 81       	ldd	r23, Z+1	; 0x01
     404:	82 81       	ldd	r24, Z+2	; 0x02
     406:	93 81       	ldd	r25, Z+3	; 0x03
     408:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     40c:	dc 01       	movw	r26, r24
     40e:	cb 01       	movw	r24, r22
     410:	f8 01       	movw	r30, r16
     412:	91 83       	std	Z+1, r25	; 0x01
     414:	80 83       	st	Z, r24
     416:	de 01       	movw	r26, r28
     418:	ab 5a       	subi	r26, 0xAB	; 171
     41a:	bf 4f       	sbci	r27, 0xFF	; 255
     41c:	fe 01       	movw	r30, r28
     41e:	e7 5a       	subi	r30, 0xA7	; 167
     420:	ff 4f       	sbci	r31, 0xFF	; 255
     422:	80 81       	ld	r24, Z
     424:	91 81       	ldd	r25, Z+1	; 0x01
     426:	8d 93       	st	X+, r24
     428:	9c 93       	st	X, r25
     42a:	fe 01       	movw	r30, r28
     42c:	eb 5a       	subi	r30, 0xAB	; 171
     42e:	ff 4f       	sbci	r31, 0xFF	; 255
     430:	80 81       	ld	r24, Z
     432:	91 81       	ldd	r25, Z+1	; 0x01
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	f1 f7       	brne	.-4      	; 0x434 <lcd_set_4bit+0x30a>
     438:	fe 01       	movw	r30, r28
     43a:	eb 5a       	subi	r30, 0xAB	; 171
     43c:	ff 4f       	sbci	r31, 0xFF	; 255
     43e:	91 83       	std	Z+1, r25	; 0x01
     440:	80 83       	st	Z, r24
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     442:	a8 e2       	ldi	r26, 0x28	; 40
     444:	b0 e0       	ldi	r27, 0x00	; 0
     446:	e8 e2       	ldi	r30, 0x28	; 40
     448:	f0 e0       	ldi	r31, 0x00	; 0
     44a:	80 81       	ld	r24, Z
     44c:	8b 7f       	andi	r24, 0xFB	; 251
     44e:	8c 93       	st	X, r24
     450:	fe 01       	movw	r30, r28
     452:	ef 5a       	subi	r30, 0xAF	; 175
     454:	ff 4f       	sbci	r31, 0xFF	; 255
     456:	80 e0       	ldi	r24, 0x00	; 0
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	a0 e8       	ldi	r26, 0x80	; 128
     45c:	bf e3       	ldi	r27, 0x3F	; 63
     45e:	80 83       	st	Z, r24
     460:	91 83       	std	Z+1, r25	; 0x01
     462:	a2 83       	std	Z+2, r26	; 0x02
     464:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     466:	8e 01       	movw	r16, r28
     468:	03 5b       	subi	r16, 0xB3	; 179
     46a:	1f 4f       	sbci	r17, 0xFF	; 255
     46c:	fe 01       	movw	r30, r28
     46e:	ef 5a       	subi	r30, 0xAF	; 175
     470:	ff 4f       	sbci	r31, 0xFF	; 255
     472:	60 81       	ld	r22, Z
     474:	71 81       	ldd	r23, Z+1	; 0x01
     476:	82 81       	ldd	r24, Z+2	; 0x02
     478:	93 81       	ldd	r25, Z+3	; 0x03
     47a:	26 e6       	ldi	r18, 0x66	; 102
     47c:	36 e6       	ldi	r19, 0x66	; 102
     47e:	46 e6       	ldi	r20, 0x66	; 102
     480:	55 e4       	ldi	r21, 0x45	; 69
     482:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     486:	dc 01       	movw	r26, r24
     488:	cb 01       	movw	r24, r22
     48a:	f8 01       	movw	r30, r16
     48c:	80 83       	st	Z, r24
     48e:	91 83       	std	Z+1, r25	; 0x01
     490:	a2 83       	std	Z+2, r26	; 0x02
     492:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     494:	fe 01       	movw	r30, r28
     496:	e3 5b       	subi	r30, 0xB3	; 179
     498:	ff 4f       	sbci	r31, 0xFF	; 255
     49a:	60 81       	ld	r22, Z
     49c:	71 81       	ldd	r23, Z+1	; 0x01
     49e:	82 81       	ldd	r24, Z+2	; 0x02
     4a0:	93 81       	ldd	r25, Z+3	; 0x03
     4a2:	20 e0       	ldi	r18, 0x00	; 0
     4a4:	30 e0       	ldi	r19, 0x00	; 0
     4a6:	40 e8       	ldi	r20, 0x80	; 128
     4a8:	5f e3       	ldi	r21, 0x3F	; 63
     4aa:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     4ae:	88 23       	and	r24, r24
     4b0:	44 f4       	brge	.+16     	; 0x4c2 <lcd_set_4bit+0x398>
		__ticks = 1;
     4b2:	fe 01       	movw	r30, r28
     4b4:	e5 5b       	subi	r30, 0xB5	; 181
     4b6:	ff 4f       	sbci	r31, 0xFF	; 255
     4b8:	81 e0       	ldi	r24, 0x01	; 1
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	91 83       	std	Z+1, r25	; 0x01
     4be:	80 83       	st	Z, r24
     4c0:	64 c0       	rjmp	.+200    	; 0x58a <lcd_set_4bit+0x460>
	else if (__tmp > 65535)
     4c2:	fe 01       	movw	r30, r28
     4c4:	e3 5b       	subi	r30, 0xB3	; 179
     4c6:	ff 4f       	sbci	r31, 0xFF	; 255
     4c8:	60 81       	ld	r22, Z
     4ca:	71 81       	ldd	r23, Z+1	; 0x01
     4cc:	82 81       	ldd	r24, Z+2	; 0x02
     4ce:	93 81       	ldd	r25, Z+3	; 0x03
     4d0:	20 e0       	ldi	r18, 0x00	; 0
     4d2:	3f ef       	ldi	r19, 0xFF	; 255
     4d4:	4f e7       	ldi	r20, 0x7F	; 127
     4d6:	57 e4       	ldi	r21, 0x47	; 71
     4d8:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     4dc:	18 16       	cp	r1, r24
     4de:	0c f0       	brlt	.+2      	; 0x4e2 <lcd_set_4bit+0x3b8>
     4e0:	43 c0       	rjmp	.+134    	; 0x568 <lcd_set_4bit+0x43e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     4e2:	fe 01       	movw	r30, r28
     4e4:	ef 5a       	subi	r30, 0xAF	; 175
     4e6:	ff 4f       	sbci	r31, 0xFF	; 255
     4e8:	60 81       	ld	r22, Z
     4ea:	71 81       	ldd	r23, Z+1	; 0x01
     4ec:	82 81       	ldd	r24, Z+2	; 0x02
     4ee:	93 81       	ldd	r25, Z+3	; 0x03
     4f0:	20 e0       	ldi	r18, 0x00	; 0
     4f2:	30 e0       	ldi	r19, 0x00	; 0
     4f4:	40 e2       	ldi	r20, 0x20	; 32
     4f6:	51 e4       	ldi	r21, 0x41	; 65
     4f8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     4fc:	dc 01       	movw	r26, r24
     4fe:	cb 01       	movw	r24, r22
     500:	8e 01       	movw	r16, r28
     502:	05 5b       	subi	r16, 0xB5	; 181
     504:	1f 4f       	sbci	r17, 0xFF	; 255
     506:	bc 01       	movw	r22, r24
     508:	cd 01       	movw	r24, r26
     50a:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     50e:	dc 01       	movw	r26, r24
     510:	cb 01       	movw	r24, r22
     512:	f8 01       	movw	r30, r16
     514:	91 83       	std	Z+1, r25	; 0x01
     516:	80 83       	st	Z, r24
     518:	1f c0       	rjmp	.+62     	; 0x558 <lcd_set_4bit+0x42e>
     51a:	fe 01       	movw	r30, r28
     51c:	e7 5b       	subi	r30, 0xB7	; 183
     51e:	ff 4f       	sbci	r31, 0xFF	; 255
     520:	80 e7       	ldi	r24, 0x70	; 112
     522:	91 e0       	ldi	r25, 0x01	; 1
     524:	91 83       	std	Z+1, r25	; 0x01
     526:	80 83       	st	Z, r24
     528:	fe 01       	movw	r30, r28
     52a:	e7 5b       	subi	r30, 0xB7	; 183
     52c:	ff 4f       	sbci	r31, 0xFF	; 255
     52e:	80 81       	ld	r24, Z
     530:	91 81       	ldd	r25, Z+1	; 0x01
     532:	01 97       	sbiw	r24, 0x01	; 1
     534:	f1 f7       	brne	.-4      	; 0x532 <lcd_set_4bit+0x408>
     536:	fe 01       	movw	r30, r28
     538:	e7 5b       	subi	r30, 0xB7	; 183
     53a:	ff 4f       	sbci	r31, 0xFF	; 255
     53c:	91 83       	std	Z+1, r25	; 0x01
     53e:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     540:	de 01       	movw	r26, r28
     542:	a5 5b       	subi	r26, 0xB5	; 181
     544:	bf 4f       	sbci	r27, 0xFF	; 255
     546:	fe 01       	movw	r30, r28
     548:	e5 5b       	subi	r30, 0xB5	; 181
     54a:	ff 4f       	sbci	r31, 0xFF	; 255
     54c:	80 81       	ld	r24, Z
     54e:	91 81       	ldd	r25, Z+1	; 0x01
     550:	01 97       	sbiw	r24, 0x01	; 1
     552:	11 96       	adiw	r26, 0x01	; 1
     554:	9c 93       	st	X, r25
     556:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     558:	fe 01       	movw	r30, r28
     55a:	e5 5b       	subi	r30, 0xB5	; 181
     55c:	ff 4f       	sbci	r31, 0xFF	; 255
     55e:	80 81       	ld	r24, Z
     560:	91 81       	ldd	r25, Z+1	; 0x01
     562:	00 97       	sbiw	r24, 0x00	; 0
     564:	d1 f6       	brne	.-76     	; 0x51a <lcd_set_4bit+0x3f0>
     566:	27 c0       	rjmp	.+78     	; 0x5b6 <lcd_set_4bit+0x48c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     568:	8e 01       	movw	r16, r28
     56a:	05 5b       	subi	r16, 0xB5	; 181
     56c:	1f 4f       	sbci	r17, 0xFF	; 255
     56e:	fe 01       	movw	r30, r28
     570:	e3 5b       	subi	r30, 0xB3	; 179
     572:	ff 4f       	sbci	r31, 0xFF	; 255
     574:	60 81       	ld	r22, Z
     576:	71 81       	ldd	r23, Z+1	; 0x01
     578:	82 81       	ldd	r24, Z+2	; 0x02
     57a:	93 81       	ldd	r25, Z+3	; 0x03
     57c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     580:	dc 01       	movw	r26, r24
     582:	cb 01       	movw	r24, r22
     584:	f8 01       	movw	r30, r16
     586:	91 83       	std	Z+1, r25	; 0x01
     588:	80 83       	st	Z, r24
     58a:	de 01       	movw	r26, r28
     58c:	a9 5b       	subi	r26, 0xB9	; 185
     58e:	bf 4f       	sbci	r27, 0xFF	; 255
     590:	fe 01       	movw	r30, r28
     592:	e5 5b       	subi	r30, 0xB5	; 181
     594:	ff 4f       	sbci	r31, 0xFF	; 255
     596:	80 81       	ld	r24, Z
     598:	91 81       	ldd	r25, Z+1	; 0x01
     59a:	8d 93       	st	X+, r24
     59c:	9c 93       	st	X, r25
     59e:	fe 01       	movw	r30, r28
     5a0:	e9 5b       	subi	r30, 0xB9	; 185
     5a2:	ff 4f       	sbci	r31, 0xFF	; 255
     5a4:	80 81       	ld	r24, Z
     5a6:	91 81       	ldd	r25, Z+1	; 0x01
     5a8:	01 97       	sbiw	r24, 0x01	; 1
     5aa:	f1 f7       	brne	.-4      	; 0x5a8 <lcd_set_4bit+0x47e>
     5ac:	fe 01       	movw	r30, r28
     5ae:	e9 5b       	subi	r30, 0xB9	; 185
     5b0:	ff 4f       	sbci	r31, 0xFF	; 255
     5b2:	91 83       	std	Z+1, r25	; 0x01
     5b4:	80 83       	st	Z, r24

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     5b6:	a8 e2       	ldi	r26, 0x28	; 40
     5b8:	b0 e0       	ldi	r27, 0x00	; 0
     5ba:	e8 e2       	ldi	r30, 0x28	; 40
     5bc:	f0 e0       	ldi	r31, 0x00	; 0
     5be:	80 81       	ld	r24, Z
     5c0:	8e 7f       	andi	r24, 0xFE	; 254
     5c2:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     5c4:	a8 e2       	ldi	r26, 0x28	; 40
     5c6:	b0 e0       	ldi	r27, 0x00	; 0
     5c8:	e8 e2       	ldi	r30, 0x28	; 40
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	80 81       	ld	r24, Z
     5ce:	8d 7f       	andi	r24, 0xFD	; 253
     5d0:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
     5d2:	e8 e2       	ldi	r30, 0x28	; 40
     5d4:	f0 e0       	ldi	r31, 0x00	; 0
     5d6:	80 e3       	ldi	r24, 0x30	; 48
     5d8:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
     5da:	a8 e2       	ldi	r26, 0x28	; 40
     5dc:	b0 e0       	ldi	r27, 0x00	; 0
     5de:	e8 e2       	ldi	r30, 0x28	; 40
     5e0:	f0 e0       	ldi	r31, 0x00	; 0
     5e2:	80 81       	ld	r24, Z
     5e4:	84 60       	ori	r24, 0x04	; 4
     5e6:	8c 93       	st	X, r24
     5e8:	fe 01       	movw	r30, r28
     5ea:	ed 5b       	subi	r30, 0xBD	; 189
     5ec:	ff 4f       	sbci	r31, 0xFF	; 255
     5ee:	80 e0       	ldi	r24, 0x00	; 0
     5f0:	90 e0       	ldi	r25, 0x00	; 0
     5f2:	a0 ea       	ldi	r26, 0xA0	; 160
     5f4:	b0 e4       	ldi	r27, 0x40	; 64
     5f6:	80 83       	st	Z, r24
     5f8:	91 83       	std	Z+1, r25	; 0x01
     5fa:	a2 83       	std	Z+2, r26	; 0x02
     5fc:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     5fe:	8e 01       	movw	r16, r28
     600:	01 5c       	subi	r16, 0xC1	; 193
     602:	1f 4f       	sbci	r17, 0xFF	; 255
     604:	fe 01       	movw	r30, r28
     606:	ed 5b       	subi	r30, 0xBD	; 189
     608:	ff 4f       	sbci	r31, 0xFF	; 255
     60a:	60 81       	ld	r22, Z
     60c:	71 81       	ldd	r23, Z+1	; 0x01
     60e:	82 81       	ldd	r24, Z+2	; 0x02
     610:	93 81       	ldd	r25, Z+3	; 0x03
     612:	26 e6       	ldi	r18, 0x66	; 102
     614:	36 e6       	ldi	r19, 0x66	; 102
     616:	46 e6       	ldi	r20, 0x66	; 102
     618:	55 e4       	ldi	r21, 0x45	; 69
     61a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     61e:	dc 01       	movw	r26, r24
     620:	cb 01       	movw	r24, r22
     622:	f8 01       	movw	r30, r16
     624:	80 83       	st	Z, r24
     626:	91 83       	std	Z+1, r25	; 0x01
     628:	a2 83       	std	Z+2, r26	; 0x02
     62a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
     62c:	fe 01       	movw	r30, r28
     62e:	ff 96       	adiw	r30, 0x3f	; 63
     630:	60 81       	ld	r22, Z
     632:	71 81       	ldd	r23, Z+1	; 0x01
     634:	82 81       	ldd	r24, Z+2	; 0x02
     636:	93 81       	ldd	r25, Z+3	; 0x03
     638:	20 e0       	ldi	r18, 0x00	; 0
     63a:	30 e0       	ldi	r19, 0x00	; 0
     63c:	40 e8       	ldi	r20, 0x80	; 128
     63e:	5f e3       	ldi	r21, 0x3F	; 63
     640:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     644:	88 23       	and	r24, r24
     646:	2c f4       	brge	.+10     	; 0x652 <lcd_set_4bit+0x528>
		__ticks = 1;
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	9e af       	std	Y+62, r25	; 0x3e
     64e:	8d af       	std	Y+61, r24	; 0x3d
     650:	46 c0       	rjmp	.+140    	; 0x6de <lcd_set_4bit+0x5b4>
	else if (__tmp > 65535)
     652:	fe 01       	movw	r30, r28
     654:	ff 96       	adiw	r30, 0x3f	; 63
     656:	60 81       	ld	r22, Z
     658:	71 81       	ldd	r23, Z+1	; 0x01
     65a:	82 81       	ldd	r24, Z+2	; 0x02
     65c:	93 81       	ldd	r25, Z+3	; 0x03
     65e:	20 e0       	ldi	r18, 0x00	; 0
     660:	3f ef       	ldi	r19, 0xFF	; 255
     662:	4f e7       	ldi	r20, 0x7F	; 127
     664:	57 e4       	ldi	r21, 0x47	; 71
     666:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     66a:	18 16       	cp	r1, r24
     66c:	64 f5       	brge	.+88     	; 0x6c6 <lcd_set_4bit+0x59c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     66e:	fe 01       	movw	r30, r28
     670:	ed 5b       	subi	r30, 0xBD	; 189
     672:	ff 4f       	sbci	r31, 0xFF	; 255
     674:	60 81       	ld	r22, Z
     676:	71 81       	ldd	r23, Z+1	; 0x01
     678:	82 81       	ldd	r24, Z+2	; 0x02
     67a:	93 81       	ldd	r25, Z+3	; 0x03
     67c:	20 e0       	ldi	r18, 0x00	; 0
     67e:	30 e0       	ldi	r19, 0x00	; 0
     680:	40 e2       	ldi	r20, 0x20	; 32
     682:	51 e4       	ldi	r21, 0x41	; 65
     684:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     688:	dc 01       	movw	r26, r24
     68a:	cb 01       	movw	r24, r22
     68c:	bc 01       	movw	r22, r24
     68e:	cd 01       	movw	r24, r26
     690:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     694:	dc 01       	movw	r26, r24
     696:	cb 01       	movw	r24, r22
     698:	9e af       	std	Y+62, r25	; 0x3e
     69a:	8d af       	std	Y+61, r24	; 0x3d
     69c:	0f c0       	rjmp	.+30     	; 0x6bc <lcd_set_4bit+0x592>
     69e:	80 e7       	ldi	r24, 0x70	; 112
     6a0:	91 e0       	ldi	r25, 0x01	; 1
     6a2:	9c af       	std	Y+60, r25	; 0x3c
     6a4:	8b af       	std	Y+59, r24	; 0x3b
     6a6:	8b ad       	ldd	r24, Y+59	; 0x3b
     6a8:	9c ad       	ldd	r25, Y+60	; 0x3c
     6aa:	01 97       	sbiw	r24, 0x01	; 1
     6ac:	f1 f7       	brne	.-4      	; 0x6aa <lcd_set_4bit+0x580>
     6ae:	9c af       	std	Y+60, r25	; 0x3c
     6b0:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6b2:	8d ad       	ldd	r24, Y+61	; 0x3d
     6b4:	9e ad       	ldd	r25, Y+62	; 0x3e
     6b6:	01 97       	sbiw	r24, 0x01	; 1
     6b8:	9e af       	std	Y+62, r25	; 0x3e
     6ba:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6bc:	8d ad       	ldd	r24, Y+61	; 0x3d
     6be:	9e ad       	ldd	r25, Y+62	; 0x3e
     6c0:	00 97       	sbiw	r24, 0x00	; 0
     6c2:	69 f7       	brne	.-38     	; 0x69e <lcd_set_4bit+0x574>
     6c4:	16 c0       	rjmp	.+44     	; 0x6f2 <lcd_set_4bit+0x5c8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     6c6:	fe 01       	movw	r30, r28
     6c8:	ff 96       	adiw	r30, 0x3f	; 63
     6ca:	60 81       	ld	r22, Z
     6cc:	71 81       	ldd	r23, Z+1	; 0x01
     6ce:	82 81       	ldd	r24, Z+2	; 0x02
     6d0:	93 81       	ldd	r25, Z+3	; 0x03
     6d2:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     6d6:	dc 01       	movw	r26, r24
     6d8:	cb 01       	movw	r24, r22
     6da:	9e af       	std	Y+62, r25	; 0x3e
     6dc:	8d af       	std	Y+61, r24	; 0x3d
     6de:	8d ad       	ldd	r24, Y+61	; 0x3d
     6e0:	9e ad       	ldd	r25, Y+62	; 0x3e
     6e2:	9a af       	std	Y+58, r25	; 0x3a
     6e4:	89 af       	std	Y+57, r24	; 0x39
     6e6:	89 ad       	ldd	r24, Y+57	; 0x39
     6e8:	9a ad       	ldd	r25, Y+58	; 0x3a
     6ea:	01 97       	sbiw	r24, 0x01	; 1
     6ec:	f1 f7       	brne	.-4      	; 0x6ea <lcd_set_4bit+0x5c0>
     6ee:	9a af       	std	Y+58, r25	; 0x3a
     6f0:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     6f2:	a8 e2       	ldi	r26, 0x28	; 40
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	e8 e2       	ldi	r30, 0x28	; 40
     6f8:	f0 e0       	ldi	r31, 0x00	; 0
     6fa:	80 81       	ld	r24, Z
     6fc:	8b 7f       	andi	r24, 0xFB	; 251
     6fe:	8c 93       	st	X, r24
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e8       	ldi	r26, 0x80	; 128
     706:	bf e3       	ldi	r27, 0x3F	; 63
     708:	8d ab       	std	Y+53, r24	; 0x35
     70a:	9e ab       	std	Y+54, r25	; 0x36
     70c:	af ab       	std	Y+55, r26	; 0x37
     70e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     710:	6d a9       	ldd	r22, Y+53	; 0x35
     712:	7e a9       	ldd	r23, Y+54	; 0x36
     714:	8f a9       	ldd	r24, Y+55	; 0x37
     716:	98 ad       	ldd	r25, Y+56	; 0x38
     718:	26 e6       	ldi	r18, 0x66	; 102
     71a:	36 e6       	ldi	r19, 0x66	; 102
     71c:	46 e6       	ldi	r20, 0x66	; 102
     71e:	55 e4       	ldi	r21, 0x45	; 69
     720:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     724:	dc 01       	movw	r26, r24
     726:	cb 01       	movw	r24, r22
     728:	89 ab       	std	Y+49, r24	; 0x31
     72a:	9a ab       	std	Y+50, r25	; 0x32
     72c:	ab ab       	std	Y+51, r26	; 0x33
     72e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
     730:	69 a9       	ldd	r22, Y+49	; 0x31
     732:	7a a9       	ldd	r23, Y+50	; 0x32
     734:	8b a9       	ldd	r24, Y+51	; 0x33
     736:	9c a9       	ldd	r25, Y+52	; 0x34
     738:	20 e0       	ldi	r18, 0x00	; 0
     73a:	30 e0       	ldi	r19, 0x00	; 0
     73c:	40 e8       	ldi	r20, 0x80	; 128
     73e:	5f e3       	ldi	r21, 0x3F	; 63
     740:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     744:	88 23       	and	r24, r24
     746:	2c f4       	brge	.+10     	; 0x752 <lcd_set_4bit+0x628>
		__ticks = 1;
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	98 ab       	std	Y+48, r25	; 0x30
     74e:	8f a7       	std	Y+47, r24	; 0x2f
     750:	3f c0       	rjmp	.+126    	; 0x7d0 <lcd_set_4bit+0x6a6>
	else if (__tmp > 65535)
     752:	69 a9       	ldd	r22, Y+49	; 0x31
     754:	7a a9       	ldd	r23, Y+50	; 0x32
     756:	8b a9       	ldd	r24, Y+51	; 0x33
     758:	9c a9       	ldd	r25, Y+52	; 0x34
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	3f ef       	ldi	r19, 0xFF	; 255
     75e:	4f e7       	ldi	r20, 0x7F	; 127
     760:	57 e4       	ldi	r21, 0x47	; 71
     762:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     766:	18 16       	cp	r1, r24
     768:	4c f5       	brge	.+82     	; 0x7bc <lcd_set_4bit+0x692>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     76a:	6d a9       	ldd	r22, Y+53	; 0x35
     76c:	7e a9       	ldd	r23, Y+54	; 0x36
     76e:	8f a9       	ldd	r24, Y+55	; 0x37
     770:	98 ad       	ldd	r25, Y+56	; 0x38
     772:	20 e0       	ldi	r18, 0x00	; 0
     774:	30 e0       	ldi	r19, 0x00	; 0
     776:	40 e2       	ldi	r20, 0x20	; 32
     778:	51 e4       	ldi	r21, 0x41	; 65
     77a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     77e:	dc 01       	movw	r26, r24
     780:	cb 01       	movw	r24, r22
     782:	bc 01       	movw	r22, r24
     784:	cd 01       	movw	r24, r26
     786:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     78a:	dc 01       	movw	r26, r24
     78c:	cb 01       	movw	r24, r22
     78e:	98 ab       	std	Y+48, r25	; 0x30
     790:	8f a7       	std	Y+47, r24	; 0x2f
     792:	0f c0       	rjmp	.+30     	; 0x7b2 <lcd_set_4bit+0x688>
     794:	80 e7       	ldi	r24, 0x70	; 112
     796:	91 e0       	ldi	r25, 0x01	; 1
     798:	9e a7       	std	Y+46, r25	; 0x2e
     79a:	8d a7       	std	Y+45, r24	; 0x2d
     79c:	8d a5       	ldd	r24, Y+45	; 0x2d
     79e:	9e a5       	ldd	r25, Y+46	; 0x2e
     7a0:	01 97       	sbiw	r24, 0x01	; 1
     7a2:	f1 f7       	brne	.-4      	; 0x7a0 <lcd_set_4bit+0x676>
     7a4:	9e a7       	std	Y+46, r25	; 0x2e
     7a6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7a8:	8f a5       	ldd	r24, Y+47	; 0x2f
     7aa:	98 a9       	ldd	r25, Y+48	; 0x30
     7ac:	01 97       	sbiw	r24, 0x01	; 1
     7ae:	98 ab       	std	Y+48, r25	; 0x30
     7b0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7b2:	8f a5       	ldd	r24, Y+47	; 0x2f
     7b4:	98 a9       	ldd	r25, Y+48	; 0x30
     7b6:	00 97       	sbiw	r24, 0x00	; 0
     7b8:	69 f7       	brne	.-38     	; 0x794 <lcd_set_4bit+0x66a>
     7ba:	14 c0       	rjmp	.+40     	; 0x7e4 <lcd_set_4bit+0x6ba>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     7bc:	69 a9       	ldd	r22, Y+49	; 0x31
     7be:	7a a9       	ldd	r23, Y+50	; 0x32
     7c0:	8b a9       	ldd	r24, Y+51	; 0x33
     7c2:	9c a9       	ldd	r25, Y+52	; 0x34
     7c4:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     7c8:	dc 01       	movw	r26, r24
     7ca:	cb 01       	movw	r24, r22
     7cc:	98 ab       	std	Y+48, r25	; 0x30
     7ce:	8f a7       	std	Y+47, r24	; 0x2f
     7d0:	8f a5       	ldd	r24, Y+47	; 0x2f
     7d2:	98 a9       	ldd	r25, Y+48	; 0x30
     7d4:	9c a7       	std	Y+44, r25	; 0x2c
     7d6:	8b a7       	std	Y+43, r24	; 0x2b
     7d8:	8b a5       	ldd	r24, Y+43	; 0x2b
     7da:	9c a5       	ldd	r25, Y+44	; 0x2c
     7dc:	01 97       	sbiw	r24, 0x01	; 1
     7de:	f1 f7       	brne	.-4      	; 0x7dc <lcd_set_4bit+0x6b2>
     7e0:	9c a7       	std	Y+44, r25	; 0x2c
     7e2:	8b a7       	std	Y+43, r24	; 0x2b

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     7e4:	a8 e2       	ldi	r26, 0x28	; 40
     7e6:	b0 e0       	ldi	r27, 0x00	; 0
     7e8:	e8 e2       	ldi	r30, 0x28	; 40
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	80 81       	ld	r24, Z
     7ee:	8e 7f       	andi	r24, 0xFE	; 254
     7f0:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     7f2:	a8 e2       	ldi	r26, 0x28	; 40
     7f4:	b0 e0       	ldi	r27, 0x00	; 0
     7f6:	e8 e2       	ldi	r30, 0x28	; 40
     7f8:	f0 e0       	ldi	r31, 0x00	; 0
     7fa:	80 81       	ld	r24, Z
     7fc:	8d 7f       	andi	r24, 0xFD	; 253
     7fe:	8c 93       	st	X, r24
	lcd_port = 0x30;				//Sending 3
     800:	e8 e2       	ldi	r30, 0x28	; 40
     802:	f0 e0       	ldi	r31, 0x00	; 0
     804:	80 e3       	ldi	r24, 0x30	; 48
     806:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
     808:	a8 e2       	ldi	r26, 0x28	; 40
     80a:	b0 e0       	ldi	r27, 0x00	; 0
     80c:	e8 e2       	ldi	r30, 0x28	; 40
     80e:	f0 e0       	ldi	r31, 0x00	; 0
     810:	80 81       	ld	r24, Z
     812:	84 60       	ori	r24, 0x04	; 4
     814:	8c 93       	st	X, r24
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 ea       	ldi	r26, 0xA0	; 160
     81c:	b0 e4       	ldi	r27, 0x40	; 64
     81e:	8f a3       	std	Y+39, r24	; 0x27
     820:	98 a7       	std	Y+40, r25	; 0x28
     822:	a9 a7       	std	Y+41, r26	; 0x29
     824:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     826:	6f a1       	ldd	r22, Y+39	; 0x27
     828:	78 a5       	ldd	r23, Y+40	; 0x28
     82a:	89 a5       	ldd	r24, Y+41	; 0x29
     82c:	9a a5       	ldd	r25, Y+42	; 0x2a
     82e:	26 e6       	ldi	r18, 0x66	; 102
     830:	36 e6       	ldi	r19, 0x66	; 102
     832:	46 e6       	ldi	r20, 0x66	; 102
     834:	55 e4       	ldi	r21, 0x45	; 69
     836:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     83a:	dc 01       	movw	r26, r24
     83c:	cb 01       	movw	r24, r22
     83e:	8b a3       	std	Y+35, r24	; 0x23
     840:	9c a3       	std	Y+36, r25	; 0x24
     842:	ad a3       	std	Y+37, r26	; 0x25
     844:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
     846:	6b a1       	ldd	r22, Y+35	; 0x23
     848:	7c a1       	ldd	r23, Y+36	; 0x24
     84a:	8d a1       	ldd	r24, Y+37	; 0x25
     84c:	9e a1       	ldd	r25, Y+38	; 0x26
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	30 e0       	ldi	r19, 0x00	; 0
     852:	40 e8       	ldi	r20, 0x80	; 128
     854:	5f e3       	ldi	r21, 0x3F	; 63
     856:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     85a:	88 23       	and	r24, r24
     85c:	2c f4       	brge	.+10     	; 0x868 <lcd_set_4bit+0x73e>
		__ticks = 1;
     85e:	81 e0       	ldi	r24, 0x01	; 1
     860:	90 e0       	ldi	r25, 0x00	; 0
     862:	9a a3       	std	Y+34, r25	; 0x22
     864:	89 a3       	std	Y+33, r24	; 0x21
     866:	3f c0       	rjmp	.+126    	; 0x8e6 <lcd_set_4bit+0x7bc>
	else if (__tmp > 65535)
     868:	6b a1       	ldd	r22, Y+35	; 0x23
     86a:	7c a1       	ldd	r23, Y+36	; 0x24
     86c:	8d a1       	ldd	r24, Y+37	; 0x25
     86e:	9e a1       	ldd	r25, Y+38	; 0x26
     870:	20 e0       	ldi	r18, 0x00	; 0
     872:	3f ef       	ldi	r19, 0xFF	; 255
     874:	4f e7       	ldi	r20, 0x7F	; 127
     876:	57 e4       	ldi	r21, 0x47	; 71
     878:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     87c:	18 16       	cp	r1, r24
     87e:	4c f5       	brge	.+82     	; 0x8d2 <lcd_set_4bit+0x7a8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     880:	6f a1       	ldd	r22, Y+39	; 0x27
     882:	78 a5       	ldd	r23, Y+40	; 0x28
     884:	89 a5       	ldd	r24, Y+41	; 0x29
     886:	9a a5       	ldd	r25, Y+42	; 0x2a
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	30 e0       	ldi	r19, 0x00	; 0
     88c:	40 e2       	ldi	r20, 0x20	; 32
     88e:	51 e4       	ldi	r21, 0x41	; 65
     890:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     894:	dc 01       	movw	r26, r24
     896:	cb 01       	movw	r24, r22
     898:	bc 01       	movw	r22, r24
     89a:	cd 01       	movw	r24, r26
     89c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     8a0:	dc 01       	movw	r26, r24
     8a2:	cb 01       	movw	r24, r22
     8a4:	9a a3       	std	Y+34, r25	; 0x22
     8a6:	89 a3       	std	Y+33, r24	; 0x21
     8a8:	0f c0       	rjmp	.+30     	; 0x8c8 <lcd_set_4bit+0x79e>
     8aa:	80 e7       	ldi	r24, 0x70	; 112
     8ac:	91 e0       	ldi	r25, 0x01	; 1
     8ae:	98 a3       	std	Y+32, r25	; 0x20
     8b0:	8f 8f       	std	Y+31, r24	; 0x1f
     8b2:	8f 8d       	ldd	r24, Y+31	; 0x1f
     8b4:	98 a1       	ldd	r25, Y+32	; 0x20
     8b6:	01 97       	sbiw	r24, 0x01	; 1
     8b8:	f1 f7       	brne	.-4      	; 0x8b6 <lcd_set_4bit+0x78c>
     8ba:	98 a3       	std	Y+32, r25	; 0x20
     8bc:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8be:	89 a1       	ldd	r24, Y+33	; 0x21
     8c0:	9a a1       	ldd	r25, Y+34	; 0x22
     8c2:	01 97       	sbiw	r24, 0x01	; 1
     8c4:	9a a3       	std	Y+34, r25	; 0x22
     8c6:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8c8:	89 a1       	ldd	r24, Y+33	; 0x21
     8ca:	9a a1       	ldd	r25, Y+34	; 0x22
     8cc:	00 97       	sbiw	r24, 0x00	; 0
     8ce:	69 f7       	brne	.-38     	; 0x8aa <lcd_set_4bit+0x780>
     8d0:	14 c0       	rjmp	.+40     	; 0x8fa <lcd_set_4bit+0x7d0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     8d2:	6b a1       	ldd	r22, Y+35	; 0x23
     8d4:	7c a1       	ldd	r23, Y+36	; 0x24
     8d6:	8d a1       	ldd	r24, Y+37	; 0x25
     8d8:	9e a1       	ldd	r25, Y+38	; 0x26
     8da:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     8de:	dc 01       	movw	r26, r24
     8e0:	cb 01       	movw	r24, r22
     8e2:	9a a3       	std	Y+34, r25	; 0x22
     8e4:	89 a3       	std	Y+33, r24	; 0x21
     8e6:	89 a1       	ldd	r24, Y+33	; 0x21
     8e8:	9a a1       	ldd	r25, Y+34	; 0x22
     8ea:	9e 8f       	std	Y+30, r25	; 0x1e
     8ec:	8d 8f       	std	Y+29, r24	; 0x1d
     8ee:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8f0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8f2:	01 97       	sbiw	r24, 0x01	; 1
     8f4:	f1 f7       	brne	.-4      	; 0x8f2 <lcd_set_4bit+0x7c8>
     8f6:	9e 8f       	std	Y+30, r25	; 0x1e
     8f8:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     8fa:	a8 e2       	ldi	r26, 0x28	; 40
     8fc:	b0 e0       	ldi	r27, 0x00	; 0
     8fe:	e8 e2       	ldi	r30, 0x28	; 40
     900:	f0 e0       	ldi	r31, 0x00	; 0
     902:	80 81       	ld	r24, Z
     904:	8b 7f       	andi	r24, 0xFB	; 251
     906:	8c 93       	st	X, r24
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	90 e0       	ldi	r25, 0x00	; 0
     90c:	a0 e8       	ldi	r26, 0x80	; 128
     90e:	bf e3       	ldi	r27, 0x3F	; 63
     910:	89 8f       	std	Y+25, r24	; 0x19
     912:	9a 8f       	std	Y+26, r25	; 0x1a
     914:	ab 8f       	std	Y+27, r26	; 0x1b
     916:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     918:	69 8d       	ldd	r22, Y+25	; 0x19
     91a:	7a 8d       	ldd	r23, Y+26	; 0x1a
     91c:	8b 8d       	ldd	r24, Y+27	; 0x1b
     91e:	9c 8d       	ldd	r25, Y+28	; 0x1c
     920:	26 e6       	ldi	r18, 0x66	; 102
     922:	36 e6       	ldi	r19, 0x66	; 102
     924:	46 e6       	ldi	r20, 0x66	; 102
     926:	55 e4       	ldi	r21, 0x45	; 69
     928:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     92c:	dc 01       	movw	r26, r24
     92e:	cb 01       	movw	r24, r22
     930:	8d 8b       	std	Y+21, r24	; 0x15
     932:	9e 8b       	std	Y+22, r25	; 0x16
     934:	af 8b       	std	Y+23, r26	; 0x17
     936:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     938:	6d 89       	ldd	r22, Y+21	; 0x15
     93a:	7e 89       	ldd	r23, Y+22	; 0x16
     93c:	8f 89       	ldd	r24, Y+23	; 0x17
     93e:	98 8d       	ldd	r25, Y+24	; 0x18
     940:	20 e0       	ldi	r18, 0x00	; 0
     942:	30 e0       	ldi	r19, 0x00	; 0
     944:	40 e8       	ldi	r20, 0x80	; 128
     946:	5f e3       	ldi	r21, 0x3F	; 63
     948:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     94c:	88 23       	and	r24, r24
     94e:	2c f4       	brge	.+10     	; 0x95a <lcd_set_4bit+0x830>
		__ticks = 1;
     950:	81 e0       	ldi	r24, 0x01	; 1
     952:	90 e0       	ldi	r25, 0x00	; 0
     954:	9c 8b       	std	Y+20, r25	; 0x14
     956:	8b 8b       	std	Y+19, r24	; 0x13
     958:	3f c0       	rjmp	.+126    	; 0x9d8 <lcd_set_4bit+0x8ae>
	else if (__tmp > 65535)
     95a:	6d 89       	ldd	r22, Y+21	; 0x15
     95c:	7e 89       	ldd	r23, Y+22	; 0x16
     95e:	8f 89       	ldd	r24, Y+23	; 0x17
     960:	98 8d       	ldd	r25, Y+24	; 0x18
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	3f ef       	ldi	r19, 0xFF	; 255
     966:	4f e7       	ldi	r20, 0x7F	; 127
     968:	57 e4       	ldi	r21, 0x47	; 71
     96a:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     96e:	18 16       	cp	r1, r24
     970:	4c f5       	brge	.+82     	; 0x9c4 <lcd_set_4bit+0x89a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     972:	69 8d       	ldd	r22, Y+25	; 0x19
     974:	7a 8d       	ldd	r23, Y+26	; 0x1a
     976:	8b 8d       	ldd	r24, Y+27	; 0x1b
     978:	9c 8d       	ldd	r25, Y+28	; 0x1c
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	30 e0       	ldi	r19, 0x00	; 0
     97e:	40 e2       	ldi	r20, 0x20	; 32
     980:	51 e4       	ldi	r21, 0x41	; 65
     982:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     986:	dc 01       	movw	r26, r24
     988:	cb 01       	movw	r24, r22
     98a:	bc 01       	movw	r22, r24
     98c:	cd 01       	movw	r24, r26
     98e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     992:	dc 01       	movw	r26, r24
     994:	cb 01       	movw	r24, r22
     996:	9c 8b       	std	Y+20, r25	; 0x14
     998:	8b 8b       	std	Y+19, r24	; 0x13
     99a:	0f c0       	rjmp	.+30     	; 0x9ba <lcd_set_4bit+0x890>
     99c:	80 e7       	ldi	r24, 0x70	; 112
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	9a 8b       	std	Y+18, r25	; 0x12
     9a2:	89 8b       	std	Y+17, r24	; 0x11
     9a4:	89 89       	ldd	r24, Y+17	; 0x11
     9a6:	9a 89       	ldd	r25, Y+18	; 0x12
     9a8:	01 97       	sbiw	r24, 0x01	; 1
     9aa:	f1 f7       	brne	.-4      	; 0x9a8 <lcd_set_4bit+0x87e>
     9ac:	9a 8b       	std	Y+18, r25	; 0x12
     9ae:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     9b0:	8b 89       	ldd	r24, Y+19	; 0x13
     9b2:	9c 89       	ldd	r25, Y+20	; 0x14
     9b4:	01 97       	sbiw	r24, 0x01	; 1
     9b6:	9c 8b       	std	Y+20, r25	; 0x14
     9b8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     9ba:	8b 89       	ldd	r24, Y+19	; 0x13
     9bc:	9c 89       	ldd	r25, Y+20	; 0x14
     9be:	00 97       	sbiw	r24, 0x00	; 0
     9c0:	69 f7       	brne	.-38     	; 0x99c <lcd_set_4bit+0x872>
     9c2:	14 c0       	rjmp	.+40     	; 0x9ec <lcd_set_4bit+0x8c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     9c4:	6d 89       	ldd	r22, Y+21	; 0x15
     9c6:	7e 89       	ldd	r23, Y+22	; 0x16
     9c8:	8f 89       	ldd	r24, Y+23	; 0x17
     9ca:	98 8d       	ldd	r25, Y+24	; 0x18
     9cc:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     9d0:	dc 01       	movw	r26, r24
     9d2:	cb 01       	movw	r24, r22
     9d4:	9c 8b       	std	Y+20, r25	; 0x14
     9d6:	8b 8b       	std	Y+19, r24	; 0x13
     9d8:	8b 89       	ldd	r24, Y+19	; 0x13
     9da:	9c 89       	ldd	r25, Y+20	; 0x14
     9dc:	98 8b       	std	Y+16, r25	; 0x10
     9de:	8f 87       	std	Y+15, r24	; 0x0f
     9e0:	8f 85       	ldd	r24, Y+15	; 0x0f
     9e2:	98 89       	ldd	r25, Y+16	; 0x10
     9e4:	01 97       	sbiw	r24, 0x01	; 1
     9e6:	f1 f7       	brne	.-4      	; 0x9e4 <lcd_set_4bit+0x8ba>
     9e8:	98 8b       	std	Y+16, r25	; 0x10
     9ea:	8f 87       	std	Y+15, r24	; 0x0f

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     9ec:	a8 e2       	ldi	r26, 0x28	; 40
     9ee:	b0 e0       	ldi	r27, 0x00	; 0
     9f0:	e8 e2       	ldi	r30, 0x28	; 40
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	80 81       	ld	r24, Z
     9f6:	8e 7f       	andi	r24, 0xFE	; 254
     9f8:	8c 93       	st	X, r24
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     9fa:	a8 e2       	ldi	r26, 0x28	; 40
     9fc:	b0 e0       	ldi	r27, 0x00	; 0
     9fe:	e8 e2       	ldi	r30, 0x28	; 40
     a00:	f0 e0       	ldi	r31, 0x00	; 0
     a02:	80 81       	ld	r24, Z
     a04:	8d 7f       	andi	r24, 0xFD	; 253
     a06:	8c 93       	st	X, r24
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     a08:	e8 e2       	ldi	r30, 0x28	; 40
     a0a:	f0 e0       	ldi	r31, 0x00	; 0
     a0c:	80 e2       	ldi	r24, 0x20	; 32
     a0e:	80 83       	st	Z, r24
	sbit(lcd_port,EN);				//Set Enable Pin
     a10:	a8 e2       	ldi	r26, 0x28	; 40
     a12:	b0 e0       	ldi	r27, 0x00	; 0
     a14:	e8 e2       	ldi	r30, 0x28	; 40
     a16:	f0 e0       	ldi	r31, 0x00	; 0
     a18:	80 81       	ld	r24, Z
     a1a:	84 60       	ori	r24, 0x04	; 4
     a1c:	8c 93       	st	X, r24
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	90 e0       	ldi	r25, 0x00	; 0
     a22:	a0 ea       	ldi	r26, 0xA0	; 160
     a24:	b0 e4       	ldi	r27, 0x40	; 64
     a26:	8b 87       	std	Y+11, r24	; 0x0b
     a28:	9c 87       	std	Y+12, r25	; 0x0c
     a2a:	ad 87       	std	Y+13, r26	; 0x0d
     a2c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     a2e:	6b 85       	ldd	r22, Y+11	; 0x0b
     a30:	7c 85       	ldd	r23, Y+12	; 0x0c
     a32:	8d 85       	ldd	r24, Y+13	; 0x0d
     a34:	9e 85       	ldd	r25, Y+14	; 0x0e
     a36:	26 e6       	ldi	r18, 0x66	; 102
     a38:	36 e6       	ldi	r19, 0x66	; 102
     a3a:	46 e6       	ldi	r20, 0x66	; 102
     a3c:	55 e4       	ldi	r21, 0x45	; 69
     a3e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     a42:	dc 01       	movw	r26, r24
     a44:	cb 01       	movw	r24, r22
     a46:	8f 83       	std	Y+7, r24	; 0x07
     a48:	98 87       	std	Y+8, r25	; 0x08
     a4a:	a9 87       	std	Y+9, r26	; 0x09
     a4c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     a4e:	6f 81       	ldd	r22, Y+7	; 0x07
     a50:	78 85       	ldd	r23, Y+8	; 0x08
     a52:	89 85       	ldd	r24, Y+9	; 0x09
     a54:	9a 85       	ldd	r25, Y+10	; 0x0a
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	40 e8       	ldi	r20, 0x80	; 128
     a5c:	5f e3       	ldi	r21, 0x3F	; 63
     a5e:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     a62:	88 23       	and	r24, r24
     a64:	2c f4       	brge	.+10     	; 0xa70 <lcd_set_4bit+0x946>
		__ticks = 1;
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	9e 83       	std	Y+6, r25	; 0x06
     a6c:	8d 83       	std	Y+5, r24	; 0x05
     a6e:	3f c0       	rjmp	.+126    	; 0xaee <lcd_set_4bit+0x9c4>
	else if (__tmp > 65535)
     a70:	6f 81       	ldd	r22, Y+7	; 0x07
     a72:	78 85       	ldd	r23, Y+8	; 0x08
     a74:	89 85       	ldd	r24, Y+9	; 0x09
     a76:	9a 85       	ldd	r25, Y+10	; 0x0a
     a78:	20 e0       	ldi	r18, 0x00	; 0
     a7a:	3f ef       	ldi	r19, 0xFF	; 255
     a7c:	4f e7       	ldi	r20, 0x7F	; 127
     a7e:	57 e4       	ldi	r21, 0x47	; 71
     a80:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     a84:	18 16       	cp	r1, r24
     a86:	4c f5       	brge	.+82     	; 0xada <lcd_set_4bit+0x9b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     a88:	6b 85       	ldd	r22, Y+11	; 0x0b
     a8a:	7c 85       	ldd	r23, Y+12	; 0x0c
     a8c:	8d 85       	ldd	r24, Y+13	; 0x0d
     a8e:	9e 85       	ldd	r25, Y+14	; 0x0e
     a90:	20 e0       	ldi	r18, 0x00	; 0
     a92:	30 e0       	ldi	r19, 0x00	; 0
     a94:	40 e2       	ldi	r20, 0x20	; 32
     a96:	51 e4       	ldi	r21, 0x41	; 65
     a98:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     a9c:	dc 01       	movw	r26, r24
     a9e:	cb 01       	movw	r24, r22
     aa0:	bc 01       	movw	r22, r24
     aa2:	cd 01       	movw	r24, r26
     aa4:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     aa8:	dc 01       	movw	r26, r24
     aaa:	cb 01       	movw	r24, r22
     aac:	9e 83       	std	Y+6, r25	; 0x06
     aae:	8d 83       	std	Y+5, r24	; 0x05
     ab0:	0f c0       	rjmp	.+30     	; 0xad0 <lcd_set_4bit+0x9a6>
     ab2:	80 e7       	ldi	r24, 0x70	; 112
     ab4:	91 e0       	ldi	r25, 0x01	; 1
     ab6:	9c 83       	std	Y+4, r25	; 0x04
     ab8:	8b 83       	std	Y+3, r24	; 0x03
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	f1 f7       	brne	.-4      	; 0xabe <lcd_set_4bit+0x994>
     ac2:	9c 83       	std	Y+4, r25	; 0x04
     ac4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ac6:	8d 81       	ldd	r24, Y+5	; 0x05
     ac8:	9e 81       	ldd	r25, Y+6	; 0x06
     aca:	01 97       	sbiw	r24, 0x01	; 1
     acc:	9e 83       	std	Y+6, r25	; 0x06
     ace:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ad0:	8d 81       	ldd	r24, Y+5	; 0x05
     ad2:	9e 81       	ldd	r25, Y+6	; 0x06
     ad4:	00 97       	sbiw	r24, 0x00	; 0
     ad6:	69 f7       	brne	.-38     	; 0xab2 <lcd_set_4bit+0x988>
     ad8:	14 c0       	rjmp	.+40     	; 0xb02 <lcd_set_4bit+0x9d8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     ada:	6f 81       	ldd	r22, Y+7	; 0x07
     adc:	78 85       	ldd	r23, Y+8	; 0x08
     ade:	89 85       	ldd	r24, Y+9	; 0x09
     ae0:	9a 85       	ldd	r25, Y+10	; 0x0a
     ae2:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     ae6:	dc 01       	movw	r26, r24
     ae8:	cb 01       	movw	r24, r22
     aea:	9e 83       	std	Y+6, r25	; 0x06
     aec:	8d 83       	std	Y+5, r24	; 0x05
     aee:	8d 81       	ldd	r24, Y+5	; 0x05
     af0:	9e 81       	ldd	r25, Y+6	; 0x06
     af2:	9a 83       	std	Y+2, r25	; 0x02
     af4:	89 83       	std	Y+1, r24	; 0x01
     af6:	89 81       	ldd	r24, Y+1	; 0x01
     af8:	9a 81       	ldd	r25, Y+2	; 0x02
     afa:	01 97       	sbiw	r24, 0x01	; 1
     afc:	f1 f7       	brne	.-4      	; 0xafa <lcd_set_4bit+0x9d0>
     afe:	9a 83       	std	Y+2, r25	; 0x02
     b00:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     b02:	a8 e2       	ldi	r26, 0x28	; 40
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 e2       	ldi	r30, 0x28	; 40
     b08:	f0 e0       	ldi	r31, 0x00	; 0
     b0a:	80 81       	ld	r24, Z
     b0c:	8b 7f       	andi	r24, 0xFB	; 251
     b0e:	8c 93       	st	X, r24

	
}
     b10:	c0 59       	subi	r28, 0x90	; 144
     b12:	df 4f       	sbci	r29, 0xFF	; 255
     b14:	0f b6       	in	r0, 0x3f	; 63
     b16:	f8 94       	cli
     b18:	de bf       	out	0x3e, r29	; 62
     b1a:	0f be       	out	0x3f, r0	; 63
     b1c:	cd bf       	out	0x3d, r28	; 61
     b1e:	cf 91       	pop	r28
     b20:	df 91       	pop	r29
     b22:	1f 91       	pop	r17
     b24:	0f 91       	pop	r16
     b26:	08 95       	ret

00000b28 <lcd_init>:

//Function to Initialize LCD
void lcd_init()
{
     b28:	df 93       	push	r29
     b2a:	cf 93       	push	r28
     b2c:	cd b7       	in	r28, 0x3d	; 61
     b2e:	de b7       	in	r29, 0x3e	; 62
     b30:	2e 97       	sbiw	r28, 0x0e	; 14
     b32:	0f b6       	in	r0, 0x3f	; 63
     b34:	f8 94       	cli
     b36:	de bf       	out	0x3e, r29	; 62
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	cd bf       	out	0x3d, r28	; 61
	lcd_set_4bit();
     b3c:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_set_4bit>
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	a0 e8       	ldi	r26, 0x80	; 128
     b46:	bf e3       	ldi	r27, 0x3F	; 63
     b48:	8b 87       	std	Y+11, r24	; 0x0b
     b4a:	9c 87       	std	Y+12, r25	; 0x0c
     b4c:	ad 87       	std	Y+13, r26	; 0x0d
     b4e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     b50:	6b 85       	ldd	r22, Y+11	; 0x0b
     b52:	7c 85       	ldd	r23, Y+12	; 0x0c
     b54:	8d 85       	ldd	r24, Y+13	; 0x0d
     b56:	9e 85       	ldd	r25, Y+14	; 0x0e
     b58:	26 e6       	ldi	r18, 0x66	; 102
     b5a:	36 e6       	ldi	r19, 0x66	; 102
     b5c:	46 e6       	ldi	r20, 0x66	; 102
     b5e:	55 e4       	ldi	r21, 0x45	; 69
     b60:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     b64:	dc 01       	movw	r26, r24
     b66:	cb 01       	movw	r24, r22
     b68:	8f 83       	std	Y+7, r24	; 0x07
     b6a:	98 87       	std	Y+8, r25	; 0x08
     b6c:	a9 87       	std	Y+9, r26	; 0x09
     b6e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     b70:	6f 81       	ldd	r22, Y+7	; 0x07
     b72:	78 85       	ldd	r23, Y+8	; 0x08
     b74:	89 85       	ldd	r24, Y+9	; 0x09
     b76:	9a 85       	ldd	r25, Y+10	; 0x0a
     b78:	20 e0       	ldi	r18, 0x00	; 0
     b7a:	30 e0       	ldi	r19, 0x00	; 0
     b7c:	40 e8       	ldi	r20, 0x80	; 128
     b7e:	5f e3       	ldi	r21, 0x3F	; 63
     b80:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     b84:	88 23       	and	r24, r24
     b86:	2c f4       	brge	.+10     	; 0xb92 <lcd_init+0x6a>
		__ticks = 1;
     b88:	81 e0       	ldi	r24, 0x01	; 1
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	9e 83       	std	Y+6, r25	; 0x06
     b8e:	8d 83       	std	Y+5, r24	; 0x05
     b90:	3f c0       	rjmp	.+126    	; 0xc10 <lcd_init+0xe8>
	else if (__tmp > 65535)
     b92:	6f 81       	ldd	r22, Y+7	; 0x07
     b94:	78 85       	ldd	r23, Y+8	; 0x08
     b96:	89 85       	ldd	r24, Y+9	; 0x09
     b98:	9a 85       	ldd	r25, Y+10	; 0x0a
     b9a:	20 e0       	ldi	r18, 0x00	; 0
     b9c:	3f ef       	ldi	r19, 0xFF	; 255
     b9e:	4f e7       	ldi	r20, 0x7F	; 127
     ba0:	57 e4       	ldi	r21, 0x47	; 71
     ba2:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     ba6:	18 16       	cp	r1, r24
     ba8:	4c f5       	brge	.+82     	; 0xbfc <lcd_init+0xd4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     baa:	6b 85       	ldd	r22, Y+11	; 0x0b
     bac:	7c 85       	ldd	r23, Y+12	; 0x0c
     bae:	8d 85       	ldd	r24, Y+13	; 0x0d
     bb0:	9e 85       	ldd	r25, Y+14	; 0x0e
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	30 e0       	ldi	r19, 0x00	; 0
     bb6:	40 e2       	ldi	r20, 0x20	; 32
     bb8:	51 e4       	ldi	r21, 0x41	; 65
     bba:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     bbe:	dc 01       	movw	r26, r24
     bc0:	cb 01       	movw	r24, r22
     bc2:	bc 01       	movw	r22, r24
     bc4:	cd 01       	movw	r24, r26
     bc6:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     bca:	dc 01       	movw	r26, r24
     bcc:	cb 01       	movw	r24, r22
     bce:	9e 83       	std	Y+6, r25	; 0x06
     bd0:	8d 83       	std	Y+5, r24	; 0x05
     bd2:	0f c0       	rjmp	.+30     	; 0xbf2 <lcd_init+0xca>
     bd4:	80 e7       	ldi	r24, 0x70	; 112
     bd6:	91 e0       	ldi	r25, 0x01	; 1
     bd8:	9c 83       	std	Y+4, r25	; 0x04
     bda:	8b 83       	std	Y+3, r24	; 0x03
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	9c 81       	ldd	r25, Y+4	; 0x04
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	f1 f7       	brne	.-4      	; 0xbe0 <lcd_init+0xb8>
     be4:	9c 83       	std	Y+4, r25	; 0x04
     be6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     be8:	8d 81       	ldd	r24, Y+5	; 0x05
     bea:	9e 81       	ldd	r25, Y+6	; 0x06
     bec:	01 97       	sbiw	r24, 0x01	; 1
     bee:	9e 83       	std	Y+6, r25	; 0x06
     bf0:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     bf2:	8d 81       	ldd	r24, Y+5	; 0x05
     bf4:	9e 81       	ldd	r25, Y+6	; 0x06
     bf6:	00 97       	sbiw	r24, 0x00	; 0
     bf8:	69 f7       	brne	.-38     	; 0xbd4 <lcd_init+0xac>
     bfa:	14 c0       	rjmp	.+40     	; 0xc24 <lcd_init+0xfc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     bfc:	6f 81       	ldd	r22, Y+7	; 0x07
     bfe:	78 85       	ldd	r23, Y+8	; 0x08
     c00:	89 85       	ldd	r24, Y+9	; 0x09
     c02:	9a 85       	ldd	r25, Y+10	; 0x0a
     c04:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     c08:	dc 01       	movw	r26, r24
     c0a:	cb 01       	movw	r24, r22
     c0c:	9e 83       	std	Y+6, r25	; 0x06
     c0e:	8d 83       	std	Y+5, r24	; 0x05
     c10:	8d 81       	ldd	r24, Y+5	; 0x05
     c12:	9e 81       	ldd	r25, Y+6	; 0x06
     c14:	9a 83       	std	Y+2, r25	; 0x02
     c16:	89 83       	std	Y+1, r24	; 0x01
     c18:	89 81       	ldd	r24, Y+1	; 0x01
     c1a:	9a 81       	ldd	r25, Y+2	; 0x02
     c1c:	01 97       	sbiw	r24, 0x01	; 1
     c1e:	f1 f7       	brne	.-4      	; 0xc1c <lcd_init+0xf4>
     c20:	9a 83       	std	Y+2, r25	; 0x02
     c22:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     c24:	88 e2       	ldi	r24, 0x28	; 40
     c26:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
	lcd_wr_command(0x01);
     c2a:	81 e0       	ldi	r24, 0x01	; 1
     c2c:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
	lcd_wr_command(0x06);
     c30:	86 e0       	ldi	r24, 0x06	; 6
     c32:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
	lcd_wr_command(0x0E);
     c36:	8e e0       	ldi	r24, 0x0E	; 14
     c38:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
	lcd_wr_command(0x80);
     c3c:	80 e8       	ldi	r24, 0x80	; 128
     c3e:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
		
}
     c42:	2e 96       	adiw	r28, 0x0e	; 14
     c44:	0f b6       	in	r0, 0x3f	; 63
     c46:	f8 94       	cli
     c48:	de bf       	out	0x3e, r29	; 62
     c4a:	0f be       	out	0x3f, r0	; 63
     c4c:	cd bf       	out	0x3d, r28	; 61
     c4e:	cf 91       	pop	r28
     c50:	df 91       	pop	r29
     c52:	08 95       	ret

00000c54 <lcd_wr_command>:

	 
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
     c54:	df 93       	push	r29
     c56:	cf 93       	push	r28
     c58:	cd b7       	in	r28, 0x3d	; 61
     c5a:	de b7       	in	r29, 0x3e	; 62
     c5c:	6e 97       	sbiw	r28, 0x1e	; 30
     c5e:	0f b6       	in	r0, 0x3f	; 63
     c60:	f8 94       	cli
     c62:	de bf       	out	0x3e, r29	; 62
     c64:	0f be       	out	0x3f, r0	; 63
     c66:	cd bf       	out	0x3d, r28	; 61
     c68:	8e 8f       	std	Y+30, r24	; 0x1e
	unsigned char temp;
	temp = cmd;
     c6a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c6c:	8d 8f       	std	Y+29, r24	; 0x1d
	temp = temp & 0xF0;
     c6e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c70:	80 7f       	andi	r24, 0xF0	; 240
     c72:	8d 8f       	std	Y+29, r24	; 0x1d
	lcd_port &= 0x0F;
     c74:	a8 e2       	ldi	r26, 0x28	; 40
     c76:	b0 e0       	ldi	r27, 0x00	; 0
     c78:	e8 e2       	ldi	r30, 0x28	; 40
     c7a:	f0 e0       	ldi	r31, 0x00	; 0
     c7c:	80 81       	ld	r24, Z
     c7e:	8f 70       	andi	r24, 0x0F	; 15
     c80:	8c 93       	st	X, r24
	lcd_port |= temp;
     c82:	a8 e2       	ldi	r26, 0x28	; 40
     c84:	b0 e0       	ldi	r27, 0x00	; 0
     c86:	e8 e2       	ldi	r30, 0x28	; 40
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	90 81       	ld	r25, Z
     c8c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c8e:	89 2b       	or	r24, r25
     c90:	8c 93       	st	X, r24
	cbit(lcd_port,RS);
     c92:	a8 e2       	ldi	r26, 0x28	; 40
     c94:	b0 e0       	ldi	r27, 0x00	; 0
     c96:	e8 e2       	ldi	r30, 0x28	; 40
     c98:	f0 e0       	ldi	r31, 0x00	; 0
     c9a:	80 81       	ld	r24, Z
     c9c:	8e 7f       	andi	r24, 0xFE	; 254
     c9e:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
     ca0:	a8 e2       	ldi	r26, 0x28	; 40
     ca2:	b0 e0       	ldi	r27, 0x00	; 0
     ca4:	e8 e2       	ldi	r30, 0x28	; 40
     ca6:	f0 e0       	ldi	r31, 0x00	; 0
     ca8:	80 81       	ld	r24, Z
     caa:	8d 7f       	andi	r24, 0xFD	; 253
     cac:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
     cae:	a8 e2       	ldi	r26, 0x28	; 40
     cb0:	b0 e0       	ldi	r27, 0x00	; 0
     cb2:	e8 e2       	ldi	r30, 0x28	; 40
     cb4:	f0 e0       	ldi	r31, 0x00	; 0
     cb6:	80 81       	ld	r24, Z
     cb8:	84 60       	ori	r24, 0x04	; 4
     cba:	8c 93       	st	X, r24
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	90 e0       	ldi	r25, 0x00	; 0
     cc0:	a0 ea       	ldi	r26, 0xA0	; 160
     cc2:	b0 e4       	ldi	r27, 0x40	; 64
     cc4:	89 8f       	std	Y+25, r24	; 0x19
     cc6:	9a 8f       	std	Y+26, r25	; 0x1a
     cc8:	ab 8f       	std	Y+27, r26	; 0x1b
     cca:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     ccc:	69 8d       	ldd	r22, Y+25	; 0x19
     cce:	7a 8d       	ldd	r23, Y+26	; 0x1a
     cd0:	8b 8d       	ldd	r24, Y+27	; 0x1b
     cd2:	9c 8d       	ldd	r25, Y+28	; 0x1c
     cd4:	26 e6       	ldi	r18, 0x66	; 102
     cd6:	36 e6       	ldi	r19, 0x66	; 102
     cd8:	46 e6       	ldi	r20, 0x66	; 102
     cda:	55 e4       	ldi	r21, 0x45	; 69
     cdc:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     ce0:	dc 01       	movw	r26, r24
     ce2:	cb 01       	movw	r24, r22
     ce4:	8d 8b       	std	Y+21, r24	; 0x15
     ce6:	9e 8b       	std	Y+22, r25	; 0x16
     ce8:	af 8b       	std	Y+23, r26	; 0x17
     cea:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     cec:	6d 89       	ldd	r22, Y+21	; 0x15
     cee:	7e 89       	ldd	r23, Y+22	; 0x16
     cf0:	8f 89       	ldd	r24, Y+23	; 0x17
     cf2:	98 8d       	ldd	r25, Y+24	; 0x18
     cf4:	20 e0       	ldi	r18, 0x00	; 0
     cf6:	30 e0       	ldi	r19, 0x00	; 0
     cf8:	40 e8       	ldi	r20, 0x80	; 128
     cfa:	5f e3       	ldi	r21, 0x3F	; 63
     cfc:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     d00:	88 23       	and	r24, r24
     d02:	2c f4       	brge	.+10     	; 0xd0e <lcd_wr_command+0xba>
		__ticks = 1;
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	9c 8b       	std	Y+20, r25	; 0x14
     d0a:	8b 8b       	std	Y+19, r24	; 0x13
     d0c:	3f c0       	rjmp	.+126    	; 0xd8c <lcd_wr_command+0x138>
	else if (__tmp > 65535)
     d0e:	6d 89       	ldd	r22, Y+21	; 0x15
     d10:	7e 89       	ldd	r23, Y+22	; 0x16
     d12:	8f 89       	ldd	r24, Y+23	; 0x17
     d14:	98 8d       	ldd	r25, Y+24	; 0x18
     d16:	20 e0       	ldi	r18, 0x00	; 0
     d18:	3f ef       	ldi	r19, 0xFF	; 255
     d1a:	4f e7       	ldi	r20, 0x7F	; 127
     d1c:	57 e4       	ldi	r21, 0x47	; 71
     d1e:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     d22:	18 16       	cp	r1, r24
     d24:	4c f5       	brge	.+82     	; 0xd78 <lcd_wr_command+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d26:	69 8d       	ldd	r22, Y+25	; 0x19
     d28:	7a 8d       	ldd	r23, Y+26	; 0x1a
     d2a:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d2c:	9c 8d       	ldd	r25, Y+28	; 0x1c
     d2e:	20 e0       	ldi	r18, 0x00	; 0
     d30:	30 e0       	ldi	r19, 0x00	; 0
     d32:	40 e2       	ldi	r20, 0x20	; 32
     d34:	51 e4       	ldi	r21, 0x41	; 65
     d36:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     d3a:	dc 01       	movw	r26, r24
     d3c:	cb 01       	movw	r24, r22
     d3e:	bc 01       	movw	r22, r24
     d40:	cd 01       	movw	r24, r26
     d42:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     d46:	dc 01       	movw	r26, r24
     d48:	cb 01       	movw	r24, r22
     d4a:	9c 8b       	std	Y+20, r25	; 0x14
     d4c:	8b 8b       	std	Y+19, r24	; 0x13
     d4e:	0f c0       	rjmp	.+30     	; 0xd6e <lcd_wr_command+0x11a>
     d50:	80 e7       	ldi	r24, 0x70	; 112
     d52:	91 e0       	ldi	r25, 0x01	; 1
     d54:	9a 8b       	std	Y+18, r25	; 0x12
     d56:	89 8b       	std	Y+17, r24	; 0x11
     d58:	89 89       	ldd	r24, Y+17	; 0x11
     d5a:	9a 89       	ldd	r25, Y+18	; 0x12
     d5c:	01 97       	sbiw	r24, 0x01	; 1
     d5e:	f1 f7       	brne	.-4      	; 0xd5c <lcd_wr_command+0x108>
     d60:	9a 8b       	std	Y+18, r25	; 0x12
     d62:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     d64:	8b 89       	ldd	r24, Y+19	; 0x13
     d66:	9c 89       	ldd	r25, Y+20	; 0x14
     d68:	01 97       	sbiw	r24, 0x01	; 1
     d6a:	9c 8b       	std	Y+20, r25	; 0x14
     d6c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d6e:	8b 89       	ldd	r24, Y+19	; 0x13
     d70:	9c 89       	ldd	r25, Y+20	; 0x14
     d72:	00 97       	sbiw	r24, 0x00	; 0
     d74:	69 f7       	brne	.-38     	; 0xd50 <lcd_wr_command+0xfc>
     d76:	14 c0       	rjmp	.+40     	; 0xda0 <lcd_wr_command+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d78:	6d 89       	ldd	r22, Y+21	; 0x15
     d7a:	7e 89       	ldd	r23, Y+22	; 0x16
     d7c:	8f 89       	ldd	r24, Y+23	; 0x17
     d7e:	98 8d       	ldd	r25, Y+24	; 0x18
     d80:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     d84:	dc 01       	movw	r26, r24
     d86:	cb 01       	movw	r24, r22
     d88:	9c 8b       	std	Y+20, r25	; 0x14
     d8a:	8b 8b       	std	Y+19, r24	; 0x13
     d8c:	8b 89       	ldd	r24, Y+19	; 0x13
     d8e:	9c 89       	ldd	r25, Y+20	; 0x14
     d90:	98 8b       	std	Y+16, r25	; 0x10
     d92:	8f 87       	std	Y+15, r24	; 0x0f
     d94:	8f 85       	ldd	r24, Y+15	; 0x0f
     d96:	98 89       	ldd	r25, Y+16	; 0x10
     d98:	01 97       	sbiw	r24, 0x01	; 1
     d9a:	f1 f7       	brne	.-4      	; 0xd98 <lcd_wr_command+0x144>
     d9c:	98 8b       	std	Y+16, r25	; 0x10
     d9e:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	cbit(lcd_port,EN);
     da0:	a8 e2       	ldi	r26, 0x28	; 40
     da2:	b0 e0       	ldi	r27, 0x00	; 0
     da4:	e8 e2       	ldi	r30, 0x28	; 40
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	80 81       	ld	r24, Z
     daa:	8b 7f       	andi	r24, 0xFB	; 251
     dac:	8c 93       	st	X, r24
	
	cmd = cmd & 0x0F;
     dae:	8e 8d       	ldd	r24, Y+30	; 0x1e
     db0:	8f 70       	andi	r24, 0x0F	; 15
     db2:	8e 8f       	std	Y+30, r24	; 0x1e
	cmd = cmd<<4;
     db4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     db6:	82 95       	swap	r24
     db8:	80 7f       	andi	r24, 0xF0	; 240
     dba:	8e 8f       	std	Y+30, r24	; 0x1e
	lcd_port &= 0x0F;
     dbc:	a8 e2       	ldi	r26, 0x28	; 40
     dbe:	b0 e0       	ldi	r27, 0x00	; 0
     dc0:	e8 e2       	ldi	r30, 0x28	; 40
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	80 81       	ld	r24, Z
     dc6:	8f 70       	andi	r24, 0x0F	; 15
     dc8:	8c 93       	st	X, r24
	lcd_port |= cmd;
     dca:	a8 e2       	ldi	r26, 0x28	; 40
     dcc:	b0 e0       	ldi	r27, 0x00	; 0
     dce:	e8 e2       	ldi	r30, 0x28	; 40
     dd0:	f0 e0       	ldi	r31, 0x00	; 0
     dd2:	90 81       	ld	r25, Z
     dd4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     dd6:	89 2b       	or	r24, r25
     dd8:	8c 93       	st	X, r24
	cbit(lcd_port,RS);
     dda:	a8 e2       	ldi	r26, 0x28	; 40
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	e8 e2       	ldi	r30, 0x28	; 40
     de0:	f0 e0       	ldi	r31, 0x00	; 0
     de2:	80 81       	ld	r24, Z
     de4:	8e 7f       	andi	r24, 0xFE	; 254
     de6:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
     de8:	a8 e2       	ldi	r26, 0x28	; 40
     dea:	b0 e0       	ldi	r27, 0x00	; 0
     dec:	e8 e2       	ldi	r30, 0x28	; 40
     dee:	f0 e0       	ldi	r31, 0x00	; 0
     df0:	80 81       	ld	r24, Z
     df2:	8d 7f       	andi	r24, 0xFD	; 253
     df4:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
     df6:	a8 e2       	ldi	r26, 0x28	; 40
     df8:	b0 e0       	ldi	r27, 0x00	; 0
     dfa:	e8 e2       	ldi	r30, 0x28	; 40
     dfc:	f0 e0       	ldi	r31, 0x00	; 0
     dfe:	80 81       	ld	r24, Z
     e00:	84 60       	ori	r24, 0x04	; 4
     e02:	8c 93       	st	X, r24
     e04:	80 e0       	ldi	r24, 0x00	; 0
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	a0 ea       	ldi	r26, 0xA0	; 160
     e0a:	b0 e4       	ldi	r27, 0x40	; 64
     e0c:	8b 87       	std	Y+11, r24	; 0x0b
     e0e:	9c 87       	std	Y+12, r25	; 0x0c
     e10:	ad 87       	std	Y+13, r26	; 0x0d
     e12:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     e14:	6b 85       	ldd	r22, Y+11	; 0x0b
     e16:	7c 85       	ldd	r23, Y+12	; 0x0c
     e18:	8d 85       	ldd	r24, Y+13	; 0x0d
     e1a:	9e 85       	ldd	r25, Y+14	; 0x0e
     e1c:	26 e6       	ldi	r18, 0x66	; 102
     e1e:	36 e6       	ldi	r19, 0x66	; 102
     e20:	46 e6       	ldi	r20, 0x66	; 102
     e22:	55 e4       	ldi	r21, 0x45	; 69
     e24:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     e28:	dc 01       	movw	r26, r24
     e2a:	cb 01       	movw	r24, r22
     e2c:	8f 83       	std	Y+7, r24	; 0x07
     e2e:	98 87       	std	Y+8, r25	; 0x08
     e30:	a9 87       	std	Y+9, r26	; 0x09
     e32:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     e34:	6f 81       	ldd	r22, Y+7	; 0x07
     e36:	78 85       	ldd	r23, Y+8	; 0x08
     e38:	89 85       	ldd	r24, Y+9	; 0x09
     e3a:	9a 85       	ldd	r25, Y+10	; 0x0a
     e3c:	20 e0       	ldi	r18, 0x00	; 0
     e3e:	30 e0       	ldi	r19, 0x00	; 0
     e40:	40 e8       	ldi	r20, 0x80	; 128
     e42:	5f e3       	ldi	r21, 0x3F	; 63
     e44:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     e48:	88 23       	and	r24, r24
     e4a:	2c f4       	brge	.+10     	; 0xe56 <lcd_wr_command+0x202>
		__ticks = 1;
     e4c:	81 e0       	ldi	r24, 0x01	; 1
     e4e:	90 e0       	ldi	r25, 0x00	; 0
     e50:	9e 83       	std	Y+6, r25	; 0x06
     e52:	8d 83       	std	Y+5, r24	; 0x05
     e54:	3f c0       	rjmp	.+126    	; 0xed4 <lcd_wr_command+0x280>
	else if (__tmp > 65535)
     e56:	6f 81       	ldd	r22, Y+7	; 0x07
     e58:	78 85       	ldd	r23, Y+8	; 0x08
     e5a:	89 85       	ldd	r24, Y+9	; 0x09
     e5c:	9a 85       	ldd	r25, Y+10	; 0x0a
     e5e:	20 e0       	ldi	r18, 0x00	; 0
     e60:	3f ef       	ldi	r19, 0xFF	; 255
     e62:	4f e7       	ldi	r20, 0x7F	; 127
     e64:	57 e4       	ldi	r21, 0x47	; 71
     e66:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     e6a:	18 16       	cp	r1, r24
     e6c:	4c f5       	brge	.+82     	; 0xec0 <lcd_wr_command+0x26c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     e6e:	6b 85       	ldd	r22, Y+11	; 0x0b
     e70:	7c 85       	ldd	r23, Y+12	; 0x0c
     e72:	8d 85       	ldd	r24, Y+13	; 0x0d
     e74:	9e 85       	ldd	r25, Y+14	; 0x0e
     e76:	20 e0       	ldi	r18, 0x00	; 0
     e78:	30 e0       	ldi	r19, 0x00	; 0
     e7a:	40 e2       	ldi	r20, 0x20	; 32
     e7c:	51 e4       	ldi	r21, 0x41	; 65
     e7e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     e82:	dc 01       	movw	r26, r24
     e84:	cb 01       	movw	r24, r22
     e86:	bc 01       	movw	r22, r24
     e88:	cd 01       	movw	r24, r26
     e8a:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     e8e:	dc 01       	movw	r26, r24
     e90:	cb 01       	movw	r24, r22
     e92:	9e 83       	std	Y+6, r25	; 0x06
     e94:	8d 83       	std	Y+5, r24	; 0x05
     e96:	0f c0       	rjmp	.+30     	; 0xeb6 <lcd_wr_command+0x262>
     e98:	80 e7       	ldi	r24, 0x70	; 112
     e9a:	91 e0       	ldi	r25, 0x01	; 1
     e9c:	9c 83       	std	Y+4, r25	; 0x04
     e9e:	8b 83       	std	Y+3, r24	; 0x03
     ea0:	8b 81       	ldd	r24, Y+3	; 0x03
     ea2:	9c 81       	ldd	r25, Y+4	; 0x04
     ea4:	01 97       	sbiw	r24, 0x01	; 1
     ea6:	f1 f7       	brne	.-4      	; 0xea4 <lcd_wr_command+0x250>
     ea8:	9c 83       	std	Y+4, r25	; 0x04
     eaa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     eac:	8d 81       	ldd	r24, Y+5	; 0x05
     eae:	9e 81       	ldd	r25, Y+6	; 0x06
     eb0:	01 97       	sbiw	r24, 0x01	; 1
     eb2:	9e 83       	std	Y+6, r25	; 0x06
     eb4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     eb6:	8d 81       	ldd	r24, Y+5	; 0x05
     eb8:	9e 81       	ldd	r25, Y+6	; 0x06
     eba:	00 97       	sbiw	r24, 0x00	; 0
     ebc:	69 f7       	brne	.-38     	; 0xe98 <lcd_wr_command+0x244>
     ebe:	14 c0       	rjmp	.+40     	; 0xee8 <lcd_wr_command+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     ec0:	6f 81       	ldd	r22, Y+7	; 0x07
     ec2:	78 85       	ldd	r23, Y+8	; 0x08
     ec4:	89 85       	ldd	r24, Y+9	; 0x09
     ec6:	9a 85       	ldd	r25, Y+10	; 0x0a
     ec8:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     ecc:	dc 01       	movw	r26, r24
     ece:	cb 01       	movw	r24, r22
     ed0:	9e 83       	std	Y+6, r25	; 0x06
     ed2:	8d 83       	std	Y+5, r24	; 0x05
     ed4:	8d 81       	ldd	r24, Y+5	; 0x05
     ed6:	9e 81       	ldd	r25, Y+6	; 0x06
     ed8:	9a 83       	std	Y+2, r25	; 0x02
     eda:	89 83       	std	Y+1, r24	; 0x01
     edc:	89 81       	ldd	r24, Y+1	; 0x01
     ede:	9a 81       	ldd	r25, Y+2	; 0x02
     ee0:	01 97       	sbiw	r24, 0x01	; 1
     ee2:	f1 f7       	brne	.-4      	; 0xee0 <lcd_wr_command+0x28c>
     ee4:	9a 83       	std	Y+2, r25	; 0x02
     ee6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
	cbit(lcd_port,EN);
     ee8:	a8 e2       	ldi	r26, 0x28	; 40
     eea:	b0 e0       	ldi	r27, 0x00	; 0
     eec:	e8 e2       	ldi	r30, 0x28	; 40
     eee:	f0 e0       	ldi	r31, 0x00	; 0
     ef0:	80 81       	ld	r24, Z
     ef2:	8b 7f       	andi	r24, 0xFB	; 251
     ef4:	8c 93       	st	X, r24
}
     ef6:	6e 96       	adiw	r28, 0x1e	; 30
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	cf 91       	pop	r28
     f04:	df 91       	pop	r29
     f06:	08 95       	ret

00000f08 <lcd_wr_char>:

//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
     f08:	df 93       	push	r29
     f0a:	cf 93       	push	r28
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	6e 97       	sbiw	r28, 0x1e	; 30
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 8f       	std	Y+30, r24	; 0x1e
	char temp;
	temp = letter;
     f1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f20:	8d 8f       	std	Y+29, r24	; 0x1d
	temp = (temp & 0xF0);
     f22:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f24:	80 7f       	andi	r24, 0xF0	; 240
     f26:	8d 8f       	std	Y+29, r24	; 0x1d
	lcd_port &= 0x0F;
     f28:	a8 e2       	ldi	r26, 0x28	; 40
     f2a:	b0 e0       	ldi	r27, 0x00	; 0
     f2c:	e8 e2       	ldi	r30, 0x28	; 40
     f2e:	f0 e0       	ldi	r31, 0x00	; 0
     f30:	80 81       	ld	r24, Z
     f32:	8f 70       	andi	r24, 0x0F	; 15
     f34:	8c 93       	st	X, r24
	lcd_port |= temp;
     f36:	a8 e2       	ldi	r26, 0x28	; 40
     f38:	b0 e0       	ldi	r27, 0x00	; 0
     f3a:	e8 e2       	ldi	r30, 0x28	; 40
     f3c:	f0 e0       	ldi	r31, 0x00	; 0
     f3e:	90 81       	ld	r25, Z
     f40:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f42:	89 2b       	or	r24, r25
     f44:	8c 93       	st	X, r24
	sbit(lcd_port,RS);
     f46:	a8 e2       	ldi	r26, 0x28	; 40
     f48:	b0 e0       	ldi	r27, 0x00	; 0
     f4a:	e8 e2       	ldi	r30, 0x28	; 40
     f4c:	f0 e0       	ldi	r31, 0x00	; 0
     f4e:	80 81       	ld	r24, Z
     f50:	81 60       	ori	r24, 0x01	; 1
     f52:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
     f54:	a8 e2       	ldi	r26, 0x28	; 40
     f56:	b0 e0       	ldi	r27, 0x00	; 0
     f58:	e8 e2       	ldi	r30, 0x28	; 40
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	8d 7f       	andi	r24, 0xFD	; 253
     f60:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
     f62:	a8 e2       	ldi	r26, 0x28	; 40
     f64:	b0 e0       	ldi	r27, 0x00	; 0
     f66:	e8 e2       	ldi	r30, 0x28	; 40
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	80 81       	ld	r24, Z
     f6c:	84 60       	ori	r24, 0x04	; 4
     f6e:	8c 93       	st	X, r24
     f70:	80 e0       	ldi	r24, 0x00	; 0
     f72:	90 e0       	ldi	r25, 0x00	; 0
     f74:	a0 ea       	ldi	r26, 0xA0	; 160
     f76:	b0 e4       	ldi	r27, 0x40	; 64
     f78:	89 8f       	std	Y+25, r24	; 0x19
     f7a:	9a 8f       	std	Y+26, r25	; 0x1a
     f7c:	ab 8f       	std	Y+27, r26	; 0x1b
     f7e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     f80:	69 8d       	ldd	r22, Y+25	; 0x19
     f82:	7a 8d       	ldd	r23, Y+26	; 0x1a
     f84:	8b 8d       	ldd	r24, Y+27	; 0x1b
     f86:	9c 8d       	ldd	r25, Y+28	; 0x1c
     f88:	26 e6       	ldi	r18, 0x66	; 102
     f8a:	36 e6       	ldi	r19, 0x66	; 102
     f8c:	46 e6       	ldi	r20, 0x66	; 102
     f8e:	55 e4       	ldi	r21, 0x45	; 69
     f90:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     f94:	dc 01       	movw	r26, r24
     f96:	cb 01       	movw	r24, r22
     f98:	8d 8b       	std	Y+21, r24	; 0x15
     f9a:	9e 8b       	std	Y+22, r25	; 0x16
     f9c:	af 8b       	std	Y+23, r26	; 0x17
     f9e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
     fa0:	6d 89       	ldd	r22, Y+21	; 0x15
     fa2:	7e 89       	ldd	r23, Y+22	; 0x16
     fa4:	8f 89       	ldd	r24, Y+23	; 0x17
     fa6:	98 8d       	ldd	r25, Y+24	; 0x18
     fa8:	20 e0       	ldi	r18, 0x00	; 0
     faa:	30 e0       	ldi	r19, 0x00	; 0
     fac:	40 e8       	ldi	r20, 0x80	; 128
     fae:	5f e3       	ldi	r21, 0x3F	; 63
     fb0:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
     fb4:	88 23       	and	r24, r24
     fb6:	2c f4       	brge	.+10     	; 0xfc2 <lcd_wr_char+0xba>
		__ticks = 1;
     fb8:	81 e0       	ldi	r24, 0x01	; 1
     fba:	90 e0       	ldi	r25, 0x00	; 0
     fbc:	9c 8b       	std	Y+20, r25	; 0x14
     fbe:	8b 8b       	std	Y+19, r24	; 0x13
     fc0:	3f c0       	rjmp	.+126    	; 0x1040 <lcd_wr_char+0x138>
	else if (__tmp > 65535)
     fc2:	6d 89       	ldd	r22, Y+21	; 0x15
     fc4:	7e 89       	ldd	r23, Y+22	; 0x16
     fc6:	8f 89       	ldd	r24, Y+23	; 0x17
     fc8:	98 8d       	ldd	r25, Y+24	; 0x18
     fca:	20 e0       	ldi	r18, 0x00	; 0
     fcc:	3f ef       	ldi	r19, 0xFF	; 255
     fce:	4f e7       	ldi	r20, 0x7F	; 127
     fd0:	57 e4       	ldi	r21, 0x47	; 71
     fd2:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
     fd6:	18 16       	cp	r1, r24
     fd8:	4c f5       	brge	.+82     	; 0x102c <lcd_wr_char+0x124>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     fda:	69 8d       	ldd	r22, Y+25	; 0x19
     fdc:	7a 8d       	ldd	r23, Y+26	; 0x1a
     fde:	8b 8d       	ldd	r24, Y+27	; 0x1b
     fe0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     fe2:	20 e0       	ldi	r18, 0x00	; 0
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	40 e2       	ldi	r20, 0x20	; 32
     fe8:	51 e4       	ldi	r21, 0x41	; 65
     fea:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
     fee:	dc 01       	movw	r26, r24
     ff0:	cb 01       	movw	r24, r22
     ff2:	bc 01       	movw	r22, r24
     ff4:	cd 01       	movw	r24, r26
     ff6:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
     ffa:	dc 01       	movw	r26, r24
     ffc:	cb 01       	movw	r24, r22
     ffe:	9c 8b       	std	Y+20, r25	; 0x14
    1000:	8b 8b       	std	Y+19, r24	; 0x13
    1002:	0f c0       	rjmp	.+30     	; 0x1022 <lcd_wr_char+0x11a>
    1004:	80 e7       	ldi	r24, 0x70	; 112
    1006:	91 e0       	ldi	r25, 0x01	; 1
    1008:	9a 8b       	std	Y+18, r25	; 0x12
    100a:	89 8b       	std	Y+17, r24	; 0x11
    100c:	89 89       	ldd	r24, Y+17	; 0x11
    100e:	9a 89       	ldd	r25, Y+18	; 0x12
    1010:	01 97       	sbiw	r24, 0x01	; 1
    1012:	f1 f7       	brne	.-4      	; 0x1010 <lcd_wr_char+0x108>
    1014:	9a 8b       	std	Y+18, r25	; 0x12
    1016:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1018:	8b 89       	ldd	r24, Y+19	; 0x13
    101a:	9c 89       	ldd	r25, Y+20	; 0x14
    101c:	01 97       	sbiw	r24, 0x01	; 1
    101e:	9c 8b       	std	Y+20, r25	; 0x14
    1020:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1022:	8b 89       	ldd	r24, Y+19	; 0x13
    1024:	9c 89       	ldd	r25, Y+20	; 0x14
    1026:	00 97       	sbiw	r24, 0x00	; 0
    1028:	69 f7       	brne	.-38     	; 0x1004 <lcd_wr_char+0xfc>
    102a:	14 c0       	rjmp	.+40     	; 0x1054 <lcd_wr_char+0x14c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    102c:	6d 89       	ldd	r22, Y+21	; 0x15
    102e:	7e 89       	ldd	r23, Y+22	; 0x16
    1030:	8f 89       	ldd	r24, Y+23	; 0x17
    1032:	98 8d       	ldd	r25, Y+24	; 0x18
    1034:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1038:	dc 01       	movw	r26, r24
    103a:	cb 01       	movw	r24, r22
    103c:	9c 8b       	std	Y+20, r25	; 0x14
    103e:	8b 8b       	std	Y+19, r24	; 0x13
    1040:	8b 89       	ldd	r24, Y+19	; 0x13
    1042:	9c 89       	ldd	r25, Y+20	; 0x14
    1044:	98 8b       	std	Y+16, r25	; 0x10
    1046:	8f 87       	std	Y+15, r24	; 0x0f
    1048:	8f 85       	ldd	r24, Y+15	; 0x0f
    104a:	98 89       	ldd	r25, Y+16	; 0x10
    104c:	01 97       	sbiw	r24, 0x01	; 1
    104e:	f1 f7       	brne	.-4      	; 0x104c <lcd_wr_char+0x144>
    1050:	98 8b       	std	Y+16, r25	; 0x10
    1052:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	cbit(lcd_port,EN);
    1054:	a8 e2       	ldi	r26, 0x28	; 40
    1056:	b0 e0       	ldi	r27, 0x00	; 0
    1058:	e8 e2       	ldi	r30, 0x28	; 40
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	8b 7f       	andi	r24, 0xFB	; 251
    1060:	8c 93       	st	X, r24

	letter = letter & 0x0F;
    1062:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1064:	8f 70       	andi	r24, 0x0F	; 15
    1066:	8e 8f       	std	Y+30, r24	; 0x1e
	letter = letter<<4;
    1068:	8e 8d       	ldd	r24, Y+30	; 0x1e
    106a:	82 95       	swap	r24
    106c:	80 7f       	andi	r24, 0xF0	; 240
    106e:	8e 8f       	std	Y+30, r24	; 0x1e
	lcd_port &= 0x0F;
    1070:	a8 e2       	ldi	r26, 0x28	; 40
    1072:	b0 e0       	ldi	r27, 0x00	; 0
    1074:	e8 e2       	ldi	r30, 0x28	; 40
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	80 81       	ld	r24, Z
    107a:	8f 70       	andi	r24, 0x0F	; 15
    107c:	8c 93       	st	X, r24
	lcd_port |= letter;
    107e:	a8 e2       	ldi	r26, 0x28	; 40
    1080:	b0 e0       	ldi	r27, 0x00	; 0
    1082:	e8 e2       	ldi	r30, 0x28	; 40
    1084:	f0 e0       	ldi	r31, 0x00	; 0
    1086:	90 81       	ld	r25, Z
    1088:	8e 8d       	ldd	r24, Y+30	; 0x1e
    108a:	89 2b       	or	r24, r25
    108c:	8c 93       	st	X, r24
	sbit(lcd_port,RS);
    108e:	a8 e2       	ldi	r26, 0x28	; 40
    1090:	b0 e0       	ldi	r27, 0x00	; 0
    1092:	e8 e2       	ldi	r30, 0x28	; 40
    1094:	f0 e0       	ldi	r31, 0x00	; 0
    1096:	80 81       	ld	r24, Z
    1098:	81 60       	ori	r24, 0x01	; 1
    109a:	8c 93       	st	X, r24
	cbit(lcd_port,RW);
    109c:	a8 e2       	ldi	r26, 0x28	; 40
    109e:	b0 e0       	ldi	r27, 0x00	; 0
    10a0:	e8 e2       	ldi	r30, 0x28	; 40
    10a2:	f0 e0       	ldi	r31, 0x00	; 0
    10a4:	80 81       	ld	r24, Z
    10a6:	8d 7f       	andi	r24, 0xFD	; 253
    10a8:	8c 93       	st	X, r24
	sbit(lcd_port,EN);
    10aa:	a8 e2       	ldi	r26, 0x28	; 40
    10ac:	b0 e0       	ldi	r27, 0x00	; 0
    10ae:	e8 e2       	ldi	r30, 0x28	; 40
    10b0:	f0 e0       	ldi	r31, 0x00	; 0
    10b2:	80 81       	ld	r24, Z
    10b4:	84 60       	ori	r24, 0x04	; 4
    10b6:	8c 93       	st	X, r24
    10b8:	80 e0       	ldi	r24, 0x00	; 0
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	a0 ea       	ldi	r26, 0xA0	; 160
    10be:	b0 e4       	ldi	r27, 0x40	; 64
    10c0:	8b 87       	std	Y+11, r24	; 0x0b
    10c2:	9c 87       	std	Y+12, r25	; 0x0c
    10c4:	ad 87       	std	Y+13, r26	; 0x0d
    10c6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    10c8:	6b 85       	ldd	r22, Y+11	; 0x0b
    10ca:	7c 85       	ldd	r23, Y+12	; 0x0c
    10cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    10ce:	9e 85       	ldd	r25, Y+14	; 0x0e
    10d0:	26 e6       	ldi	r18, 0x66	; 102
    10d2:	36 e6       	ldi	r19, 0x66	; 102
    10d4:	46 e6       	ldi	r20, 0x66	; 102
    10d6:	55 e4       	ldi	r21, 0x45	; 69
    10d8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    10dc:	dc 01       	movw	r26, r24
    10de:	cb 01       	movw	r24, r22
    10e0:	8f 83       	std	Y+7, r24	; 0x07
    10e2:	98 87       	std	Y+8, r25	; 0x08
    10e4:	a9 87       	std	Y+9, r26	; 0x09
    10e6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    10e8:	6f 81       	ldd	r22, Y+7	; 0x07
    10ea:	78 85       	ldd	r23, Y+8	; 0x08
    10ec:	89 85       	ldd	r24, Y+9	; 0x09
    10ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    10f0:	20 e0       	ldi	r18, 0x00	; 0
    10f2:	30 e0       	ldi	r19, 0x00	; 0
    10f4:	40 e8       	ldi	r20, 0x80	; 128
    10f6:	5f e3       	ldi	r21, 0x3F	; 63
    10f8:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    10fc:	88 23       	and	r24, r24
    10fe:	2c f4       	brge	.+10     	; 0x110a <lcd_wr_char+0x202>
		__ticks = 1;
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	9e 83       	std	Y+6, r25	; 0x06
    1106:	8d 83       	std	Y+5, r24	; 0x05
    1108:	3f c0       	rjmp	.+126    	; 0x1188 <lcd_wr_char+0x280>
	else if (__tmp > 65535)
    110a:	6f 81       	ldd	r22, Y+7	; 0x07
    110c:	78 85       	ldd	r23, Y+8	; 0x08
    110e:	89 85       	ldd	r24, Y+9	; 0x09
    1110:	9a 85       	ldd	r25, Y+10	; 0x0a
    1112:	20 e0       	ldi	r18, 0x00	; 0
    1114:	3f ef       	ldi	r19, 0xFF	; 255
    1116:	4f e7       	ldi	r20, 0x7F	; 127
    1118:	57 e4       	ldi	r21, 0x47	; 71
    111a:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    111e:	18 16       	cp	r1, r24
    1120:	4c f5       	brge	.+82     	; 0x1174 <lcd_wr_char+0x26c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1122:	6b 85       	ldd	r22, Y+11	; 0x0b
    1124:	7c 85       	ldd	r23, Y+12	; 0x0c
    1126:	8d 85       	ldd	r24, Y+13	; 0x0d
    1128:	9e 85       	ldd	r25, Y+14	; 0x0e
    112a:	20 e0       	ldi	r18, 0x00	; 0
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	40 e2       	ldi	r20, 0x20	; 32
    1130:	51 e4       	ldi	r21, 0x41	; 65
    1132:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    1136:	dc 01       	movw	r26, r24
    1138:	cb 01       	movw	r24, r22
    113a:	bc 01       	movw	r22, r24
    113c:	cd 01       	movw	r24, r26
    113e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1142:	dc 01       	movw	r26, r24
    1144:	cb 01       	movw	r24, r22
    1146:	9e 83       	std	Y+6, r25	; 0x06
    1148:	8d 83       	std	Y+5, r24	; 0x05
    114a:	0f c0       	rjmp	.+30     	; 0x116a <lcd_wr_char+0x262>
    114c:	80 e7       	ldi	r24, 0x70	; 112
    114e:	91 e0       	ldi	r25, 0x01	; 1
    1150:	9c 83       	std	Y+4, r25	; 0x04
    1152:	8b 83       	std	Y+3, r24	; 0x03
    1154:	8b 81       	ldd	r24, Y+3	; 0x03
    1156:	9c 81       	ldd	r25, Y+4	; 0x04
    1158:	01 97       	sbiw	r24, 0x01	; 1
    115a:	f1 f7       	brne	.-4      	; 0x1158 <lcd_wr_char+0x250>
    115c:	9c 83       	std	Y+4, r25	; 0x04
    115e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1160:	8d 81       	ldd	r24, Y+5	; 0x05
    1162:	9e 81       	ldd	r25, Y+6	; 0x06
    1164:	01 97       	sbiw	r24, 0x01	; 1
    1166:	9e 83       	std	Y+6, r25	; 0x06
    1168:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    116a:	8d 81       	ldd	r24, Y+5	; 0x05
    116c:	9e 81       	ldd	r25, Y+6	; 0x06
    116e:	00 97       	sbiw	r24, 0x00	; 0
    1170:	69 f7       	brne	.-38     	; 0x114c <lcd_wr_char+0x244>
    1172:	14 c0       	rjmp	.+40     	; 0x119c <lcd_wr_char+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1174:	6f 81       	ldd	r22, Y+7	; 0x07
    1176:	78 85       	ldd	r23, Y+8	; 0x08
    1178:	89 85       	ldd	r24, Y+9	; 0x09
    117a:	9a 85       	ldd	r25, Y+10	; 0x0a
    117c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1180:	dc 01       	movw	r26, r24
    1182:	cb 01       	movw	r24, r22
    1184:	9e 83       	std	Y+6, r25	; 0x06
    1186:	8d 83       	std	Y+5, r24	; 0x05
    1188:	8d 81       	ldd	r24, Y+5	; 0x05
    118a:	9e 81       	ldd	r25, Y+6	; 0x06
    118c:	9a 83       	std	Y+2, r25	; 0x02
    118e:	89 83       	std	Y+1, r24	; 0x01
    1190:	89 81       	ldd	r24, Y+1	; 0x01
    1192:	9a 81       	ldd	r25, Y+2	; 0x02
    1194:	01 97       	sbiw	r24, 0x01	; 1
    1196:	f1 f7       	brne	.-4      	; 0x1194 <lcd_wr_char+0x28c>
    1198:	9a 83       	std	Y+2, r25	; 0x02
    119a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
	cbit(lcd_port,EN);
    119c:	a8 e2       	ldi	r26, 0x28	; 40
    119e:	b0 e0       	ldi	r27, 0x00	; 0
    11a0:	e8 e2       	ldi	r30, 0x28	; 40
    11a2:	f0 e0       	ldi	r31, 0x00	; 0
    11a4:	80 81       	ld	r24, Z
    11a6:	8b 7f       	andi	r24, 0xFB	; 251
    11a8:	8c 93       	st	X, r24
}
    11aa:	6e 96       	adiw	r28, 0x1e	; 30
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	de bf       	out	0x3e, r29	; 62
    11b2:	0f be       	out	0x3f, r0	; 63
    11b4:	cd bf       	out	0x3d, r28	; 61
    11b6:	cf 91       	pop	r28
    11b8:	df 91       	pop	r29
    11ba:	08 95       	ret

000011bc <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
    11bc:	df 93       	push	r29
    11be:	cf 93       	push	r28
    11c0:	cd b7       	in	r28, 0x3d	; 61
    11c2:	de b7       	in	r29, 0x3e	; 62
	lcd_wr_command(0x80);
    11c4:	80 e8       	ldi	r24, 0x80	; 128
    11c6:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
}
    11ca:	cf 91       	pop	r28
    11cc:	df 91       	pop	r29
    11ce:	08 95       	ret

000011d0 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
    11d0:	df 93       	push	r29
    11d2:	cf 93       	push	r28
    11d4:	0f 92       	push	r0
    11d6:	0f 92       	push	r0
    11d8:	cd b7       	in	r28, 0x3d	; 61
    11da:	de b7       	in	r29, 0x3e	; 62
    11dc:	9a 83       	std	Y+2, r25	; 0x02
    11de:	89 83       	std	Y+1, r24	; 0x01
    11e0:	0a c0       	rjmp	.+20     	; 0x11f6 <lcd_string+0x26>
	while(*str != '\0')
	{
		lcd_wr_char(*str);
    11e2:	e9 81       	ldd	r30, Y+1	; 0x01
    11e4:	fa 81       	ldd	r31, Y+2	; 0x02
    11e6:	80 81       	ld	r24, Z
    11e8:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
		str++;
    11ec:	89 81       	ldd	r24, Y+1	; 0x01
    11ee:	9a 81       	ldd	r25, Y+2	; 0x02
    11f0:	01 96       	adiw	r24, 0x01	; 1
    11f2:	9a 83       	std	Y+2, r25	; 0x02
    11f4:	89 83       	std	Y+1, r24	; 0x01


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
    11f6:	e9 81       	ldd	r30, Y+1	; 0x01
    11f8:	fa 81       	ldd	r31, Y+2	; 0x02
    11fa:	80 81       	ld	r24, Z
    11fc:	88 23       	and	r24, r24
    11fe:	89 f7       	brne	.-30     	; 0x11e2 <lcd_string+0x12>
	{
		lcd_wr_char(*str);
		str++;
	}
}
    1200:	0f 90       	pop	r0
    1202:	0f 90       	pop	r0
    1204:	cf 91       	pop	r28
    1206:	df 91       	pop	r29
    1208:	08 95       	ret

0000120a <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
    120a:	df 93       	push	r29
    120c:	cf 93       	push	r28
    120e:	00 d0       	rcall	.+0      	; 0x1210 <lcd_cursor+0x6>
    1210:	0f 92       	push	r0
    1212:	cd b7       	in	r28, 0x3d	; 61
    1214:	de b7       	in	r29, 0x3e	; 62
    1216:	89 83       	std	Y+1, r24	; 0x01
    1218:	6a 83       	std	Y+2, r22	; 0x02
	switch (row) {
    121a:	89 81       	ldd	r24, Y+1	; 0x01
    121c:	28 2f       	mov	r18, r24
    121e:	30 e0       	ldi	r19, 0x00	; 0
    1220:	3c 83       	std	Y+4, r19	; 0x04
    1222:	2b 83       	std	Y+3, r18	; 0x03
    1224:	8b 81       	ldd	r24, Y+3	; 0x03
    1226:	9c 81       	ldd	r25, Y+4	; 0x04
    1228:	82 30       	cpi	r24, 0x02	; 2
    122a:	91 05       	cpc	r25, r1
    122c:	d9 f0       	breq	.+54     	; 0x1264 <lcd_cursor+0x5a>
    122e:	2b 81       	ldd	r18, Y+3	; 0x03
    1230:	3c 81       	ldd	r19, Y+4	; 0x04
    1232:	23 30       	cpi	r18, 0x03	; 3
    1234:	31 05       	cpc	r19, r1
    1236:	34 f4       	brge	.+12     	; 0x1244 <lcd_cursor+0x3a>
    1238:	8b 81       	ldd	r24, Y+3	; 0x03
    123a:	9c 81       	ldd	r25, Y+4	; 0x04
    123c:	81 30       	cpi	r24, 0x01	; 1
    123e:	91 05       	cpc	r25, r1
    1240:	61 f0       	breq	.+24     	; 0x125a <lcd_cursor+0x50>
    1242:	1e c0       	rjmp	.+60     	; 0x1280 <lcd_cursor+0x76>
    1244:	2b 81       	ldd	r18, Y+3	; 0x03
    1246:	3c 81       	ldd	r19, Y+4	; 0x04
    1248:	23 30       	cpi	r18, 0x03	; 3
    124a:	31 05       	cpc	r19, r1
    124c:	81 f0       	breq	.+32     	; 0x126e <lcd_cursor+0x64>
    124e:	8b 81       	ldd	r24, Y+3	; 0x03
    1250:	9c 81       	ldd	r25, Y+4	; 0x04
    1252:	84 30       	cpi	r24, 0x04	; 4
    1254:	91 05       	cpc	r25, r1
    1256:	81 f0       	breq	.+32     	; 0x1278 <lcd_cursor+0x6e>
    1258:	13 c0       	rjmp	.+38     	; 0x1280 <lcd_cursor+0x76>
		case 1: lcd_wr_command (0x80 + column - 1); break;
    125a:	8a 81       	ldd	r24, Y+2	; 0x02
    125c:	81 58       	subi	r24, 0x81	; 129
    125e:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
    1262:	0e c0       	rjmp	.+28     	; 0x1280 <lcd_cursor+0x76>
		case 2: lcd_wr_command (0xc0 + column - 1); break;
    1264:	8a 81       	ldd	r24, Y+2	; 0x02
    1266:	81 54       	subi	r24, 0x41	; 65
    1268:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
    126c:	09 c0       	rjmp	.+18     	; 0x1280 <lcd_cursor+0x76>
		case 3: lcd_wr_command (0x94 + column - 1); break;
    126e:	8a 81       	ldd	r24, Y+2	; 0x02
    1270:	8d 56       	subi	r24, 0x6D	; 109
    1272:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
    1276:	04 c0       	rjmp	.+8      	; 0x1280 <lcd_cursor+0x76>
		case 4: lcd_wr_command (0xd4 + column - 1); break;
    1278:	8a 81       	ldd	r24, Y+2	; 0x02
    127a:	8d 52       	subi	r24, 0x2D	; 45
    127c:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
		default: break;
	}
}
    1280:	0f 90       	pop	r0
    1282:	0f 90       	pop	r0
    1284:	0f 90       	pop	r0
    1286:	0f 90       	pop	r0
    1288:	cf 91       	pop	r28
    128a:	df 91       	pop	r29
    128c:	08 95       	ret

0000128e <lcd_print>:

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
    128e:	df 93       	push	r29
    1290:	cf 93       	push	r28
    1292:	cd b7       	in	r28, 0x3d	; 61
    1294:	de b7       	in	r29, 0x3e	; 62
    1296:	27 97       	sbiw	r28, 0x07	; 7
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	de bf       	out	0x3e, r29	; 62
    129e:	0f be       	out	0x3f, r0	; 63
    12a0:	cd bf       	out	0x3d, r28	; 61
    12a2:	8a 83       	std	Y+2, r24	; 0x02
    12a4:	6b 83       	std	Y+3, r22	; 0x03
    12a6:	5d 83       	std	Y+5, r21	; 0x05
    12a8:	4c 83       	std	Y+4, r20	; 0x04
    12aa:	3f 83       	std	Y+7, r19	; 0x07
    12ac:	2e 83       	std	Y+6, r18	; 0x06
	unsigned char flag=0;
    12ae:	19 82       	std	Y+1, r1	; 0x01
	if(row==0||coloumn==0)
    12b0:	8a 81       	ldd	r24, Y+2	; 0x02
    12b2:	88 23       	and	r24, r24
    12b4:	19 f0       	breq	.+6      	; 0x12bc <lcd_print+0x2e>
    12b6:	8b 81       	ldd	r24, Y+3	; 0x03
    12b8:	88 23       	and	r24, r24
    12ba:	19 f4       	brne	.+6      	; 0x12c2 <lcd_print+0x34>
	{
		lcd_home();
    12bc:	0e 94 de 08 	call	0x11bc	; 0x11bc <lcd_home>
    12c0:	04 c0       	rjmp	.+8      	; 0x12ca <lcd_print+0x3c>
	}
	else
	{
		lcd_cursor(row,coloumn);
    12c2:	8a 81       	ldd	r24, Y+2	; 0x02
    12c4:	6b 81       	ldd	r22, Y+3	; 0x03
    12c6:	0e 94 05 09 	call	0x120a	; 0x120a <lcd_cursor>
	}
	if(digits==5 || flag==1)
    12ca:	8e 81       	ldd	r24, Y+6	; 0x06
    12cc:	9f 81       	ldd	r25, Y+7	; 0x07
    12ce:	85 30       	cpi	r24, 0x05	; 5
    12d0:	91 05       	cpc	r25, r1
    12d2:	19 f0       	breq	.+6      	; 0x12da <lcd_print+0x4c>
    12d4:	89 81       	ldd	r24, Y+1	; 0x01
    12d6:	81 30       	cpi	r24, 0x01	; 1
    12d8:	a9 f4       	brne	.+42     	; 0x1304 <lcd_print+0x76>
	{
		million=value/10000+48;
    12da:	8c 81       	ldd	r24, Y+4	; 0x04
    12dc:	9d 81       	ldd	r25, Y+5	; 0x05
    12de:	20 e1       	ldi	r18, 0x10	; 16
    12e0:	37 e2       	ldi	r19, 0x27	; 39
    12e2:	b9 01       	movw	r22, r18
    12e4:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    12e8:	cb 01       	movw	r24, r22
    12ea:	c0 96       	adiw	r24, 0x30	; 48
    12ec:	90 93 3b 03 	sts	0x033B, r25
    12f0:	80 93 3a 03 	sts	0x033A, r24
		lcd_wr_char(million);
    12f4:	80 91 3a 03 	lds	r24, 0x033A
    12f8:	90 91 3b 03 	lds	r25, 0x033B
    12fc:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
		flag=1;
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==4 || flag==1)
    1304:	8e 81       	ldd	r24, Y+6	; 0x06
    1306:	9f 81       	ldd	r25, Y+7	; 0x07
    1308:	84 30       	cpi	r24, 0x04	; 4
    130a:	91 05       	cpc	r25, r1
    130c:	19 f0       	breq	.+6      	; 0x1314 <lcd_print+0x86>
    130e:	89 81       	ldd	r24, Y+1	; 0x01
    1310:	81 30       	cpi	r24, 0x01	; 1
    1312:	11 f5       	brne	.+68     	; 0x1358 <lcd_print+0xca>
	{
		temp = value/1000;
    1314:	8c 81       	ldd	r24, Y+4	; 0x04
    1316:	9d 81       	ldd	r25, Y+5	; 0x05
    1318:	28 ee       	ldi	r18, 0xE8	; 232
    131a:	33 e0       	ldi	r19, 0x03	; 3
    131c:	b9 01       	movw	r22, r18
    131e:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    1322:	cb 01       	movw	r24, r22
    1324:	90 93 3d 03 	sts	0x033D, r25
    1328:	80 93 3c 03 	sts	0x033C, r24
		thousand = temp%10 + 48;
    132c:	80 91 3c 03 	lds	r24, 0x033C
    1330:	90 91 3d 03 	lds	r25, 0x033D
    1334:	2a e0       	ldi	r18, 0x0A	; 10
    1336:	30 e0       	ldi	r19, 0x00	; 0
    1338:	b9 01       	movw	r22, r18
    133a:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    133e:	c0 96       	adiw	r24, 0x30	; 48
    1340:	90 93 52 03 	sts	0x0352, r25
    1344:	80 93 51 03 	sts	0x0351, r24
		lcd_wr_char(thousand);
    1348:	80 91 51 03 	lds	r24, 0x0351
    134c:	90 91 52 03 	lds	r25, 0x0352
    1350:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
		flag=1;
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==3 || flag==1)
    1358:	8e 81       	ldd	r24, Y+6	; 0x06
    135a:	9f 81       	ldd	r25, Y+7	; 0x07
    135c:	83 30       	cpi	r24, 0x03	; 3
    135e:	91 05       	cpc	r25, r1
    1360:	19 f0       	breq	.+6      	; 0x1368 <lcd_print+0xda>
    1362:	89 81       	ldd	r24, Y+1	; 0x01
    1364:	81 30       	cpi	r24, 0x01	; 1
    1366:	11 f5       	brne	.+68     	; 0x13ac <lcd_print+0x11e>
	{
		temp = value/100;
    1368:	8c 81       	ldd	r24, Y+4	; 0x04
    136a:	9d 81       	ldd	r25, Y+5	; 0x05
    136c:	24 e6       	ldi	r18, 0x64	; 100
    136e:	30 e0       	ldi	r19, 0x00	; 0
    1370:	b9 01       	movw	r22, r18
    1372:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    1376:	cb 01       	movw	r24, r22
    1378:	90 93 3d 03 	sts	0x033D, r25
    137c:	80 93 3c 03 	sts	0x033C, r24
		hundred = temp%10 + 48;
    1380:	80 91 3c 03 	lds	r24, 0x033C
    1384:	90 91 3d 03 	lds	r25, 0x033D
    1388:	2a e0       	ldi	r18, 0x0A	; 10
    138a:	30 e0       	ldi	r19, 0x00	; 0
    138c:	b9 01       	movw	r22, r18
    138e:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    1392:	c0 96       	adiw	r24, 0x30	; 48
    1394:	90 93 4e 03 	sts	0x034E, r25
    1398:	80 93 4d 03 	sts	0x034D, r24
		lcd_wr_char(hundred);
    139c:	80 91 4d 03 	lds	r24, 0x034D
    13a0:	90 91 4e 03 	lds	r25, 0x034E
    13a4:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
		flag=1;
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==2 || flag==1)
    13ac:	8e 81       	ldd	r24, Y+6	; 0x06
    13ae:	9f 81       	ldd	r25, Y+7	; 0x07
    13b0:	82 30       	cpi	r24, 0x02	; 2
    13b2:	91 05       	cpc	r25, r1
    13b4:	19 f0       	breq	.+6      	; 0x13bc <lcd_print+0x12e>
    13b6:	89 81       	ldd	r24, Y+1	; 0x01
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	11 f5       	brne	.+68     	; 0x1400 <lcd_print+0x172>
	{
		temp = value/10;
    13bc:	8c 81       	ldd	r24, Y+4	; 0x04
    13be:	9d 81       	ldd	r25, Y+5	; 0x05
    13c0:	2a e0       	ldi	r18, 0x0A	; 10
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	b9 01       	movw	r22, r18
    13c6:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    13ca:	cb 01       	movw	r24, r22
    13cc:	90 93 3d 03 	sts	0x033D, r25
    13d0:	80 93 3c 03 	sts	0x033C, r24
		tens = temp%10 + 48;
    13d4:	80 91 3c 03 	lds	r24, 0x033C
    13d8:	90 91 3d 03 	lds	r25, 0x033D
    13dc:	2a e0       	ldi	r18, 0x0A	; 10
    13de:	30 e0       	ldi	r19, 0x00	; 0
    13e0:	b9 01       	movw	r22, r18
    13e2:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    13e6:	c0 96       	adiw	r24, 0x30	; 48
    13e8:	90 93 48 03 	sts	0x0348, r25
    13ec:	80 93 47 03 	sts	0x0347, r24
		lcd_wr_char(tens);
    13f0:	80 91 47 03 	lds	r24, 0x0347
    13f4:	90 91 48 03 	lds	r25, 0x0348
    13f8:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
		flag=1;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	89 83       	std	Y+1, r24	; 0x01
	}
	if(digits==1 || flag==1)
    1400:	8e 81       	ldd	r24, Y+6	; 0x06
    1402:	9f 81       	ldd	r25, Y+7	; 0x07
    1404:	81 30       	cpi	r24, 0x01	; 1
    1406:	91 05       	cpc	r25, r1
    1408:	19 f0       	breq	.+6      	; 0x1410 <lcd_print+0x182>
    140a:	89 81       	ldd	r24, Y+1	; 0x01
    140c:	81 30       	cpi	r24, 0x01	; 1
    140e:	91 f4       	brne	.+36     	; 0x1434 <lcd_print+0x1a6>
	{
		unit = value%10 + 48;
    1410:	8c 81       	ldd	r24, Y+4	; 0x04
    1412:	9d 81       	ldd	r25, Y+5	; 0x05
    1414:	2a e0       	ldi	r18, 0x0A	; 10
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	b9 01       	movw	r22, r18
    141a:	0e 94 f7 24 	call	0x49ee	; 0x49ee <__udivmodhi4>
    141e:	c0 96       	adiw	r24, 0x30	; 48
    1420:	90 93 50 03 	sts	0x0350, r25
    1424:	80 93 4f 03 	sts	0x034F, r24
		lcd_wr_char(unit);
    1428:	80 91 4f 03 	lds	r24, 0x034F
    142c:	90 91 50 03 	lds	r25, 0x0350
    1430:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
	}
	if(digits>5)
    1434:	8e 81       	ldd	r24, Y+6	; 0x06
    1436:	9f 81       	ldd	r25, Y+7	; 0x07
    1438:	86 30       	cpi	r24, 0x06	; 6
    143a:	91 05       	cpc	r25, r1
    143c:	1c f0       	brlt	.+6      	; 0x1444 <lcd_print+0x1b6>
	{
		lcd_wr_char('E');
    143e:	85 e4       	ldi	r24, 0x45	; 69
    1440:	0e 94 84 07 	call	0xf08	; 0xf08 <lcd_wr_char>
	}
	
}
    1444:	27 96       	adiw	r28, 0x07	; 7
    1446:	0f b6       	in	r0, 0x3f	; 63
    1448:	f8 94       	cli
    144a:	de bf       	out	0x3e, r29	; 62
    144c:	0f be       	out	0x3f, r0	; 63
    144e:	cd bf       	out	0x3d, r28	; 61
    1450:	cf 91       	pop	r28
    1452:	df 91       	pop	r29
    1454:	08 95       	ret

00001456 <motion_pin_config>:
unsigned char Center_white_line = 0;
unsigned char Right_white_line = 0;

//Function to configure ports to enable robot's motion
void motion_pin_config (void) 
{
    1456:	df 93       	push	r29
    1458:	cf 93       	push	r28
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
 DDRA = DDRA | 0x0F;
    145e:	a1 e2       	ldi	r26, 0x21	; 33
    1460:	b0 e0       	ldi	r27, 0x00	; 0
    1462:	e1 e2       	ldi	r30, 0x21	; 33
    1464:	f0 e0       	ldi	r31, 0x00	; 0
    1466:	80 81       	ld	r24, Z
    1468:	8f 60       	ori	r24, 0x0F	; 15
    146a:	8c 93       	st	X, r24
 PORTA = PORTA & 0xF0;
    146c:	a2 e2       	ldi	r26, 0x22	; 34
    146e:	b0 e0       	ldi	r27, 0x00	; 0
    1470:	e2 e2       	ldi	r30, 0x22	; 34
    1472:	f0 e0       	ldi	r31, 0x00	; 0
    1474:	80 81       	ld	r24, Z
    1476:	80 7f       	andi	r24, 0xF0	; 240
    1478:	8c 93       	st	X, r24
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
    147a:	aa e0       	ldi	r26, 0x0A	; 10
    147c:	b1 e0       	ldi	r27, 0x01	; 1
    147e:	ea e0       	ldi	r30, 0x0A	; 10
    1480:	f1 e0       	ldi	r31, 0x01	; 1
    1482:	80 81       	ld	r24, Z
    1484:	88 61       	ori	r24, 0x18	; 24
    1486:	8c 93       	st	X, r24
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
    1488:	ab e0       	ldi	r26, 0x0B	; 11
    148a:	b1 e0       	ldi	r27, 0x01	; 1
    148c:	eb e0       	ldi	r30, 0x0B	; 11
    148e:	f1 e0       	ldi	r31, 0x01	; 1
    1490:	80 81       	ld	r24, Z
    1492:	88 61       	ori	r24, 0x18	; 24
    1494:	8c 93       	st	X, r24
}
    1496:	cf 91       	pop	r28
    1498:	df 91       	pop	r29
    149a:	08 95       	ret

0000149c <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
    149c:	df 93       	push	r29
    149e:	cf 93       	push	r28
    14a0:	cd b7       	in	r28, 0x3d	; 61
    14a2:	de b7       	in	r29, 0x3e	; 62
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
    14a4:	ad e2       	ldi	r26, 0x2D	; 45
    14a6:	b0 e0       	ldi	r27, 0x00	; 0
    14a8:	ed e2       	ldi	r30, 0x2D	; 45
    14aa:	f0 e0       	ldi	r31, 0x00	; 0
    14ac:	80 81       	ld	r24, Z
    14ae:	8f 7e       	andi	r24, 0xEF	; 239
    14b0:	8c 93       	st	X, r24
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
    14b2:	ae e2       	ldi	r26, 0x2E	; 46
    14b4:	b0 e0       	ldi	r27, 0x00	; 0
    14b6:	ee e2       	ldi	r30, 0x2E	; 46
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	80 81       	ld	r24, Z
    14bc:	80 61       	ori	r24, 0x10	; 16
    14be:	8c 93       	st	X, r24
}
    14c0:	cf 91       	pop	r28
    14c2:	df 91       	pop	r29
    14c4:	08 95       	ret

000014c6 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
    14c6:	df 93       	push	r29
    14c8:	cf 93       	push	r28
    14ca:	cd b7       	in	r28, 0x3d	; 61
    14cc:	de b7       	in	r29, 0x3e	; 62
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
    14ce:	ad e2       	ldi	r26, 0x2D	; 45
    14d0:	b0 e0       	ldi	r27, 0x00	; 0
    14d2:	ed e2       	ldi	r30, 0x2D	; 45
    14d4:	f0 e0       	ldi	r31, 0x00	; 0
    14d6:	80 81       	ld	r24, Z
    14d8:	8f 7d       	andi	r24, 0xDF	; 223
    14da:	8c 93       	st	X, r24
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
    14dc:	ae e2       	ldi	r26, 0x2E	; 46
    14de:	b0 e0       	ldi	r27, 0x00	; 0
    14e0:	ee e2       	ldi	r30, 0x2E	; 46
    14e2:	f0 e0       	ldi	r31, 0x00	; 0
    14e4:	80 81       	ld	r24, Z
    14e6:	80 62       	ori	r24, 0x20	; 32
    14e8:	8c 93       	st	X, r24
}
    14ea:	cf 91       	pop	r28
    14ec:	df 91       	pop	r29
    14ee:	08 95       	ret

000014f0 <servo1_pin_config>:


//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
    14f0:	df 93       	push	r29
    14f2:	cf 93       	push	r28
    14f4:	cd b7       	in	r28, 0x3d	; 61
    14f6:	de b7       	in	r29, 0x3e	; 62
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
    14f8:	a4 e2       	ldi	r26, 0x24	; 36
    14fa:	b0 e0       	ldi	r27, 0x00	; 0
    14fc:	e4 e2       	ldi	r30, 0x24	; 36
    14fe:	f0 e0       	ldi	r31, 0x00	; 0
    1500:	80 81       	ld	r24, Z
    1502:	80 62       	ori	r24, 0x20	; 32
    1504:	8c 93       	st	X, r24
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
    1506:	a5 e2       	ldi	r26, 0x25	; 37
    1508:	b0 e0       	ldi	r27, 0x00	; 0
    150a:	e5 e2       	ldi	r30, 0x25	; 37
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	80 81       	ld	r24, Z
    1510:	80 62       	ori	r24, 0x20	; 32
    1512:	8c 93       	st	X, r24
}
    1514:	cf 91       	pop	r28
    1516:	df 91       	pop	r29
    1518:	08 95       	ret

0000151a <servo2_pin_config>:

//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
    151a:	df 93       	push	r29
    151c:	cf 93       	push	r28
    151e:	cd b7       	in	r28, 0x3d	; 61
    1520:	de b7       	in	r29, 0x3e	; 62
 DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
    1522:	a4 e2       	ldi	r26, 0x24	; 36
    1524:	b0 e0       	ldi	r27, 0x00	; 0
    1526:	e4 e2       	ldi	r30, 0x24	; 36
    1528:	f0 e0       	ldi	r31, 0x00	; 0
    152a:	80 81       	ld	r24, Z
    152c:	80 64       	ori	r24, 0x40	; 64
    152e:	8c 93       	st	X, r24
 PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
    1530:	a5 e2       	ldi	r26, 0x25	; 37
    1532:	b0 e0       	ldi	r27, 0x00	; 0
    1534:	e5 e2       	ldi	r30, 0x25	; 37
    1536:	f0 e0       	ldi	r31, 0x00	; 0
    1538:	80 81       	ld	r24, Z
    153a:	80 64       	ori	r24, 0x40	; 64
    153c:	8c 93       	st	X, r24
}
    153e:	cf 91       	pop	r28
    1540:	df 91       	pop	r29
    1542:	08 95       	ret

00001544 <servo3_pin_config>:

//Configure PORTB 7 pin for servo motor 3 operation
void servo3_pin_config (void)
{
    1544:	df 93       	push	r29
    1546:	cf 93       	push	r28
    1548:	cd b7       	in	r28, 0x3d	; 61
    154a:	de b7       	in	r29, 0x3e	; 62
 DDRB  = DDRB | 0x80;  //making PORTB 7 pin output
    154c:	a4 e2       	ldi	r26, 0x24	; 36
    154e:	b0 e0       	ldi	r27, 0x00	; 0
    1550:	e4 e2       	ldi	r30, 0x24	; 36
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	80 81       	ld	r24, Z
    1556:	80 68       	ori	r24, 0x80	; 128
    1558:	8c 93       	st	X, r24
 PORTB = PORTB | 0x80; //setting PORTB 7 pin to logic 1
    155a:	a5 e2       	ldi	r26, 0x25	; 37
    155c:	b0 e0       	ldi	r27, 0x00	; 0
    155e:	e5 e2       	ldi	r30, 0x25	; 37
    1560:	f0 e0       	ldi	r31, 0x00	; 0
    1562:	80 81       	ld	r24, Z
    1564:	80 68       	ori	r24, 0x80	; 128
    1566:	8c 93       	st	X, r24
}
    1568:	cf 91       	pop	r28
    156a:	df 91       	pop	r29
    156c:	08 95       	ret

0000156e <buzzer_pin_config>:
void buzzer_pin_config (void)
{
    156e:	df 93       	push	r29
    1570:	cf 93       	push	r28
    1572:	cd b7       	in	r28, 0x3d	; 61
    1574:	de b7       	in	r29, 0x3e	; 62
 DDRC = DDRC | 0x08;    //Setting PORTC 3 as output
    1576:	a7 e2       	ldi	r26, 0x27	; 39
    1578:	b0 e0       	ldi	r27, 0x00	; 0
    157a:	e7 e2       	ldi	r30, 0x27	; 39
    157c:	f0 e0       	ldi	r31, 0x00	; 0
    157e:	80 81       	ld	r24, Z
    1580:	88 60       	ori	r24, 0x08	; 8
    1582:	8c 93       	st	X, r24
 PORTC = PORTC & 0xF7;    //Setting PORTC 3 logic low to turnoff buzzer
    1584:	a8 e2       	ldi	r26, 0x28	; 40
    1586:	b0 e0       	ldi	r27, 0x00	; 0
    1588:	e8 e2       	ldi	r30, 0x28	; 40
    158a:	f0 e0       	ldi	r31, 0x00	; 0
    158c:	80 81       	ld	r24, Z
    158e:	87 7f       	andi	r24, 0xF7	; 247
    1590:	8c 93       	st	X, r24
}
    1592:	cf 91       	pop	r28
    1594:	df 91       	pop	r29
    1596:	08 95       	ret

00001598 <lcd_port_config>:

void lcd_port_config (void)
{
    1598:	df 93       	push	r29
    159a:	cf 93       	push	r28
    159c:	cd b7       	in	r28, 0x3d	; 61
    159e:	de b7       	in	r29, 0x3e	; 62
  DDRC = DDRC | 0xF7; //setting all the LCD pin's direction set as output
    15a0:	a7 e2       	ldi	r26, 0x27	; 39
    15a2:	b0 e0       	ldi	r27, 0x00	; 0
    15a4:	e7 e2       	ldi	r30, 0x27	; 39
    15a6:	f0 e0       	ldi	r31, 0x00	; 0
    15a8:	80 81       	ld	r24, Z
    15aa:	87 6f       	ori	r24, 0xF7	; 247
    15ac:	8c 93       	st	X, r24
  PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
    15ae:	a8 e2       	ldi	r26, 0x28	; 40
    15b0:	b0 e0       	ldi	r27, 0x00	; 0
    15b2:	e8 e2       	ldi	r30, 0x28	; 40
    15b4:	f0 e0       	ldi	r31, 0x00	; 0
    15b6:	80 81       	ld	r24, Z
    15b8:	80 78       	andi	r24, 0x80	; 128
    15ba:	8c 93       	st	X, r24
}
    15bc:	cf 91       	pop	r28
    15be:	df 91       	pop	r29
    15c0:	08 95       	ret

000015c2 <color_sensor_pin_config>:

void color_sensor_pin_config(void)
{
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
  DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
    15ca:	aa e2       	ldi	r26, 0x2A	; 42
    15cc:	b0 e0       	ldi	r27, 0x00	; 0
    15ce:	ea e2       	ldi	r30, 0x2A	; 42
    15d0:	f0 e0       	ldi	r31, 0x00	; 0
    15d2:	80 81       	ld	r24, Z
    15d4:	8e 6f       	ori	r24, 0xFE	; 254
    15d6:	8c 93       	st	X, r24
  PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
    15d8:	ab e2       	ldi	r26, 0x2B	; 43
    15da:	b0 e0       	ldi	r27, 0x00	; 0
    15dc:	eb e2       	ldi	r30, 0x2B	; 43
    15de:	f0 e0       	ldi	r31, 0x00	; 0
    15e0:	80 81       	ld	r24, Z
    15e2:	81 60       	ori	r24, 0x01	; 1
    15e4:	8c 93       	st	X, r24
}
    15e6:	cf 91       	pop	r28
    15e8:	df 91       	pop	r29
    15ea:	08 95       	ret

000015ec <adc_pin_config>:
void adc_pin_config (void)
{
    15ec:	df 93       	push	r29
    15ee:	cf 93       	push	r28
    15f0:	cd b7       	in	r28, 0x3d	; 61
    15f2:	de b7       	in	r29, 0x3e	; 62
 DDRF = 0x00; 
    15f4:	e0 e3       	ldi	r30, 0x30	; 48
    15f6:	f0 e0       	ldi	r31, 0x00	; 0
    15f8:	10 82       	st	Z, r1
 PORTF = 0x00;
    15fa:	e1 e3       	ldi	r30, 0x31	; 49
    15fc:	f0 e0       	ldi	r31, 0x00	; 0
    15fe:	10 82       	st	Z, r1
 DDRK = 0x00;
    1600:	e7 e0       	ldi	r30, 0x07	; 7
    1602:	f1 e0       	ldi	r31, 0x01	; 1
    1604:	10 82       	st	Z, r1
 PORTK = 0x00;
    1606:	e8 e0       	ldi	r30, 0x08	; 8
    1608:	f1 e0       	ldi	r31, 0x01	; 1
    160a:	10 82       	st	Z, r1
}
    160c:	cf 91       	pop	r28
    160e:	df 91       	pop	r29
    1610:	08 95       	ret

00001612 <port_init>:


void port_init(void)
{
    1612:	df 93       	push	r29
    1614:	cf 93       	push	r28
    1616:	cd b7       	in	r28, 0x3d	; 61
    1618:	de b7       	in	r29, 0x3e	; 62
  buzzer_pin_config();
    161a:	0e 94 b7 0a 	call	0x156e	; 0x156e <buzzer_pin_config>
  lcd_port_config();      //lcd pin configuration
    161e:	0e 94 cc 0a 	call	0x1598	; 0x1598 <lcd_port_config>
  color_sensor_pin_config();  //color sensor pin configuration
    1622:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <color_sensor_pin_config>
  servo1_pin_config();    //Configure PORTB 5 pin for servo motor 1 operation
    1626:	0e 94 78 0a 	call	0x14f0	; 0x14f0 <servo1_pin_config>
  servo2_pin_config();    //Configure PORTB 6 pin for servo motor 2 operation 
    162a:	0e 94 8d 0a 	call	0x151a	; 0x151a <servo2_pin_config>
  servo3_pin_config();    //Configure PORTB 7 pin for servo motor 3 operation  
    162e:	0e 94 a2 0a 	call	0x1544	; 0x1544 <servo3_pin_config>
  motion_pin_config(); //robot motion pins config
    1632:	0e 94 2b 0a 	call	0x1456	; 0x1456 <motion_pin_config>
  left_encoder_pin_config(); //left encoder pin config
    1636:	0e 94 4e 0a 	call	0x149c	; 0x149c <left_encoder_pin_config>
  right_encoder_pin_config(); //right encoder pin config 
    163a:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <right_encoder_pin_config>
  adc_pin_config();
    163e:	0e 94 f6 0a 	call	0x15ec	; 0x15ec <adc_pin_config>
}
    1642:	cf 91       	pop	r28
    1644:	df 91       	pop	r29
    1646:	08 95       	ret

00001648 <buzzer_on>:
void buzzer_on (void)
{
    1648:	df 93       	push	r29
    164a:	cf 93       	push	r28
    164c:	0f 92       	push	r0
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
 unsigned char port_restore = 0;
    1652:	19 82       	std	Y+1, r1	; 0x01
 port_restore = PINC;
    1654:	e6 e2       	ldi	r30, 0x26	; 38
    1656:	f0 e0       	ldi	r31, 0x00	; 0
    1658:	80 81       	ld	r24, Z
    165a:	89 83       	std	Y+1, r24	; 0x01
 port_restore = port_restore | 0x08;
    165c:	89 81       	ldd	r24, Y+1	; 0x01
    165e:	88 60       	ori	r24, 0x08	; 8
    1660:	89 83       	std	Y+1, r24	; 0x01
 PORTC = port_restore;
    1662:	e8 e2       	ldi	r30, 0x28	; 40
    1664:	f0 e0       	ldi	r31, 0x00	; 0
    1666:	89 81       	ldd	r24, Y+1	; 0x01
    1668:	80 83       	st	Z, r24
}
    166a:	0f 90       	pop	r0
    166c:	cf 91       	pop	r28
    166e:	df 91       	pop	r29
    1670:	08 95       	ret

00001672 <buzzer_off>:

void buzzer_off (void)
{
    1672:	df 93       	push	r29
    1674:	cf 93       	push	r28
    1676:	0f 92       	push	r0
    1678:	cd b7       	in	r28, 0x3d	; 61
    167a:	de b7       	in	r29, 0x3e	; 62
 unsigned char port_restore = 0;
    167c:	19 82       	std	Y+1, r1	; 0x01
 port_restore = PINC;
    167e:	e6 e2       	ldi	r30, 0x26	; 38
    1680:	f0 e0       	ldi	r31, 0x00	; 0
    1682:	80 81       	ld	r24, Z
    1684:	89 83       	std	Y+1, r24	; 0x01
 port_restore = port_restore & 0xF7;
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	87 7f       	andi	r24, 0xF7	; 247
    168a:	89 83       	std	Y+1, r24	; 0x01
 PORTC = port_restore;
    168c:	e8 e2       	ldi	r30, 0x28	; 40
    168e:	f0 e0       	ldi	r31, 0x00	; 0
    1690:	89 81       	ldd	r24, Y+1	; 0x01
    1692:	80 83       	st	Z, r24
}
    1694:	0f 90       	pop	r0
    1696:	cf 91       	pop	r28
    1698:	df 91       	pop	r29
    169a:	08 95       	ret

0000169c <color_sensor_pin_interrupt_init>:

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
    169c:	df 93       	push	r29
    169e:	cf 93       	push	r28
    16a0:	cd b7       	in	r28, 0x3d	; 61
    16a2:	de b7       	in	r29, 0x3e	; 62
  cli(); //Clears the global interrupt
    16a4:	f8 94       	cli
  EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
    16a6:	a9 e6       	ldi	r26, 0x69	; 105
    16a8:	b0 e0       	ldi	r27, 0x00	; 0
    16aa:	e9 e6       	ldi	r30, 0x69	; 105
    16ac:	f0 e0       	ldi	r31, 0x00	; 0
    16ae:	80 81       	ld	r24, Z
    16b0:	82 60       	ori	r24, 0x02	; 2
    16b2:	8c 93       	st	X, r24
  EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
    16b4:	ad e3       	ldi	r26, 0x3D	; 61
    16b6:	b0 e0       	ldi	r27, 0x00	; 0
    16b8:	ed e3       	ldi	r30, 0x3D	; 61
    16ba:	f0 e0       	ldi	r31, 0x00	; 0
    16bc:	80 81       	ld	r24, Z
    16be:	81 60       	ori	r24, 0x01	; 1
    16c0:	8c 93       	st	X, r24
  sei(); // Enables the global interrupt
    16c2:	78 94       	sei
}
    16c4:	cf 91       	pop	r28
    16c6:	df 91       	pop	r29
    16c8:	08 95       	ret

000016ca <left_position_encoder_interrupt_init>:
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
    16ca:	df 93       	push	r29
    16cc:	cf 93       	push	r28
    16ce:	cd b7       	in	r28, 0x3d	; 61
    16d0:	de b7       	in	r29, 0x3e	; 62
 cli(); //Clears the global interrupt
    16d2:	f8 94       	cli
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
    16d4:	aa e6       	ldi	r26, 0x6A	; 106
    16d6:	b0 e0       	ldi	r27, 0x00	; 0
    16d8:	ea e6       	ldi	r30, 0x6A	; 106
    16da:	f0 e0       	ldi	r31, 0x00	; 0
    16dc:	80 81       	ld	r24, Z
    16de:	82 60       	ori	r24, 0x02	; 2
    16e0:	8c 93       	st	X, r24
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
    16e2:	ad e3       	ldi	r26, 0x3D	; 61
    16e4:	b0 e0       	ldi	r27, 0x00	; 0
    16e6:	ed e3       	ldi	r30, 0x3D	; 61
    16e8:	f0 e0       	ldi	r31, 0x00	; 0
    16ea:	80 81       	ld	r24, Z
    16ec:	80 61       	ori	r24, 0x10	; 16
    16ee:	8c 93       	st	X, r24
 sei();   // Enables the global interrupt 
    16f0:	78 94       	sei
}
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	08 95       	ret

000016f8 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
 cli(); //Clears the global interrupt
    1700:	f8 94       	cli
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
    1702:	aa e6       	ldi	r26, 0x6A	; 106
    1704:	b0 e0       	ldi	r27, 0x00	; 0
    1706:	ea e6       	ldi	r30, 0x6A	; 106
    1708:	f0 e0       	ldi	r31, 0x00	; 0
    170a:	80 81       	ld	r24, Z
    170c:	88 60       	ori	r24, 0x08	; 8
    170e:	8c 93       	st	X, r24
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
    1710:	ad e3       	ldi	r26, 0x3D	; 61
    1712:	b0 e0       	ldi	r27, 0x00	; 0
    1714:	ed e3       	ldi	r30, 0x3D	; 61
    1716:	f0 e0       	ldi	r31, 0x00	; 0
    1718:	80 81       	ld	r24, Z
    171a:	80 62       	ori	r24, 0x20	; 32
    171c:	8c 93       	st	X, r24
 sei();   // Enables the global interrupt 
    171e:	78 94       	sei
}
    1720:	cf 91       	pop	r28
    1722:	df 91       	pop	r29
    1724:	08 95       	ret

00001726 <__vector_1>:


//ISR for color sensor
ISR(INT0_vect)
{
    1726:	1f 92       	push	r1
    1728:	0f 92       	push	r0
    172a:	0f b6       	in	r0, 0x3f	; 63
    172c:	0f 92       	push	r0
    172e:	11 24       	eor	r1, r1
    1730:	8f 93       	push	r24
    1732:	9f 93       	push	r25
    1734:	af 93       	push	r26
    1736:	bf 93       	push	r27
    1738:	df 93       	push	r29
    173a:	cf 93       	push	r28
    173c:	cd b7       	in	r28, 0x3d	; 61
    173e:	de b7       	in	r29, 0x3e	; 62
  pulse++; //increment on receiving pulse from the color sensor
    1740:	80 91 22 03 	lds	r24, 0x0322
    1744:	90 91 23 03 	lds	r25, 0x0323
    1748:	a0 91 24 03 	lds	r26, 0x0324
    174c:	b0 91 25 03 	lds	r27, 0x0325
    1750:	01 96       	adiw	r24, 0x01	; 1
    1752:	a1 1d       	adc	r26, r1
    1754:	b1 1d       	adc	r27, r1
    1756:	80 93 22 03 	sts	0x0322, r24
    175a:	90 93 23 03 	sts	0x0323, r25
    175e:	a0 93 24 03 	sts	0x0324, r26
    1762:	b0 93 25 03 	sts	0x0325, r27
}
    1766:	cf 91       	pop	r28
    1768:	df 91       	pop	r29
    176a:	bf 91       	pop	r27
    176c:	af 91       	pop	r26
    176e:	9f 91       	pop	r25
    1770:	8f 91       	pop	r24
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63
    1776:	0f 90       	pop	r0
    1778:	1f 90       	pop	r1
    177a:	18 95       	reti

0000177c <timer1_init>:

void timer1_init(void)
{
    177c:	df 93       	push	r29
    177e:	cf 93       	push	r28
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
 TCCR1B = 0x00; //stop
    1784:	e1 e8       	ldi	r30, 0x81	; 129
    1786:	f0 e0       	ldi	r31, 0x00	; 0
    1788:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    178a:	e5 e8       	ldi	r30, 0x85	; 133
    178c:	f0 e0       	ldi	r31, 0x00	; 0
    178e:	8c ef       	ldi	r24, 0xFC	; 252
    1790:	80 83       	st	Z, r24
 TCNT1L = 0x01; //Counter low value to which OCR1xH value is to be compared with
    1792:	e4 e8       	ldi	r30, 0x84	; 132
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	81 e0       	ldi	r24, 0x01	; 1
    1798:	80 83       	st	Z, r24
 OCR1AH = 0x03; //Output compare Register high value for servo 1
    179a:	e9 e8       	ldi	r30, 0x89	; 137
    179c:	f0 e0       	ldi	r31, 0x00	; 0
    179e:	83 e0       	ldi	r24, 0x03	; 3
    17a0:	80 83       	st	Z, r24
 OCR1AL = 0xFF; //Output Compare Register low Value For servo 1
    17a2:	e8 e8       	ldi	r30, 0x88	; 136
    17a4:	f0 e0       	ldi	r31, 0x00	; 0
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	80 83       	st	Z, r24
 OCR1BH = 0x03; //Output compare Register high value for servo 2
    17aa:	eb e8       	ldi	r30, 0x8B	; 139
    17ac:	f0 e0       	ldi	r31, 0x00	; 0
    17ae:	83 e0       	ldi	r24, 0x03	; 3
    17b0:	80 83       	st	Z, r24
 OCR1BL = 0xFF; //Output Compare Register low Value For servo 2
    17b2:	ea e8       	ldi	r30, 0x8A	; 138
    17b4:	f0 e0       	ldi	r31, 0x00	; 0
    17b6:	8f ef       	ldi	r24, 0xFF	; 255
    17b8:	80 83       	st	Z, r24
 OCR1CH = 0x03; //Output compare Register high value for servo 3
    17ba:	ed e8       	ldi	r30, 0x8D	; 141
    17bc:	f0 e0       	ldi	r31, 0x00	; 0
    17be:	83 e0       	ldi	r24, 0x03	; 3
    17c0:	80 83       	st	Z, r24
 OCR1CL = 0xFF; //Output Compare Register low Value For servo 3
    17c2:	ec e8       	ldi	r30, 0x8C	; 140
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	8f ef       	ldi	r24, 0xFF	; 255
    17c8:	80 83       	st	Z, r24
 ICR1H  = 0x03; 
    17ca:	e7 e8       	ldi	r30, 0x87	; 135
    17cc:	f0 e0       	ldi	r31, 0x00	; 0
    17ce:	83 e0       	ldi	r24, 0x03	; 3
    17d0:	80 83       	st	Z, r24
 ICR1L  = 0xFF;
    17d2:	e6 e8       	ldi	r30, 0x86	; 134
    17d4:	f0 e0       	ldi	r31, 0x00	; 0
    17d6:	8f ef       	ldi	r24, 0xFF	; 255
    17d8:	80 83       	st	Z, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
    17da:	e0 e8       	ldi	r30, 0x80	; 128
    17dc:	f0 e0       	ldi	r31, 0x00	; 0
    17de:	8b ea       	ldi	r24, 0xAB	; 171
    17e0:	80 83       	st	Z, r24
          For Overriding normal port functionality to OCRnA outputs.
          {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
    17e2:	e2 e8       	ldi	r30, 0x82	; 130
    17e4:	f0 e0       	ldi	r31, 0x00	; 0
    17e6:	10 82       	st	Z, r1
 TCCR1B = threshold; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
    17e8:	e1 e8       	ldi	r30, 0x81	; 129
    17ea:	f0 e0       	ldi	r31, 0x00	; 0
    17ec:	80 91 00 02 	lds	r24, 0x0200
    17f0:	90 91 01 02 	lds	r25, 0x0201
    17f4:	80 83       	st	Z, r24
}
    17f6:	cf 91       	pop	r28
    17f8:	df 91       	pop	r29
    17fa:	08 95       	ret

000017fc <timer5_init>:
// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
    17fc:	df 93       	push	r29
    17fe:	cf 93       	push	r28
    1800:	cd b7       	in	r28, 0x3d	; 61
    1802:	de b7       	in	r29, 0x3e	; 62
  TCCR5B = 0x00;  //Stop
    1804:	e1 e2       	ldi	r30, 0x21	; 33
    1806:	f1 e0       	ldi	r31, 0x01	; 1
    1808:	10 82       	st	Z, r1
  TCNT5H = 0xFF;  //Counter higher 8-bit value to which OCR5xH value is compared with
    180a:	e5 e2       	ldi	r30, 0x25	; 37
    180c:	f1 e0       	ldi	r31, 0x01	; 1
    180e:	8f ef       	ldi	r24, 0xFF	; 255
    1810:	80 83       	st	Z, r24
  TCNT5L = 0x01;  //Counter lower 8-bit value to which OCR5xH value is compared with
    1812:	e4 e2       	ldi	r30, 0x24	; 36
    1814:	f1 e0       	ldi	r31, 0x01	; 1
    1816:	81 e0       	ldi	r24, 0x01	; 1
    1818:	80 83       	st	Z, r24
  OCR5AH = 0x00;  //Output compare register high value for Left Motor
    181a:	e9 e2       	ldi	r30, 0x29	; 41
    181c:	f1 e0       	ldi	r31, 0x01	; 1
    181e:	10 82       	st	Z, r1
  OCR5AL = 0xFF;  //Output compare register low value for Left Motor
    1820:	e8 e2       	ldi	r30, 0x28	; 40
    1822:	f1 e0       	ldi	r31, 0x01	; 1
    1824:	8f ef       	ldi	r24, 0xFF	; 255
    1826:	80 83       	st	Z, r24
  OCR5BH = 0x00;  //Output compare register high value for Right Motor
    1828:	eb e2       	ldi	r30, 0x2B	; 43
    182a:	f1 e0       	ldi	r31, 0x01	; 1
    182c:	10 82       	st	Z, r1
  OCR5BL = 0xFF;  //Output compare register low value for Right Motor
    182e:	ea e2       	ldi	r30, 0x2A	; 42
    1830:	f1 e0       	ldi	r31, 0x01	; 1
    1832:	8f ef       	ldi	r24, 0xFF	; 255
    1834:	80 83       	st	Z, r24
  OCR5CH = 0x00;  //Output compare register high value for Motor C1
    1836:	ed e2       	ldi	r30, 0x2D	; 45
    1838:	f1 e0       	ldi	r31, 0x01	; 1
    183a:	10 82       	st	Z, r1
  OCR5CL = 0xFF;  //Output compare register low value for Motor C1
    183c:	ec e2       	ldi	r30, 0x2C	; 44
    183e:	f1 e0       	ldi	r31, 0x01	; 1
    1840:	8f ef       	ldi	r24, 0xFF	; 255
    1842:	80 83       	st	Z, r24
  TCCR5A = 0xA9;  /*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
    1844:	e0 e2       	ldi	r30, 0x20	; 32
    1846:	f1 e0       	ldi	r31, 0x01	; 1
    1848:	89 ea       	ldi	r24, 0xA9	; 169
    184a:	80 83       	st	Z, r24
            For Overriding normal port functionality to OCRnA outputs.
              {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
  
  TCCR5B = 0x0B;  //WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
    184c:	e1 e2       	ldi	r30, 0x21	; 33
    184e:	f1 e0       	ldi	r31, 0x01	; 1
    1850:	8b e0       	ldi	r24, 0x0B	; 11
    1852:	80 83       	st	Z, r24
}
    1854:	cf 91       	pop	r28
    1856:	df 91       	pop	r29
    1858:	08 95       	ret

0000185a <adc_init>:

void adc_init()
{
    185a:	df 93       	push	r29
    185c:	cf 93       	push	r28
    185e:	cd b7       	in	r28, 0x3d	; 61
    1860:	de b7       	in	r29, 0x3e	; 62
  ADCSRA = 0x00;
    1862:	ea e7       	ldi	r30, 0x7A	; 122
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	10 82       	st	Z, r1
  ADCSRB = 0x00;    //MUX5 = 0
    1868:	eb e7       	ldi	r30, 0x7B	; 123
    186a:	f0 e0       	ldi	r31, 0x00	; 0
    186c:	10 82       	st	Z, r1
  ADMUX = 0x20;   //Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    186e:	ec e7       	ldi	r30, 0x7C	; 124
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	80 e2       	ldi	r24, 0x20	; 32
    1874:	80 83       	st	Z, r24
  ACSR = 0x80;
    1876:	e0 e5       	ldi	r30, 0x50	; 80
    1878:	f0 e0       	ldi	r31, 0x00	; 0
    187a:	80 e8       	ldi	r24, 0x80	; 128
    187c:	80 83       	st	Z, r24
  ADCSRA = 0x86;    //ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    187e:	ea e7       	ldi	r30, 0x7A	; 122
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	86 e8       	ldi	r24, 0x86	; 134
    1884:	80 83       	st	Z, r24
}
    1886:	cf 91       	pop	r28
    1888:	df 91       	pop	r29
    188a:	08 95       	ret

0000188c <ADC_Conversion>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
    188c:	df 93       	push	r29
    188e:	cf 93       	push	r28
    1890:	0f 92       	push	r0
    1892:	0f 92       	push	r0
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
    1898:	8a 83       	std	Y+2, r24	; 0x02
  unsigned char a;
  if(Ch>7)
    189a:	8a 81       	ldd	r24, Y+2	; 0x02
    189c:	88 30       	cpi	r24, 0x08	; 8
    189e:	20 f0       	brcs	.+8      	; 0x18a8 <ADC_Conversion+0x1c>
  {
    ADCSRB = 0x08;
    18a0:	eb e7       	ldi	r30, 0x7B	; 123
    18a2:	f0 e0       	ldi	r31, 0x00	; 0
    18a4:	88 e0       	ldi	r24, 0x08	; 8
    18a6:	80 83       	st	Z, r24
  }
  Ch = Ch & 0x07;       
    18a8:	8a 81       	ldd	r24, Y+2	; 0x02
    18aa:	87 70       	andi	r24, 0x07	; 7
    18ac:	8a 83       	std	Y+2, r24	; 0x02
  ADMUX= 0x20| Ch;        
    18ae:	ec e7       	ldi	r30, 0x7C	; 124
    18b0:	f0 e0       	ldi	r31, 0x00	; 0
    18b2:	8a 81       	ldd	r24, Y+2	; 0x02
    18b4:	80 62       	ori	r24, 0x20	; 32
    18b6:	80 83       	st	Z, r24
  ADCSRA = ADCSRA | 0x40;   //Set start conversion bit
    18b8:	aa e7       	ldi	r26, 0x7A	; 122
    18ba:	b0 e0       	ldi	r27, 0x00	; 0
    18bc:	ea e7       	ldi	r30, 0x7A	; 122
    18be:	f0 e0       	ldi	r31, 0x00	; 0
    18c0:	80 81       	ld	r24, Z
    18c2:	80 64       	ori	r24, 0x40	; 64
    18c4:	8c 93       	st	X, r24
  while((ADCSRA&0x10)==0);  //Wait for conversion to complete
    18c6:	ea e7       	ldi	r30, 0x7A	; 122
    18c8:	f0 e0       	ldi	r31, 0x00	; 0
    18ca:	80 81       	ld	r24, Z
    18cc:	88 2f       	mov	r24, r24
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	80 71       	andi	r24, 0x10	; 16
    18d2:	90 70       	andi	r25, 0x00	; 0
    18d4:	00 97       	sbiw	r24, 0x00	; 0
    18d6:	b9 f3       	breq	.-18     	; 0x18c6 <ADC_Conversion+0x3a>
  a=ADCH;
    18d8:	e9 e7       	ldi	r30, 0x79	; 121
    18da:	f0 e0       	ldi	r31, 0x00	; 0
    18dc:	80 81       	ld	r24, Z
    18de:	89 83       	std	Y+1, r24	; 0x01
  ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    18e0:	aa e7       	ldi	r26, 0x7A	; 122
    18e2:	b0 e0       	ldi	r27, 0x00	; 0
    18e4:	ea e7       	ldi	r30, 0x7A	; 122
    18e6:	f0 e0       	ldi	r31, 0x00	; 0
    18e8:	80 81       	ld	r24, Z
    18ea:	80 61       	ori	r24, 0x10	; 16
    18ec:	8c 93       	st	X, r24
  ADCSRB = 0x00;
    18ee:	eb e7       	ldi	r30, 0x7B	; 123
    18f0:	f0 e0       	ldi	r31, 0x00	; 0
    18f2:	10 82       	st	Z, r1
  return a;
    18f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    18f6:	0f 90       	pop	r0
    18f8:	0f 90       	pop	r0
    18fa:	cf 91       	pop	r28
    18fc:	df 91       	pop	r29
    18fe:	08 95       	ret

00001900 <print_sensor>:

void print_sensor(char row, char coloumn,unsigned char channel)
{
    1900:	df 93       	push	r29
    1902:	cf 93       	push	r28
    1904:	00 d0       	rcall	.+0      	; 0x1906 <print_sensor+0x6>
    1906:	cd b7       	in	r28, 0x3d	; 61
    1908:	de b7       	in	r29, 0x3e	; 62
    190a:	89 83       	std	Y+1, r24	; 0x01
    190c:	6a 83       	std	Y+2, r22	; 0x02
    190e:	4b 83       	std	Y+3, r20	; 0x03
  
  ADC_Value = ADC_Conversion(channel);
    1910:	8b 81       	ldd	r24, Y+3	; 0x03
    1912:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    1916:	80 93 46 03 	sts	0x0346, r24
  lcd_print(row, coloumn, ADC_Value, 3);
    191a:	80 91 46 03 	lds	r24, 0x0346
    191e:	28 2f       	mov	r18, r24
    1920:	30 e0       	ldi	r19, 0x00	; 0
    1922:	89 81       	ldd	r24, Y+1	; 0x01
    1924:	6a 81       	ldd	r22, Y+2	; 0x02
    1926:	a9 01       	movw	r20, r18
    1928:	23 e0       	ldi	r18, 0x03	; 3
    192a:	30 e0       	ldi	r19, 0x00	; 0
    192c:	0e 94 47 09 	call	0x128e	; 0x128e <lcd_print>
}
    1930:	0f 90       	pop	r0
    1932:	0f 90       	pop	r0
    1934:	0f 90       	pop	r0
    1936:	cf 91       	pop	r28
    1938:	df 91       	pop	r29
    193a:	08 95       	ret

0000193c <velocity>:
void velocity (unsigned char left_motor, unsigned char right_motor)
{
    193c:	df 93       	push	r29
    193e:	cf 93       	push	r28
    1940:	0f 92       	push	r0
    1942:	0f 92       	push	r0
    1944:	cd b7       	in	r28, 0x3d	; 61
    1946:	de b7       	in	r29, 0x3e	; 62
    1948:	89 83       	std	Y+1, r24	; 0x01
    194a:	6a 83       	std	Y+2, r22	; 0x02
  OCR5AL = (unsigned char)left_motor;
    194c:	e8 e2       	ldi	r30, 0x28	; 40
    194e:	f1 e0       	ldi	r31, 0x01	; 1
    1950:	89 81       	ldd	r24, Y+1	; 0x01
    1952:	80 83       	st	Z, r24
  OCR5BL = (unsigned char)right_motor;
    1954:	ea e2       	ldi	r30, 0x2A	; 42
    1956:	f1 e0       	ldi	r31, 0x01	; 1
    1958:	8a 81       	ldd	r24, Y+2	; 0x02
    195a:	80 83       	st	Z, r24
}
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	cf 91       	pop	r28
    1962:	df 91       	pop	r29
    1964:	08 95       	ret

00001966 <__vector_6>:



//ISR for right position encoder
ISR(INT5_vect)  
{
    1966:	1f 92       	push	r1
    1968:	0f 92       	push	r0
    196a:	0f b6       	in	r0, 0x3f	; 63
    196c:	0f 92       	push	r0
    196e:	11 24       	eor	r1, r1
    1970:	8f 93       	push	r24
    1972:	9f 93       	push	r25
    1974:	af 93       	push	r26
    1976:	bf 93       	push	r27
    1978:	df 93       	push	r29
    197a:	cf 93       	push	r28
    197c:	cd b7       	in	r28, 0x3d	; 61
    197e:	de b7       	in	r29, 0x3e	; 62
 ShaftCountRight++;  //increment right shaft position count
    1980:	80 91 2a 03 	lds	r24, 0x032A
    1984:	90 91 2b 03 	lds	r25, 0x032B
    1988:	a0 91 2c 03 	lds	r26, 0x032C
    198c:	b0 91 2d 03 	lds	r27, 0x032D
    1990:	01 96       	adiw	r24, 0x01	; 1
    1992:	a1 1d       	adc	r26, r1
    1994:	b1 1d       	adc	r27, r1
    1996:	80 93 2a 03 	sts	0x032A, r24
    199a:	90 93 2b 03 	sts	0x032B, r25
    199e:	a0 93 2c 03 	sts	0x032C, r26
    19a2:	b0 93 2d 03 	sts	0x032D, r27
}
    19a6:	cf 91       	pop	r28
    19a8:	df 91       	pop	r29
    19aa:	bf 91       	pop	r27
    19ac:	af 91       	pop	r26
    19ae:	9f 91       	pop	r25
    19b0:	8f 91       	pop	r24
    19b2:	0f 90       	pop	r0
    19b4:	0f be       	out	0x3f, r0	; 63
    19b6:	0f 90       	pop	r0
    19b8:	1f 90       	pop	r1
    19ba:	18 95       	reti

000019bc <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
    19bc:	1f 92       	push	r1
    19be:	0f 92       	push	r0
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	0f 92       	push	r0
    19c4:	11 24       	eor	r1, r1
    19c6:	8f 93       	push	r24
    19c8:	9f 93       	push	r25
    19ca:	af 93       	push	r26
    19cc:	bf 93       	push	r27
    19ce:	df 93       	push	r29
    19d0:	cf 93       	push	r28
    19d2:	cd b7       	in	r28, 0x3d	; 61
    19d4:	de b7       	in	r29, 0x3e	; 62
 ShaftCountLeft++;  //increment left shaft position count
    19d6:	80 91 26 03 	lds	r24, 0x0326
    19da:	90 91 27 03 	lds	r25, 0x0327
    19de:	a0 91 28 03 	lds	r26, 0x0328
    19e2:	b0 91 29 03 	lds	r27, 0x0329
    19e6:	01 96       	adiw	r24, 0x01	; 1
    19e8:	a1 1d       	adc	r26, r1
    19ea:	b1 1d       	adc	r27, r1
    19ec:	80 93 26 03 	sts	0x0326, r24
    19f0:	90 93 27 03 	sts	0x0327, r25
    19f4:	a0 93 28 03 	sts	0x0328, r26
    19f8:	b0 93 29 03 	sts	0x0329, r27
}
    19fc:	cf 91       	pop	r28
    19fe:	df 91       	pop	r29
    1a00:	bf 91       	pop	r27
    1a02:	af 91       	pop	r26
    1a04:	9f 91       	pop	r25
    1a06:	8f 91       	pop	r24
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
    1a0c:	0f 90       	pop	r0
    1a0e:	1f 90       	pop	r1
    1a10:	18 95       	reti

00001a12 <motion_set>:


//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
    1a12:	df 93       	push	r29
    1a14:	cf 93       	push	r28
    1a16:	0f 92       	push	r0
    1a18:	0f 92       	push	r0
    1a1a:	cd b7       	in	r28, 0x3d	; 61
    1a1c:	de b7       	in	r29, 0x3e	; 62
    1a1e:	8a 83       	std	Y+2, r24	; 0x02
 unsigned char PortARestore = 0;
    1a20:	19 82       	std	Y+1, r1	; 0x01

 Direction &= 0x0F;     // removing upper nibbel for the protection
    1a22:	8a 81       	ldd	r24, Y+2	; 0x02
    1a24:	8f 70       	andi	r24, 0x0F	; 15
    1a26:	8a 83       	std	Y+2, r24	; 0x02
 PortARestore = PORTA;    // reading the PORTA original status
    1a28:	e2 e2       	ldi	r30, 0x22	; 34
    1a2a:	f0 e0       	ldi	r31, 0x00	; 0
    1a2c:	80 81       	ld	r24, Z
    1a2e:	89 83       	std	Y+1, r24	; 0x01
 PortARestore &= 0xF0;    // making lower direction nibbel to 0
    1a30:	89 81       	ldd	r24, Y+1	; 0x01
    1a32:	80 7f       	andi	r24, 0xF0	; 240
    1a34:	89 83       	std	Y+1, r24	; 0x01
 PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    1a36:	99 81       	ldd	r25, Y+1	; 0x01
    1a38:	8a 81       	ldd	r24, Y+2	; 0x02
    1a3a:	89 2b       	or	r24, r25
    1a3c:	89 83       	std	Y+1, r24	; 0x01
 PORTA = PortARestore;    // executing the command
    1a3e:	e2 e2       	ldi	r30, 0x22	; 34
    1a40:	f0 e0       	ldi	r31, 0x00	; 0
    1a42:	89 81       	ldd	r24, Y+1	; 0x01
    1a44:	80 83       	st	Z, r24
}
    1a46:	0f 90       	pop	r0
    1a48:	0f 90       	pop	r0
    1a4a:	cf 91       	pop	r28
    1a4c:	df 91       	pop	r29
    1a4e:	08 95       	ret

00001a50 <forward>:

void forward (void) //both wheels forward
{
    1a50:	df 93       	push	r29
    1a52:	cf 93       	push	r28
    1a54:	cd b7       	in	r28, 0x3d	; 61
    1a56:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x06);
    1a58:	86 e0       	ldi	r24, 0x06	; 6
    1a5a:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1a5e:	cf 91       	pop	r28
    1a60:	df 91       	pop	r29
    1a62:	08 95       	ret

00001a64 <back>:

void back (void) //both wheels backward
{
    1a64:	df 93       	push	r29
    1a66:	cf 93       	push	r28
    1a68:	cd b7       	in	r28, 0x3d	; 61
    1a6a:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x09);
    1a6c:	89 e0       	ldi	r24, 0x09	; 9
    1a6e:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1a72:	cf 91       	pop	r28
    1a74:	df 91       	pop	r29
    1a76:	08 95       	ret

00001a78 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
    1a78:	df 93       	push	r29
    1a7a:	cf 93       	push	r28
    1a7c:	cd b7       	in	r28, 0x3d	; 61
    1a7e:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x05);
    1a80:	85 e0       	ldi	r24, 0x05	; 5
    1a82:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1a86:	cf 91       	pop	r28
    1a88:	df 91       	pop	r29
    1a8a:	08 95       	ret

00001a8c <right>:

void right (void) //Left wheel forward, Right wheel backward
{
    1a8c:	df 93       	push	r29
    1a8e:	cf 93       	push	r28
    1a90:	cd b7       	in	r28, 0x3d	; 61
    1a92:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x0A);
    1a94:	8a e0       	ldi	r24, 0x0A	; 10
    1a96:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1a9a:	cf 91       	pop	r28
    1a9c:	df 91       	pop	r29
    1a9e:	08 95       	ret

00001aa0 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
    1aa0:	df 93       	push	r29
    1aa2:	cf 93       	push	r28
    1aa4:	cd b7       	in	r28, 0x3d	; 61
    1aa6:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x04);
    1aa8:	84 e0       	ldi	r24, 0x04	; 4
    1aaa:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1aae:	cf 91       	pop	r28
    1ab0:	df 91       	pop	r29
    1ab2:	08 95       	ret

00001ab4 <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
    1ab4:	df 93       	push	r29
    1ab6:	cf 93       	push	r28
    1ab8:	cd b7       	in	r28, 0x3d	; 61
    1aba:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x02);
    1abc:	82 e0       	ldi	r24, 0x02	; 2
    1abe:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1ac2:	cf 91       	pop	r28
    1ac4:	df 91       	pop	r29
    1ac6:	08 95       	ret

00001ac8 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
    1ac8:	df 93       	push	r29
    1aca:	cf 93       	push	r28
    1acc:	cd b7       	in	r28, 0x3d	; 61
    1ace:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x01);
    1ad0:	81 e0       	ldi	r24, 0x01	; 1
    1ad2:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1ad6:	cf 91       	pop	r28
    1ad8:	df 91       	pop	r29
    1ada:	08 95       	ret

00001adc <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
    1adc:	df 93       	push	r29
    1ade:	cf 93       	push	r28
    1ae0:	cd b7       	in	r28, 0x3d	; 61
    1ae2:	de b7       	in	r29, 0x3e	; 62
 motion_set(0x08);
    1ae4:	88 e0       	ldi	r24, 0x08	; 8
    1ae6:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1aea:	cf 91       	pop	r28
    1aec:	df 91       	pop	r29
    1aee:	08 95       	ret

00001af0 <stop>:

void stop (void)
{
    1af0:	df 93       	push	r29
    1af2:	cf 93       	push	r28
    1af4:	cd b7       	in	r28, 0x3d	; 61
    1af6:	de b7       	in	r29, 0x3e	; 62
  motion_set(0x00);
    1af8:	80 e0       	ldi	r24, 0x00	; 0
    1afa:	0e 94 09 0d 	call	0x1a12	; 0x1a12 <motion_set>
}
    1afe:	cf 91       	pop	r28
    1b00:	df 91       	pop	r29
    1b02:	08 95       	ret

00001b04 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
    1b04:	df 93       	push	r29
    1b06:	cf 93       	push	r28
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
    1b0c:	2c 97       	sbiw	r28, 0x0c	; 12
    1b0e:	0f b6       	in	r0, 0x3f	; 63
    1b10:	f8 94       	cli
    1b12:	de bf       	out	0x3e, r29	; 62
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	cd bf       	out	0x3d, r28	; 61
    1b18:	9a 87       	std	Y+10, r25	; 0x0a
    1b1a:	89 87       	std	Y+9, r24	; 0x09
 float ReqdShaftCount = 0;
    1b1c:	80 e0       	ldi	r24, 0x00	; 0
    1b1e:	90 e0       	ldi	r25, 0x00	; 0
    1b20:	a0 e0       	ldi	r26, 0x00	; 0
    1b22:	b0 e0       	ldi	r27, 0x00	; 0
    1b24:	8d 83       	std	Y+5, r24	; 0x05
    1b26:	9e 83       	std	Y+6, r25	; 0x06
    1b28:	af 83       	std	Y+7, r26	; 0x07
    1b2a:	b8 87       	std	Y+8, r27	; 0x08
 unsigned long int ReqdShaftCountInt = 0;
    1b2c:	19 82       	std	Y+1, r1	; 0x01
    1b2e:	1a 82       	std	Y+2, r1	; 0x02
    1b30:	1b 82       	std	Y+3, r1	; 0x03
    1b32:	1c 82       	std	Y+4, r1	; 0x04

 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    1b34:	89 85       	ldd	r24, Y+9	; 0x09
    1b36:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b38:	cc 01       	movw	r24, r24
    1b3a:	a0 e0       	ldi	r26, 0x00	; 0
    1b3c:	b0 e0       	ldi	r27, 0x00	; 0
    1b3e:	bc 01       	movw	r22, r24
    1b40:	cd 01       	movw	r24, r26
    1b42:	0e 94 89 22 	call	0x4512	; 0x4512 <__floatunsisf>
    1b46:	dc 01       	movw	r26, r24
    1b48:	cb 01       	movw	r24, r22
    1b4a:	bc 01       	movw	r22, r24
    1b4c:	cd 01       	movw	r24, r26
    1b4e:	28 e4       	ldi	r18, 0x48	; 72
    1b50:	31 ee       	ldi	r19, 0xE1	; 225
    1b52:	42 e8       	ldi	r20, 0x82	; 130
    1b54:	50 e4       	ldi	r21, 0x40	; 64
    1b56:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__divsf3>
    1b5a:	dc 01       	movw	r26, r24
    1b5c:	cb 01       	movw	r24, r22
    1b5e:	8d 83       	std	Y+5, r24	; 0x05
    1b60:	9e 83       	std	Y+6, r25	; 0x06
    1b62:	af 83       	std	Y+7, r26	; 0x07
    1b64:	b8 87       	std	Y+8, r27	; 0x08
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    1b66:	6d 81       	ldd	r22, Y+5	; 0x05
    1b68:	7e 81       	ldd	r23, Y+6	; 0x06
    1b6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1b6c:	98 85       	ldd	r25, Y+8	; 0x08
    1b6e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1b72:	dc 01       	movw	r26, r24
    1b74:	cb 01       	movw	r24, r22
    1b76:	cc 01       	movw	r24, r24
    1b78:	a0 e0       	ldi	r26, 0x00	; 0
    1b7a:	b0 e0       	ldi	r27, 0x00	; 0
    1b7c:	89 83       	std	Y+1, r24	; 0x01
    1b7e:	9a 83       	std	Y+2, r25	; 0x02
    1b80:	ab 83       	std	Y+3, r26	; 0x03
    1b82:	bc 83       	std	Y+4, r27	; 0x04
 ShaftCountRight = 0; 
    1b84:	10 92 2a 03 	sts	0x032A, r1
    1b88:	10 92 2b 03 	sts	0x032B, r1
    1b8c:	10 92 2c 03 	sts	0x032C, r1
    1b90:	10 92 2d 03 	sts	0x032D, r1
 ShaftCountLeft = 0; 
    1b94:	10 92 26 03 	sts	0x0326, r1
    1b98:	10 92 27 03 	sts	0x0327, r1
    1b9c:	10 92 28 03 	sts	0x0328, r1
    1ba0:	10 92 29 03 	sts	0x0329, r1

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    1ba4:	20 91 2a 03 	lds	r18, 0x032A
    1ba8:	30 91 2b 03 	lds	r19, 0x032B
    1bac:	40 91 2c 03 	lds	r20, 0x032C
    1bb0:	50 91 2d 03 	lds	r21, 0x032D
    1bb4:	1c 86       	std	Y+12, r1	; 0x0c
    1bb6:	89 81       	ldd	r24, Y+1	; 0x01
    1bb8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bba:	ab 81       	ldd	r26, Y+3	; 0x03
    1bbc:	bc 81       	ldd	r27, Y+4	; 0x04
    1bbe:	28 17       	cp	r18, r24
    1bc0:	39 07       	cpc	r19, r25
    1bc2:	4a 07       	cpc	r20, r26
    1bc4:	5b 07       	cpc	r21, r27
    1bc6:	10 f0       	brcs	.+4      	; 0x1bcc <angle_rotate+0xc8>
    1bc8:	81 e0       	ldi	r24, 0x01	; 1
    1bca:	8c 87       	std	Y+12, r24	; 0x0c
    1bcc:	20 91 26 03 	lds	r18, 0x0326
    1bd0:	30 91 27 03 	lds	r19, 0x0327
    1bd4:	40 91 28 03 	lds	r20, 0x0328
    1bd8:	50 91 29 03 	lds	r21, 0x0329
    1bdc:	1b 86       	std	Y+11, r1	; 0x0b
    1bde:	89 81       	ldd	r24, Y+1	; 0x01
    1be0:	9a 81       	ldd	r25, Y+2	; 0x02
    1be2:	ab 81       	ldd	r26, Y+3	; 0x03
    1be4:	bc 81       	ldd	r27, Y+4	; 0x04
    1be6:	28 17       	cp	r18, r24
    1be8:	39 07       	cpc	r19, r25
    1bea:	4a 07       	cpc	r20, r26
    1bec:	5b 07       	cpc	r21, r27
    1bee:	10 f0       	brcs	.+4      	; 0x1bf4 <angle_rotate+0xf0>
    1bf0:	91 e0       	ldi	r25, 0x01	; 1
    1bf2:	9b 87       	std	Y+11, r25	; 0x0b
    1bf4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bf6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bf8:	89 2b       	or	r24, r25
    1bfa:	88 23       	and	r24, r24
    1bfc:	99 f2       	breq	.-90     	; 0x1ba4 <angle_rotate+0xa0>
  break;
 }
 stop(); //Stop robot
    1bfe:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <stop>
}
    1c02:	2c 96       	adiw	r28, 0x0c	; 12
    1c04:	0f b6       	in	r0, 0x3f	; 63
    1c06:	f8 94       	cli
    1c08:	de bf       	out	0x3e, r29	; 62
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	cd bf       	out	0x3d, r28	; 61
    1c0e:	cf 91       	pop	r28
    1c10:	df 91       	pop	r29
    1c12:	08 95       	ret

00001c14 <linear_distance_mm>:

//Function used for moving robot forward by specified distance

void linear_distance_mm(unsigned int DistanceInMM)
{
    1c14:	df 93       	push	r29
    1c16:	cf 93       	push	r28
    1c18:	cd b7       	in	r28, 0x3d	; 61
    1c1a:	de b7       	in	r29, 0x3e	; 62
    1c1c:	2a 97       	sbiw	r28, 0x0a	; 10
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	de bf       	out	0x3e, r29	; 62
    1c24:	0f be       	out	0x3f, r0	; 63
    1c26:	cd bf       	out	0x3d, r28	; 61
    1c28:	9a 87       	std	Y+10, r25	; 0x0a
    1c2a:	89 87       	std	Y+9, r24	; 0x09
 float ReqdShaftCount = 0;
    1c2c:	80 e0       	ldi	r24, 0x00	; 0
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	a0 e0       	ldi	r26, 0x00	; 0
    1c32:	b0 e0       	ldi	r27, 0x00	; 0
    1c34:	8d 83       	std	Y+5, r24	; 0x05
    1c36:	9e 83       	std	Y+6, r25	; 0x06
    1c38:	af 83       	std	Y+7, r26	; 0x07
    1c3a:	b8 87       	std	Y+8, r27	; 0x08
 unsigned long int ReqdShaftCountInt = 0;
    1c3c:	19 82       	std	Y+1, r1	; 0x01
    1c3e:	1a 82       	std	Y+2, r1	; 0x02
    1c40:	1b 82       	std	Y+3, r1	; 0x03
    1c42:	1c 82       	std	Y+4, r1	; 0x04

 ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    1c44:	89 85       	ldd	r24, Y+9	; 0x09
    1c46:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c48:	cc 01       	movw	r24, r24
    1c4a:	a0 e0       	ldi	r26, 0x00	; 0
    1c4c:	b0 e0       	ldi	r27, 0x00	; 0
    1c4e:	bc 01       	movw	r22, r24
    1c50:	cd 01       	movw	r24, r26
    1c52:	0e 94 89 22 	call	0x4512	; 0x4512 <__floatunsisf>
    1c56:	dc 01       	movw	r26, r24
    1c58:	cb 01       	movw	r24, r22
    1c5a:	bc 01       	movw	r22, r24
    1c5c:	cd 01       	movw	r24, r26
    1c5e:	25 ee       	ldi	r18, 0xE5	; 229
    1c60:	30 ed       	ldi	r19, 0xD0	; 208
    1c62:	4a ea       	ldi	r20, 0xAA	; 170
    1c64:	50 e4       	ldi	r21, 0x40	; 64
    1c66:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__divsf3>
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	cb 01       	movw	r24, r22
    1c6e:	8d 83       	std	Y+5, r24	; 0x05
    1c70:	9e 83       	std	Y+6, r25	; 0x06
    1c72:	af 83       	std	Y+7, r26	; 0x07
    1c74:	b8 87       	std	Y+8, r27	; 0x08
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    1c76:	6d 81       	ldd	r22, Y+5	; 0x05
    1c78:	7e 81       	ldd	r23, Y+6	; 0x06
    1c7a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c7c:	98 85       	ldd	r25, Y+8	; 0x08
    1c7e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1c82:	dc 01       	movw	r26, r24
    1c84:	cb 01       	movw	r24, r22
    1c86:	89 83       	std	Y+1, r24	; 0x01
    1c88:	9a 83       	std	Y+2, r25	; 0x02
    1c8a:	ab 83       	std	Y+3, r26	; 0x03
    1c8c:	bc 83       	std	Y+4, r27	; 0x04
  
 ShaftCountRight = 0;
    1c8e:	10 92 2a 03 	sts	0x032A, r1
    1c92:	10 92 2b 03 	sts	0x032B, r1
    1c96:	10 92 2c 03 	sts	0x032C, r1
    1c9a:	10 92 2d 03 	sts	0x032D, r1
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
    1c9e:	20 91 2a 03 	lds	r18, 0x032A
    1ca2:	30 91 2b 03 	lds	r19, 0x032B
    1ca6:	40 91 2c 03 	lds	r20, 0x032C
    1caa:	50 91 2d 03 	lds	r21, 0x032D
    1cae:	89 81       	ldd	r24, Y+1	; 0x01
    1cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    1cb2:	ab 81       	ldd	r26, Y+3	; 0x03
    1cb4:	bc 81       	ldd	r27, Y+4	; 0x04
    1cb6:	82 17       	cp	r24, r18
    1cb8:	93 07       	cpc	r25, r19
    1cba:	a4 07       	cpc	r26, r20
    1cbc:	b5 07       	cpc	r27, r21
    1cbe:	78 f7       	brcc	.-34     	; 0x1c9e <linear_distance_mm+0x8a>
  {
    break;
  }
 } 
 stop(); //Stop robot
    1cc0:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <stop>
}
    1cc4:	2a 96       	adiw	r28, 0x0a	; 10
    1cc6:	0f b6       	in	r0, 0x3f	; 63
    1cc8:	f8 94       	cli
    1cca:	de bf       	out	0x3e, r29	; 62
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	cd bf       	out	0x3d, r28	; 61
    1cd0:	cf 91       	pop	r28
    1cd2:	df 91       	pop	r29
    1cd4:	08 95       	ret

00001cd6 <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
    1cd6:	df 93       	push	r29
    1cd8:	cf 93       	push	r28
    1cda:	0f 92       	push	r0
    1cdc:	0f 92       	push	r0
    1cde:	cd b7       	in	r28, 0x3d	; 61
    1ce0:	de b7       	in	r29, 0x3e	; 62
    1ce2:	9a 83       	std	Y+2, r25	; 0x02
    1ce4:	89 83       	std	Y+1, r24	; 0x01
 forward();
    1ce6:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <forward>
 linear_distance_mm(DistanceInMM);
    1cea:	89 81       	ldd	r24, Y+1	; 0x01
    1cec:	9a 81       	ldd	r25, Y+2	; 0x02
    1cee:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <linear_distance_mm>
}
    1cf2:	0f 90       	pop	r0
    1cf4:	0f 90       	pop	r0
    1cf6:	cf 91       	pop	r28
    1cf8:	df 91       	pop	r29
    1cfa:	08 95       	ret

00001cfc <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
    1cfc:	df 93       	push	r29
    1cfe:	cf 93       	push	r28
    1d00:	0f 92       	push	r0
    1d02:	0f 92       	push	r0
    1d04:	cd b7       	in	r28, 0x3d	; 61
    1d06:	de b7       	in	r29, 0x3e	; 62
    1d08:	9a 83       	std	Y+2, r25	; 0x02
    1d0a:	89 83       	std	Y+1, r24	; 0x01
 back();
    1d0c:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <back>
 linear_distance_mm(DistanceInMM);
    1d10:	89 81       	ldd	r24, Y+1	; 0x01
    1d12:	9a 81       	ldd	r25, Y+2	; 0x02
    1d14:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <linear_distance_mm>
}
    1d18:	0f 90       	pop	r0
    1d1a:	0f 90       	pop	r0
    1d1c:	cf 91       	pop	r28
    1d1e:	df 91       	pop	r29
    1d20:	08 95       	ret

00001d22 <left_degrees>:

void left_degrees(unsigned int Degrees) 
{
    1d22:	df 93       	push	r29
    1d24:	cf 93       	push	r28
    1d26:	0f 92       	push	r0
    1d28:	0f 92       	push	r0
    1d2a:	cd b7       	in	r28, 0x3d	; 61
    1d2c:	de b7       	in	r29, 0x3e	; 62
    1d2e:	9a 83       	std	Y+2, r25	; 0x02
    1d30:	89 83       	std	Y+1, r24	; 0x01
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
    1d32:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <left>
 angle_rotate(Degrees);
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3a:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1d3e:	0f 90       	pop	r0
    1d40:	0f 90       	pop	r0
    1d42:	cf 91       	pop	r28
    1d44:	df 91       	pop	r29
    1d46:	08 95       	ret

00001d48 <right_degrees>:



void right_degrees(unsigned int Degrees)
{
    1d48:	df 93       	push	r29
    1d4a:	cf 93       	push	r28
    1d4c:	0f 92       	push	r0
    1d4e:	0f 92       	push	r0
    1d50:	cd b7       	in	r28, 0x3d	; 61
    1d52:	de b7       	in	r29, 0x3e	; 62
    1d54:	9a 83       	std	Y+2, r25	; 0x02
    1d56:	89 83       	std	Y+1, r24	; 0x01
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
    1d58:	0e 94 46 0d 	call	0x1a8c	; 0x1a8c <right>
 angle_rotate(Degrees);
    1d5c:	89 81       	ldd	r24, Y+1	; 0x01
    1d5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d60:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	cf 91       	pop	r28
    1d6a:	df 91       	pop	r29
    1d6c:	08 95       	ret

00001d6e <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
    1d6e:	df 93       	push	r29
    1d70:	cf 93       	push	r28
    1d72:	0f 92       	push	r0
    1d74:	0f 92       	push	r0
    1d76:	cd b7       	in	r28, 0x3d	; 61
    1d78:	de b7       	in	r29, 0x3e	; 62
    1d7a:	9a 83       	std	Y+2, r25	; 0x02
    1d7c:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
    1d7e:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <soft_left>
 Degrees=Degrees*2;
    1d82:	89 81       	ldd	r24, Y+1	; 0x01
    1d84:	9a 81       	ldd	r25, Y+2	; 0x02
    1d86:	88 0f       	add	r24, r24
    1d88:	99 1f       	adc	r25, r25
    1d8a:	9a 83       	std	Y+2, r25	; 0x02
    1d8c:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    1d8e:	89 81       	ldd	r24, Y+1	; 0x01
    1d90:	9a 81       	ldd	r25, Y+2	; 0x02
    1d92:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1d96:	0f 90       	pop	r0
    1d98:	0f 90       	pop	r0
    1d9a:	cf 91       	pop	r28
    1d9c:	df 91       	pop	r29
    1d9e:	08 95       	ret

00001da0 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
    1da0:	df 93       	push	r29
    1da2:	cf 93       	push	r28
    1da4:	0f 92       	push	r0
    1da6:	0f 92       	push	r0
    1da8:	cd b7       	in	r28, 0x3d	; 61
    1daa:	de b7       	in	r29, 0x3e	; 62
    1dac:	9a 83       	std	Y+2, r25	; 0x02
    1dae:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
    1db0:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <soft_right>
 Degrees=Degrees*2;
    1db4:	89 81       	ldd	r24, Y+1	; 0x01
    1db6:	9a 81       	ldd	r25, Y+2	; 0x02
    1db8:	88 0f       	add	r24, r24
    1dba:	99 1f       	adc	r25, r25
    1dbc:	9a 83       	std	Y+2, r25	; 0x02
    1dbe:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    1dc0:	89 81       	ldd	r24, Y+1	; 0x01
    1dc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1dc4:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1dc8:	0f 90       	pop	r0
    1dca:	0f 90       	pop	r0
    1dcc:	cf 91       	pop	r28
    1dce:	df 91       	pop	r29
    1dd0:	08 95       	ret

00001dd2 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
    1dd2:	df 93       	push	r29
    1dd4:	cf 93       	push	r28
    1dd6:	0f 92       	push	r0
    1dd8:	0f 92       	push	r0
    1dda:	cd b7       	in	r28, 0x3d	; 61
    1ddc:	de b7       	in	r29, 0x3e	; 62
    1dde:	9a 83       	std	Y+2, r25	; 0x02
    1de0:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left_2(); //Turn reverse soft left
    1de2:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <soft_left_2>
 Degrees=Degrees*2;
    1de6:	89 81       	ldd	r24, Y+1	; 0x01
    1de8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dea:	88 0f       	add	r24, r24
    1dec:	99 1f       	adc	r25, r25
    1dee:	9a 83       	std	Y+2, r25	; 0x02
    1df0:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    1df2:	89 81       	ldd	r24, Y+1	; 0x01
    1df4:	9a 81       	ldd	r25, Y+2	; 0x02
    1df6:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1dfa:	0f 90       	pop	r0
    1dfc:	0f 90       	pop	r0
    1dfe:	cf 91       	pop	r28
    1e00:	df 91       	pop	r29
    1e02:	08 95       	ret

00001e04 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
    1e04:	df 93       	push	r29
    1e06:	cf 93       	push	r28
    1e08:	0f 92       	push	r0
    1e0a:	0f 92       	push	r0
    1e0c:	cd b7       	in	r28, 0x3d	; 61
    1e0e:	de b7       	in	r29, 0x3e	; 62
    1e10:	9a 83       	std	Y+2, r25	; 0x02
    1e12:	89 83       	std	Y+1, r24	; 0x01
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right_2();  //Turn reverse soft right
    1e14:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <soft_right_2>
 Degrees=Degrees*2;
    1e18:	89 81       	ldd	r24, Y+1	; 0x01
    1e1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e1c:	88 0f       	add	r24, r24
    1e1e:	99 1f       	adc	r25, r25
    1e20:	9a 83       	std	Y+2, r25	; 0x02
    1e22:	89 83       	std	Y+1, r24	; 0x01
 angle_rotate(Degrees);
    1e24:	89 81       	ldd	r24, Y+1	; 0x01
    1e26:	9a 81       	ldd	r25, Y+2	; 0x02
    1e28:	0e 94 82 0d 	call	0x1b04	; 0x1b04 <angle_rotate>
}
    1e2c:	0f 90       	pop	r0
    1e2e:	0f 90       	pop	r0
    1e30:	cf 91       	pop	r28
    1e32:	df 91       	pop	r29
    1e34:	08 95       	ret

00001e36 <init_devices>:

void init_devices(void)
{
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	cd b7       	in	r28, 0x3d	; 61
    1e3c:	de b7       	in	r29, 0x3e	; 62
  cli(); //Clears the global interrupt
    1e3e:	f8 94       	cli
  port_init();  //Initializes all the ports
    1e40:	0e 94 09 0b 	call	0x1612	; 0x1612 <port_init>
  color_sensor_pin_interrupt_init();
    1e44:	0e 94 4e 0b 	call	0x169c	; 0x169c <color_sensor_pin_interrupt_init>
  timer1_init();
    1e48:	0e 94 be 0b 	call	0x177c	; 0x177c <timer1_init>
  left_position_encoder_interrupt_init();
    1e4c:	0e 94 65 0b 	call	0x16ca	; 0x16ca <left_position_encoder_interrupt_init>
  right_position_encoder_interrupt_init();
    1e50:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <right_position_encoder_interrupt_init>
  adc_init();
    1e54:	0e 94 2d 0c 	call	0x185a	; 0x185a <adc_init>
  timer5_init();
    1e58:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <timer5_init>
  sei();   // Enables the global interrupt
    1e5c:	78 94       	sei
}
    1e5e:	cf 91       	pop	r28
    1e60:	df 91       	pop	r29
    1e62:	08 95       	ret

00001e64 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
    1e64:	df 93       	push	r29
    1e66:	cf 93       	push	r28
    1e68:	cd b7       	in	r28, 0x3d	; 61
    1e6a:	de b7       	in	r29, 0x3e	; 62
  //Filter Select - red filter
  PORTD = PORTD & 0xBF; //set S2 low
    1e6c:	ab e2       	ldi	r26, 0x2B	; 43
    1e6e:	b0 e0       	ldi	r27, 0x00	; 0
    1e70:	eb e2       	ldi	r30, 0x2B	; 43
    1e72:	f0 e0       	ldi	r31, 0x00	; 0
    1e74:	80 81       	ld	r24, Z
    1e76:	8f 7b       	andi	r24, 0xBF	; 191
    1e78:	8c 93       	st	X, r24
  PORTD = PORTD & 0x7F; //set S3 low
    1e7a:	ab e2       	ldi	r26, 0x2B	; 43
    1e7c:	b0 e0       	ldi	r27, 0x00	; 0
    1e7e:	eb e2       	ldi	r30, 0x2B	; 43
    1e80:	f0 e0       	ldi	r31, 0x00	; 0
    1e82:	80 81       	ld	r24, Z
    1e84:	8f 77       	andi	r24, 0x7F	; 127
    1e86:	8c 93       	st	X, r24
}
    1e88:	cf 91       	pop	r28
    1e8a:	df 91       	pop	r29
    1e8c:	08 95       	ret

00001e8e <filter_green>:

void filter_green(void) //Used to select green filter
{
    1e8e:	df 93       	push	r29
    1e90:	cf 93       	push	r28
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
  //Filter Select - green filter
  PORTD = PORTD | 0x40; //set S2 High
    1e96:	ab e2       	ldi	r26, 0x2B	; 43
    1e98:	b0 e0       	ldi	r27, 0x00	; 0
    1e9a:	eb e2       	ldi	r30, 0x2B	; 43
    1e9c:	f0 e0       	ldi	r31, 0x00	; 0
    1e9e:	80 81       	ld	r24, Z
    1ea0:	80 64       	ori	r24, 0x40	; 64
    1ea2:	8c 93       	st	X, r24
  PORTD = PORTD | 0x80; //set S3 High
    1ea4:	ab e2       	ldi	r26, 0x2B	; 43
    1ea6:	b0 e0       	ldi	r27, 0x00	; 0
    1ea8:	eb e2       	ldi	r30, 0x2B	; 43
    1eaa:	f0 e0       	ldi	r31, 0x00	; 0
    1eac:	80 81       	ld	r24, Z
    1eae:	80 68       	ori	r24, 0x80	; 128
    1eb0:	8c 93       	st	X, r24
}
    1eb2:	cf 91       	pop	r28
    1eb4:	df 91       	pop	r29
    1eb6:	08 95       	ret

00001eb8 <filter_blue>:

void filter_blue(void)  //Used to select blue filter
{
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	cd b7       	in	r28, 0x3d	; 61
    1ebe:	de b7       	in	r29, 0x3e	; 62
  //Filter Select - blue filter
  PORTD = PORTD & 0xBF; //set S2 low
    1ec0:	ab e2       	ldi	r26, 0x2B	; 43
    1ec2:	b0 e0       	ldi	r27, 0x00	; 0
    1ec4:	eb e2       	ldi	r30, 0x2B	; 43
    1ec6:	f0 e0       	ldi	r31, 0x00	; 0
    1ec8:	80 81       	ld	r24, Z
    1eca:	8f 7b       	andi	r24, 0xBF	; 191
    1ecc:	8c 93       	st	X, r24
  PORTD = PORTD | 0x80; //set S3 High
    1ece:	ab e2       	ldi	r26, 0x2B	; 43
    1ed0:	b0 e0       	ldi	r27, 0x00	; 0
    1ed2:	eb e2       	ldi	r30, 0x2B	; 43
    1ed4:	f0 e0       	ldi	r31, 0x00	; 0
    1ed6:	80 81       	ld	r24, Z
    1ed8:	80 68       	ori	r24, 0x80	; 128
    1eda:	8c 93       	st	X, r24
}
    1edc:	cf 91       	pop	r28
    1ede:	df 91       	pop	r29
    1ee0:	08 95       	ret

00001ee2 <filter_clear>:

void filter_clear(void) //select no filter
{
    1ee2:	df 93       	push	r29
    1ee4:	cf 93       	push	r28
    1ee6:	cd b7       	in	r28, 0x3d	; 61
    1ee8:	de b7       	in	r29, 0x3e	; 62
  //Filter Select - no filter
  PORTD = PORTD | 0x40; //set S2 High
    1eea:	ab e2       	ldi	r26, 0x2B	; 43
    1eec:	b0 e0       	ldi	r27, 0x00	; 0
    1eee:	eb e2       	ldi	r30, 0x2B	; 43
    1ef0:	f0 e0       	ldi	r31, 0x00	; 0
    1ef2:	80 81       	ld	r24, Z
    1ef4:	80 64       	ori	r24, 0x40	; 64
    1ef6:	8c 93       	st	X, r24
  PORTD = PORTD & 0x7F; //set S3 Low
    1ef8:	ab e2       	ldi	r26, 0x2B	; 43
    1efa:	b0 e0       	ldi	r27, 0x00	; 0
    1efc:	eb e2       	ldi	r30, 0x2B	; 43
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	80 81       	ld	r24, Z
    1f02:	8f 77       	andi	r24, 0x7F	; 127
    1f04:	8c 93       	st	X, r24
}
    1f06:	cf 91       	pop	r28
    1f08:	df 91       	pop	r29
    1f0a:	08 95       	ret

00001f0c <color_sensor_scaling>:

//Color Sensing Scaling
void color_sensor_scaling()   //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
    1f0c:	df 93       	push	r29
    1f0e:	cf 93       	push	r28
    1f10:	cd b7       	in	r28, 0x3d	; 61
    1f12:	de b7       	in	r29, 0x3e	; 62
  //Output Scaling 20% from datasheet
  //PORTD = PORTD & 0xEF;
  PORTD = PORTD | 0x10; //set S0 high
    1f14:	ab e2       	ldi	r26, 0x2B	; 43
    1f16:	b0 e0       	ldi	r27, 0x00	; 0
    1f18:	eb e2       	ldi	r30, 0x2B	; 43
    1f1a:	f0 e0       	ldi	r31, 0x00	; 0
    1f1c:	80 81       	ld	r24, Z
    1f1e:	80 61       	ori	r24, 0x10	; 16
    1f20:	8c 93       	st	X, r24
  //PORTD = PORTD & 0xDF; //set S1 low
  PORTD = PORTD | 0x20; //set S1 high
    1f22:	ab e2       	ldi	r26, 0x2B	; 43
    1f24:	b0 e0       	ldi	r27, 0x00	; 0
    1f26:	eb e2       	ldi	r30, 0x2B	; 43
    1f28:	f0 e0       	ldi	r31, 0x00	; 0
    1f2a:	80 81       	ld	r24, Z
    1f2c:	80 62       	ori	r24, 0x20	; 32
    1f2e:	8c 93       	st	X, r24
}
    1f30:	cf 91       	pop	r28
    1f32:	df 91       	pop	r29
    1f34:	08 95       	ret

00001f36 <red_read>:

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
    1f36:	df 93       	push	r29
    1f38:	cf 93       	push	r28
    1f3a:	cd b7       	in	r28, 0x3d	; 61
    1f3c:	de b7       	in	r29, 0x3e	; 62
    1f3e:	2e 97       	sbiw	r28, 0x0e	; 14
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	de bf       	out	0x3e, r29	; 62
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	cd bf       	out	0x3d, r28	; 61
  //Red
  filter_red(); //select red filter
    1f4a:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <filter_red>
  pulse=0; //reset the count to 0
    1f4e:	10 92 22 03 	sts	0x0322, r1
    1f52:	10 92 23 03 	sts	0x0323, r1
    1f56:	10 92 24 03 	sts	0x0324, r1
    1f5a:	10 92 25 03 	sts	0x0325, r1
    1f5e:	80 e0       	ldi	r24, 0x00	; 0
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	a8 ec       	ldi	r26, 0xC8	; 200
    1f64:	b2 e4       	ldi	r27, 0x42	; 66
    1f66:	8b 87       	std	Y+11, r24	; 0x0b
    1f68:	9c 87       	std	Y+12, r25	; 0x0c
    1f6a:	ad 87       	std	Y+13, r26	; 0x0d
    1f6c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f6e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f70:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f72:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f74:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f76:	26 e6       	ldi	r18, 0x66	; 102
    1f78:	36 e6       	ldi	r19, 0x66	; 102
    1f7a:	46 e6       	ldi	r20, 0x66	; 102
    1f7c:	55 e4       	ldi	r21, 0x45	; 69
    1f7e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    1f82:	dc 01       	movw	r26, r24
    1f84:	cb 01       	movw	r24, r22
    1f86:	8f 83       	std	Y+7, r24	; 0x07
    1f88:	98 87       	std	Y+8, r25	; 0x08
    1f8a:	a9 87       	std	Y+9, r26	; 0x09
    1f8c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f8e:	6f 81       	ldd	r22, Y+7	; 0x07
    1f90:	78 85       	ldd	r23, Y+8	; 0x08
    1f92:	89 85       	ldd	r24, Y+9	; 0x09
    1f94:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f96:	20 e0       	ldi	r18, 0x00	; 0
    1f98:	30 e0       	ldi	r19, 0x00	; 0
    1f9a:	40 e8       	ldi	r20, 0x80	; 128
    1f9c:	5f e3       	ldi	r21, 0x3F	; 63
    1f9e:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    1fa2:	88 23       	and	r24, r24
    1fa4:	2c f4       	brge	.+10     	; 0x1fb0 <red_read+0x7a>
		__ticks = 1;
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	9e 83       	std	Y+6, r25	; 0x06
    1fac:	8d 83       	std	Y+5, r24	; 0x05
    1fae:	3f c0       	rjmp	.+126    	; 0x202e <red_read+0xf8>
	else if (__tmp > 65535)
    1fb0:	6f 81       	ldd	r22, Y+7	; 0x07
    1fb2:	78 85       	ldd	r23, Y+8	; 0x08
    1fb4:	89 85       	ldd	r24, Y+9	; 0x09
    1fb6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fb8:	20 e0       	ldi	r18, 0x00	; 0
    1fba:	3f ef       	ldi	r19, 0xFF	; 255
    1fbc:	4f e7       	ldi	r20, 0x7F	; 127
    1fbe:	57 e4       	ldi	r21, 0x47	; 71
    1fc0:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    1fc4:	18 16       	cp	r1, r24
    1fc6:	4c f5       	brge	.+82     	; 0x201a <red_read+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1fc8:	6b 85       	ldd	r22, Y+11	; 0x0b
    1fca:	7c 85       	ldd	r23, Y+12	; 0x0c
    1fcc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1fce:	9e 85       	ldd	r25, Y+14	; 0x0e
    1fd0:	20 e0       	ldi	r18, 0x00	; 0
    1fd2:	30 e0       	ldi	r19, 0x00	; 0
    1fd4:	40 e2       	ldi	r20, 0x20	; 32
    1fd6:	51 e4       	ldi	r21, 0x41	; 65
    1fd8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    1fdc:	dc 01       	movw	r26, r24
    1fde:	cb 01       	movw	r24, r22
    1fe0:	bc 01       	movw	r22, r24
    1fe2:	cd 01       	movw	r24, r26
    1fe4:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    1fe8:	dc 01       	movw	r26, r24
    1fea:	cb 01       	movw	r24, r22
    1fec:	9e 83       	std	Y+6, r25	; 0x06
    1fee:	8d 83       	std	Y+5, r24	; 0x05
    1ff0:	0f c0       	rjmp	.+30     	; 0x2010 <red_read+0xda>
    1ff2:	80 e7       	ldi	r24, 0x70	; 112
    1ff4:	91 e0       	ldi	r25, 0x01	; 1
    1ff6:	9c 83       	std	Y+4, r25	; 0x04
    1ff8:	8b 83       	std	Y+3, r24	; 0x03
    1ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    1ffc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ffe:	01 97       	sbiw	r24, 0x01	; 1
    2000:	f1 f7       	brne	.-4      	; 0x1ffe <red_read+0xc8>
    2002:	9c 83       	std	Y+4, r25	; 0x04
    2004:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2006:	8d 81       	ldd	r24, Y+5	; 0x05
    2008:	9e 81       	ldd	r25, Y+6	; 0x06
    200a:	01 97       	sbiw	r24, 0x01	; 1
    200c:	9e 83       	std	Y+6, r25	; 0x06
    200e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2010:	8d 81       	ldd	r24, Y+5	; 0x05
    2012:	9e 81       	ldd	r25, Y+6	; 0x06
    2014:	00 97       	sbiw	r24, 0x00	; 0
    2016:	69 f7       	brne	.-38     	; 0x1ff2 <red_read+0xbc>
    2018:	14 c0       	rjmp	.+40     	; 0x2042 <red_read+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    201a:	6f 81       	ldd	r22, Y+7	; 0x07
    201c:	78 85       	ldd	r23, Y+8	; 0x08
    201e:	89 85       	ldd	r24, Y+9	; 0x09
    2020:	9a 85       	ldd	r25, Y+10	; 0x0a
    2022:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2026:	dc 01       	movw	r26, r24
    2028:	cb 01       	movw	r24, r22
    202a:	9e 83       	std	Y+6, r25	; 0x06
    202c:	8d 83       	std	Y+5, r24	; 0x05
    202e:	8d 81       	ldd	r24, Y+5	; 0x05
    2030:	9e 81       	ldd	r25, Y+6	; 0x06
    2032:	9a 83       	std	Y+2, r25	; 0x02
    2034:	89 83       	std	Y+1, r24	; 0x01
    2036:	89 81       	ldd	r24, Y+1	; 0x01
    2038:	9a 81       	ldd	r25, Y+2	; 0x02
    203a:	01 97       	sbiw	r24, 0x01	; 1
    203c:	f1 f7       	brne	.-4      	; 0x203a <red_read+0x104>
    203e:	9a 83       	std	Y+2, r25	; 0x02
    2040:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  red = pulse;  //store the count in variable called red
    2042:	80 91 22 03 	lds	r24, 0x0322
    2046:	90 91 23 03 	lds	r25, 0x0323
    204a:	a0 91 24 03 	lds	r26, 0x0324
    204e:	b0 91 25 03 	lds	r27, 0x0325
    2052:	80 93 42 03 	sts	0x0342, r24
    2056:	90 93 43 03 	sts	0x0343, r25
    205a:	a0 93 44 03 	sts	0x0344, r26
    205e:	b0 93 45 03 	sts	0x0345, r27
//  lcd_cursor(1,1);  //set the cursor on row 1, column 1
//  lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
//  lcd_print(2,1,red,5);  //Print the count on second row
//  _delay_ms(1000);  // Display for 1000ms or 1 second
//  lcd_wr_command(0x01); //Clear the LCD
}
    2062:	2e 96       	adiw	r28, 0x0e	; 14
    2064:	0f b6       	in	r0, 0x3f	; 63
    2066:	f8 94       	cli
    2068:	de bf       	out	0x3e, r29	; 62
    206a:	0f be       	out	0x3f, r0	; 63
    206c:	cd bf       	out	0x3d, r28	; 61
    206e:	cf 91       	pop	r28
    2070:	df 91       	pop	r29
    2072:	08 95       	ret

00002074 <green_read>:

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
    2074:	df 93       	push	r29
    2076:	cf 93       	push	r28
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	2e 97       	sbiw	r28, 0x0e	; 14
    207e:	0f b6       	in	r0, 0x3f	; 63
    2080:	f8 94       	cli
    2082:	de bf       	out	0x3e, r29	; 62
    2084:	0f be       	out	0x3f, r0	; 63
    2086:	cd bf       	out	0x3d, r28	; 61
  //Green
  filter_green(); //select green filter
    2088:	0e 94 47 0f 	call	0x1e8e	; 0x1e8e <filter_green>
  pulse=0; //reset the count to 0
    208c:	10 92 22 03 	sts	0x0322, r1
    2090:	10 92 23 03 	sts	0x0323, r1
    2094:	10 92 24 03 	sts	0x0324, r1
    2098:	10 92 25 03 	sts	0x0325, r1
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	a8 ec       	ldi	r26, 0xC8	; 200
    20a2:	b2 e4       	ldi	r27, 0x42	; 66
    20a4:	8b 87       	std	Y+11, r24	; 0x0b
    20a6:	9c 87       	std	Y+12, r25	; 0x0c
    20a8:	ad 87       	std	Y+13, r26	; 0x0d
    20aa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20ac:	6b 85       	ldd	r22, Y+11	; 0x0b
    20ae:	7c 85       	ldd	r23, Y+12	; 0x0c
    20b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    20b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    20b4:	26 e6       	ldi	r18, 0x66	; 102
    20b6:	36 e6       	ldi	r19, 0x66	; 102
    20b8:	46 e6       	ldi	r20, 0x66	; 102
    20ba:	55 e4       	ldi	r21, 0x45	; 69
    20bc:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    20c0:	dc 01       	movw	r26, r24
    20c2:	cb 01       	movw	r24, r22
    20c4:	8f 83       	std	Y+7, r24	; 0x07
    20c6:	98 87       	std	Y+8, r25	; 0x08
    20c8:	a9 87       	std	Y+9, r26	; 0x09
    20ca:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    20cc:	6f 81       	ldd	r22, Y+7	; 0x07
    20ce:	78 85       	ldd	r23, Y+8	; 0x08
    20d0:	89 85       	ldd	r24, Y+9	; 0x09
    20d2:	9a 85       	ldd	r25, Y+10	; 0x0a
    20d4:	20 e0       	ldi	r18, 0x00	; 0
    20d6:	30 e0       	ldi	r19, 0x00	; 0
    20d8:	40 e8       	ldi	r20, 0x80	; 128
    20da:	5f e3       	ldi	r21, 0x3F	; 63
    20dc:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    20e0:	88 23       	and	r24, r24
    20e2:	2c f4       	brge	.+10     	; 0x20ee <green_read+0x7a>
		__ticks = 1;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	9e 83       	std	Y+6, r25	; 0x06
    20ea:	8d 83       	std	Y+5, r24	; 0x05
    20ec:	3f c0       	rjmp	.+126    	; 0x216c <green_read+0xf8>
	else if (__tmp > 65535)
    20ee:	6f 81       	ldd	r22, Y+7	; 0x07
    20f0:	78 85       	ldd	r23, Y+8	; 0x08
    20f2:	89 85       	ldd	r24, Y+9	; 0x09
    20f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    20f6:	20 e0       	ldi	r18, 0x00	; 0
    20f8:	3f ef       	ldi	r19, 0xFF	; 255
    20fa:	4f e7       	ldi	r20, 0x7F	; 127
    20fc:	57 e4       	ldi	r21, 0x47	; 71
    20fe:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2102:	18 16       	cp	r1, r24
    2104:	4c f5       	brge	.+82     	; 0x2158 <green_read+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2106:	6b 85       	ldd	r22, Y+11	; 0x0b
    2108:	7c 85       	ldd	r23, Y+12	; 0x0c
    210a:	8d 85       	ldd	r24, Y+13	; 0x0d
    210c:	9e 85       	ldd	r25, Y+14	; 0x0e
    210e:	20 e0       	ldi	r18, 0x00	; 0
    2110:	30 e0       	ldi	r19, 0x00	; 0
    2112:	40 e2       	ldi	r20, 0x20	; 32
    2114:	51 e4       	ldi	r21, 0x41	; 65
    2116:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    211a:	dc 01       	movw	r26, r24
    211c:	cb 01       	movw	r24, r22
    211e:	bc 01       	movw	r22, r24
    2120:	cd 01       	movw	r24, r26
    2122:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2126:	dc 01       	movw	r26, r24
    2128:	cb 01       	movw	r24, r22
    212a:	9e 83       	std	Y+6, r25	; 0x06
    212c:	8d 83       	std	Y+5, r24	; 0x05
    212e:	0f c0       	rjmp	.+30     	; 0x214e <green_read+0xda>
    2130:	80 e7       	ldi	r24, 0x70	; 112
    2132:	91 e0       	ldi	r25, 0x01	; 1
    2134:	9c 83       	std	Y+4, r25	; 0x04
    2136:	8b 83       	std	Y+3, r24	; 0x03
    2138:	8b 81       	ldd	r24, Y+3	; 0x03
    213a:	9c 81       	ldd	r25, Y+4	; 0x04
    213c:	01 97       	sbiw	r24, 0x01	; 1
    213e:	f1 f7       	brne	.-4      	; 0x213c <green_read+0xc8>
    2140:	9c 83       	std	Y+4, r25	; 0x04
    2142:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2144:	8d 81       	ldd	r24, Y+5	; 0x05
    2146:	9e 81       	ldd	r25, Y+6	; 0x06
    2148:	01 97       	sbiw	r24, 0x01	; 1
    214a:	9e 83       	std	Y+6, r25	; 0x06
    214c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    214e:	8d 81       	ldd	r24, Y+5	; 0x05
    2150:	9e 81       	ldd	r25, Y+6	; 0x06
    2152:	00 97       	sbiw	r24, 0x00	; 0
    2154:	69 f7       	brne	.-38     	; 0x2130 <green_read+0xbc>
    2156:	14 c0       	rjmp	.+40     	; 0x2180 <green_read+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2158:	6f 81       	ldd	r22, Y+7	; 0x07
    215a:	78 85       	ldd	r23, Y+8	; 0x08
    215c:	89 85       	ldd	r24, Y+9	; 0x09
    215e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2160:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2164:	dc 01       	movw	r26, r24
    2166:	cb 01       	movw	r24, r22
    2168:	9e 83       	std	Y+6, r25	; 0x06
    216a:	8d 83       	std	Y+5, r24	; 0x05
    216c:	8d 81       	ldd	r24, Y+5	; 0x05
    216e:	9e 81       	ldd	r25, Y+6	; 0x06
    2170:	9a 83       	std	Y+2, r25	; 0x02
    2172:	89 83       	std	Y+1, r24	; 0x01
    2174:	89 81       	ldd	r24, Y+1	; 0x01
    2176:	9a 81       	ldd	r25, Y+2	; 0x02
    2178:	01 97       	sbiw	r24, 0x01	; 1
    217a:	f1 f7       	brne	.-4      	; 0x2178 <green_read+0x104>
    217c:	9a 83       	std	Y+2, r25	; 0x02
    217e:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  green = pulse;  //store the count in variable called green
    2180:	80 91 22 03 	lds	r24, 0x0322
    2184:	90 91 23 03 	lds	r25, 0x0323
    2188:	a0 91 24 03 	lds	r26, 0x0324
    218c:	b0 91 25 03 	lds	r27, 0x0325
    2190:	80 93 3e 03 	sts	0x033E, r24
    2194:	90 93 3f 03 	sts	0x033F, r25
    2198:	a0 93 40 03 	sts	0x0340, r26
    219c:	b0 93 41 03 	sts	0x0341, r27
//  lcd_cursor(1,1);  //set the cursor on row 1, column 1
//  lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
//  lcd_print(2,1,green,5);  //Print the count on second row
//  _delay_ms(1000);  // Display for 1000ms or 1 second
//  lcd_wr_command(0x01); //Clear the LCD
}
    21a0:	2e 96       	adiw	r28, 0x0e	; 14
    21a2:	0f b6       	in	r0, 0x3f	; 63
    21a4:	f8 94       	cli
    21a6:	de bf       	out	0x3e, r29	; 62
    21a8:	0f be       	out	0x3f, r0	; 63
    21aa:	cd bf       	out	0x3d, r28	; 61
    21ac:	cf 91       	pop	r28
    21ae:	df 91       	pop	r29
    21b0:	08 95       	ret

000021b2 <blue_read>:

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
    21b2:	df 93       	push	r29
    21b4:	cf 93       	push	r28
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	2e 97       	sbiw	r28, 0x0e	; 14
    21bc:	0f b6       	in	r0, 0x3f	; 63
    21be:	f8 94       	cli
    21c0:	de bf       	out	0x3e, r29	; 62
    21c2:	0f be       	out	0x3f, r0	; 63
    21c4:	cd bf       	out	0x3d, r28	; 61
  //Blue
  filter_blue(); //select blue filter
    21c6:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <filter_blue>
  pulse=0; //reset the count to 0
    21ca:	10 92 22 03 	sts	0x0322, r1
    21ce:	10 92 23 03 	sts	0x0323, r1
    21d2:	10 92 24 03 	sts	0x0324, r1
    21d6:	10 92 25 03 	sts	0x0325, r1
    21da:	80 e0       	ldi	r24, 0x00	; 0
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	a8 ec       	ldi	r26, 0xC8	; 200
    21e0:	b2 e4       	ldi	r27, 0x42	; 66
    21e2:	8b 87       	std	Y+11, r24	; 0x0b
    21e4:	9c 87       	std	Y+12, r25	; 0x0c
    21e6:	ad 87       	std	Y+13, r26	; 0x0d
    21e8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21ea:	6b 85       	ldd	r22, Y+11	; 0x0b
    21ec:	7c 85       	ldd	r23, Y+12	; 0x0c
    21ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    21f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    21f2:	26 e6       	ldi	r18, 0x66	; 102
    21f4:	36 e6       	ldi	r19, 0x66	; 102
    21f6:	46 e6       	ldi	r20, 0x66	; 102
    21f8:	55 e4       	ldi	r21, 0x45	; 69
    21fa:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    21fe:	dc 01       	movw	r26, r24
    2200:	cb 01       	movw	r24, r22
    2202:	8f 83       	std	Y+7, r24	; 0x07
    2204:	98 87       	std	Y+8, r25	; 0x08
    2206:	a9 87       	std	Y+9, r26	; 0x09
    2208:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    220a:	6f 81       	ldd	r22, Y+7	; 0x07
    220c:	78 85       	ldd	r23, Y+8	; 0x08
    220e:	89 85       	ldd	r24, Y+9	; 0x09
    2210:	9a 85       	ldd	r25, Y+10	; 0x0a
    2212:	20 e0       	ldi	r18, 0x00	; 0
    2214:	30 e0       	ldi	r19, 0x00	; 0
    2216:	40 e8       	ldi	r20, 0x80	; 128
    2218:	5f e3       	ldi	r21, 0x3F	; 63
    221a:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    221e:	88 23       	and	r24, r24
    2220:	2c f4       	brge	.+10     	; 0x222c <__stack+0x2d>
		__ticks = 1;
    2222:	81 e0       	ldi	r24, 0x01	; 1
    2224:	90 e0       	ldi	r25, 0x00	; 0
    2226:	9e 83       	std	Y+6, r25	; 0x06
    2228:	8d 83       	std	Y+5, r24	; 0x05
    222a:	3f c0       	rjmp	.+126    	; 0x22aa <__stack+0xab>
	else if (__tmp > 65535)
    222c:	6f 81       	ldd	r22, Y+7	; 0x07
    222e:	78 85       	ldd	r23, Y+8	; 0x08
    2230:	89 85       	ldd	r24, Y+9	; 0x09
    2232:	9a 85       	ldd	r25, Y+10	; 0x0a
    2234:	20 e0       	ldi	r18, 0x00	; 0
    2236:	3f ef       	ldi	r19, 0xFF	; 255
    2238:	4f e7       	ldi	r20, 0x7F	; 127
    223a:	57 e4       	ldi	r21, 0x47	; 71
    223c:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2240:	18 16       	cp	r1, r24
    2242:	4c f5       	brge	.+82     	; 0x2296 <__stack+0x97>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2244:	6b 85       	ldd	r22, Y+11	; 0x0b
    2246:	7c 85       	ldd	r23, Y+12	; 0x0c
    2248:	8d 85       	ldd	r24, Y+13	; 0x0d
    224a:	9e 85       	ldd	r25, Y+14	; 0x0e
    224c:	20 e0       	ldi	r18, 0x00	; 0
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	40 e2       	ldi	r20, 0x20	; 32
    2252:	51 e4       	ldi	r21, 0x41	; 65
    2254:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2258:	dc 01       	movw	r26, r24
    225a:	cb 01       	movw	r24, r22
    225c:	bc 01       	movw	r22, r24
    225e:	cd 01       	movw	r24, r26
    2260:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2264:	dc 01       	movw	r26, r24
    2266:	cb 01       	movw	r24, r22
    2268:	9e 83       	std	Y+6, r25	; 0x06
    226a:	8d 83       	std	Y+5, r24	; 0x05
    226c:	0f c0       	rjmp	.+30     	; 0x228c <__stack+0x8d>
    226e:	80 e7       	ldi	r24, 0x70	; 112
    2270:	91 e0       	ldi	r25, 0x01	; 1
    2272:	9c 83       	std	Y+4, r25	; 0x04
    2274:	8b 83       	std	Y+3, r24	; 0x03
    2276:	8b 81       	ldd	r24, Y+3	; 0x03
    2278:	9c 81       	ldd	r25, Y+4	; 0x04
    227a:	01 97       	sbiw	r24, 0x01	; 1
    227c:	f1 f7       	brne	.-4      	; 0x227a <__stack+0x7b>
    227e:	9c 83       	std	Y+4, r25	; 0x04
    2280:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2282:	8d 81       	ldd	r24, Y+5	; 0x05
    2284:	9e 81       	ldd	r25, Y+6	; 0x06
    2286:	01 97       	sbiw	r24, 0x01	; 1
    2288:	9e 83       	std	Y+6, r25	; 0x06
    228a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    228c:	8d 81       	ldd	r24, Y+5	; 0x05
    228e:	9e 81       	ldd	r25, Y+6	; 0x06
    2290:	00 97       	sbiw	r24, 0x00	; 0
    2292:	69 f7       	brne	.-38     	; 0x226e <__stack+0x6f>
    2294:	14 c0       	rjmp	.+40     	; 0x22be <__stack+0xbf>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2296:	6f 81       	ldd	r22, Y+7	; 0x07
    2298:	78 85       	ldd	r23, Y+8	; 0x08
    229a:	89 85       	ldd	r24, Y+9	; 0x09
    229c:	9a 85       	ldd	r25, Y+10	; 0x0a
    229e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    22a2:	dc 01       	movw	r26, r24
    22a4:	cb 01       	movw	r24, r22
    22a6:	9e 83       	std	Y+6, r25	; 0x06
    22a8:	8d 83       	std	Y+5, r24	; 0x05
    22aa:	8d 81       	ldd	r24, Y+5	; 0x05
    22ac:	9e 81       	ldd	r25, Y+6	; 0x06
    22ae:	9a 83       	std	Y+2, r25	; 0x02
    22b0:	89 83       	std	Y+1, r24	; 0x01
    22b2:	89 81       	ldd	r24, Y+1	; 0x01
    22b4:	9a 81       	ldd	r25, Y+2	; 0x02
    22b6:	01 97       	sbiw	r24, 0x01	; 1
    22b8:	f1 f7       	brne	.-4      	; 0x22b6 <__stack+0xb7>
    22ba:	9a 83       	std	Y+2, r25	; 0x02
    22bc:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(100); //capture the pulses for 100 ms or 0.1 second
  blue = pulse;  //store the count in variable called blue
    22be:	80 91 22 03 	lds	r24, 0x0322
    22c2:	90 91 23 03 	lds	r25, 0x0323
    22c6:	a0 91 24 03 	lds	r26, 0x0324
    22ca:	b0 91 25 03 	lds	r27, 0x0325
    22ce:	80 93 34 03 	sts	0x0334, r24
    22d2:	90 93 35 03 	sts	0x0335, r25
    22d6:	a0 93 36 03 	sts	0x0336, r26
    22da:	b0 93 37 03 	sts	0x0337, r27
//  lcd_cursor(1,1);  //set the cursor on row 1, column 1
//  lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
//  lcd_print(2,1,blue,5);  //Print the count on second row
//  _delay_ms(1000);  // Display for 1000ms or 1 second
//  lcd_wr_command(0x01); //Clear the LCD
}
    22de:	2e 96       	adiw	r28, 0x0e	; 14
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	f8 94       	cli
    22e4:	de bf       	out	0x3e, r29	; 62
    22e6:	0f be       	out	0x3f, r0	; 63
    22e8:	cd bf       	out	0x3d, r28	; 61
    22ea:	cf 91       	pop	r28
    22ec:	df 91       	pop	r29
    22ee:	08 95       	ret

000022f0 <servo_1>:


//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)  
{
    22f0:	0f 93       	push	r16
    22f2:	1f 93       	push	r17
    22f4:	df 93       	push	r29
    22f6:	cf 93       	push	r28
    22f8:	00 d0       	rcall	.+0      	; 0x22fa <servo_1+0xa>
    22fa:	0f 92       	push	r0
    22fc:	0f 92       	push	r0
    22fe:	cd b7       	in	r28, 0x3d	; 61
    2300:	de b7       	in	r29, 0x3e	; 62
    2302:	8d 83       	std	Y+5, r24	; 0x05
 float PositionPanServo = 0;
    2304:	80 e0       	ldi	r24, 0x00	; 0
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	a0 e0       	ldi	r26, 0x00	; 0
    230a:	b0 e0       	ldi	r27, 0x00	; 0
    230c:	89 83       	std	Y+1, r24	; 0x01
    230e:	9a 83       	std	Y+2, r25	; 0x02
    2310:	ab 83       	std	Y+3, r26	; 0x03
    2312:	bc 83       	std	Y+4, r27	; 0x04
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
    2314:	8d 81       	ldd	r24, Y+5	; 0x05
    2316:	88 2f       	mov	r24, r24
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	a0 e0       	ldi	r26, 0x00	; 0
    231c:	b0 e0       	ldi	r27, 0x00	; 0
    231e:	bc 01       	movw	r22, r24
    2320:	cd 01       	movw	r24, r26
    2322:	0e 94 89 22 	call	0x4512	; 0x4512 <__floatunsisf>
    2326:	dc 01       	movw	r26, r24
    2328:	cb 01       	movw	r24, r22
    232a:	bc 01       	movw	r22, r24
    232c:	cd 01       	movw	r24, r26
    232e:	2b e7       	ldi	r18, 0x7B	; 123
    2330:	34 e1       	ldi	r19, 0x14	; 20
    2332:	4e ee       	ldi	r20, 0xEE	; 238
    2334:	5f e3       	ldi	r21, 0x3F	; 63
    2336:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__divsf3>
    233a:	dc 01       	movw	r26, r24
    233c:	cb 01       	movw	r24, r22
    233e:	bc 01       	movw	r22, r24
    2340:	cd 01       	movw	r24, r26
    2342:	20 e0       	ldi	r18, 0x00	; 0
    2344:	30 e0       	ldi	r19, 0x00	; 0
    2346:	4c e0       	ldi	r20, 0x0C	; 12
    2348:	52 e4       	ldi	r21, 0x42	; 66
    234a:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <__addsf3>
    234e:	dc 01       	movw	r26, r24
    2350:	cb 01       	movw	r24, r22
    2352:	89 83       	std	Y+1, r24	; 0x01
    2354:	9a 83       	std	Y+2, r25	; 0x02
    2356:	ab 83       	std	Y+3, r26	; 0x03
    2358:	bc 83       	std	Y+4, r27	; 0x04
 OCR1AH = 0x00;
    235a:	e9 e8       	ldi	r30, 0x89	; 137
    235c:	f0 e0       	ldi	r31, 0x00	; 0
    235e:	10 82       	st	Z, r1
 OCR1AL = (unsigned char) PositionPanServo;
    2360:	08 e8       	ldi	r16, 0x88	; 136
    2362:	10 e0       	ldi	r17, 0x00	; 0
    2364:	69 81       	ldd	r22, Y+1	; 0x01
    2366:	7a 81       	ldd	r23, Y+2	; 0x02
    2368:	8b 81       	ldd	r24, Y+3	; 0x03
    236a:	9c 81       	ldd	r25, Y+4	; 0x04
    236c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2370:	dc 01       	movw	r26, r24
    2372:	cb 01       	movw	r24, r22
    2374:	f8 01       	movw	r30, r16
    2376:	80 83       	st	Z, r24
}
    2378:	0f 90       	pop	r0
    237a:	0f 90       	pop	r0
    237c:	0f 90       	pop	r0
    237e:	0f 90       	pop	r0
    2380:	0f 90       	pop	r0
    2382:	cf 91       	pop	r28
    2384:	df 91       	pop	r29
    2386:	1f 91       	pop	r17
    2388:	0f 91       	pop	r16
    238a:	08 95       	ret

0000238c <servo_2>:


//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
    238c:	0f 93       	push	r16
    238e:	1f 93       	push	r17
    2390:	df 93       	push	r29
    2392:	cf 93       	push	r28
    2394:	00 d0       	rcall	.+0      	; 0x2396 <servo_2+0xa>
    2396:	0f 92       	push	r0
    2398:	0f 92       	push	r0
    239a:	cd b7       	in	r28, 0x3d	; 61
    239c:	de b7       	in	r29, 0x3e	; 62
    239e:	8d 83       	std	Y+5, r24	; 0x05
 float PositionTiltServo = 0;
    23a0:	80 e0       	ldi	r24, 0x00	; 0
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	a0 e0       	ldi	r26, 0x00	; 0
    23a6:	b0 e0       	ldi	r27, 0x00	; 0
    23a8:	89 83       	std	Y+1, r24	; 0x01
    23aa:	9a 83       	std	Y+2, r25	; 0x02
    23ac:	ab 83       	std	Y+3, r26	; 0x03
    23ae:	bc 83       	std	Y+4, r27	; 0x04
 PositionTiltServo = ((float)degrees / 1.86) + 35.0;
    23b0:	8d 81       	ldd	r24, Y+5	; 0x05
    23b2:	88 2f       	mov	r24, r24
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	a0 e0       	ldi	r26, 0x00	; 0
    23b8:	b0 e0       	ldi	r27, 0x00	; 0
    23ba:	bc 01       	movw	r22, r24
    23bc:	cd 01       	movw	r24, r26
    23be:	0e 94 89 22 	call	0x4512	; 0x4512 <__floatunsisf>
    23c2:	dc 01       	movw	r26, r24
    23c4:	cb 01       	movw	r24, r22
    23c6:	bc 01       	movw	r22, r24
    23c8:	cd 01       	movw	r24, r26
    23ca:	2b e7       	ldi	r18, 0x7B	; 123
    23cc:	34 e1       	ldi	r19, 0x14	; 20
    23ce:	4e ee       	ldi	r20, 0xEE	; 238
    23d0:	5f e3       	ldi	r21, 0x3F	; 63
    23d2:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__divsf3>
    23d6:	dc 01       	movw	r26, r24
    23d8:	cb 01       	movw	r24, r22
    23da:	bc 01       	movw	r22, r24
    23dc:	cd 01       	movw	r24, r26
    23de:	20 e0       	ldi	r18, 0x00	; 0
    23e0:	30 e0       	ldi	r19, 0x00	; 0
    23e2:	4c e0       	ldi	r20, 0x0C	; 12
    23e4:	52 e4       	ldi	r21, 0x42	; 66
    23e6:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <__addsf3>
    23ea:	dc 01       	movw	r26, r24
    23ec:	cb 01       	movw	r24, r22
    23ee:	89 83       	std	Y+1, r24	; 0x01
    23f0:	9a 83       	std	Y+2, r25	; 0x02
    23f2:	ab 83       	std	Y+3, r26	; 0x03
    23f4:	bc 83       	std	Y+4, r27	; 0x04
 OCR1BH = 0x00;
    23f6:	eb e8       	ldi	r30, 0x8B	; 139
    23f8:	f0 e0       	ldi	r31, 0x00	; 0
    23fa:	10 82       	st	Z, r1
 OCR1BL = (unsigned char) PositionTiltServo;
    23fc:	0a e8       	ldi	r16, 0x8A	; 138
    23fe:	10 e0       	ldi	r17, 0x00	; 0
    2400:	69 81       	ldd	r22, Y+1	; 0x01
    2402:	7a 81       	ldd	r23, Y+2	; 0x02
    2404:	8b 81       	ldd	r24, Y+3	; 0x03
    2406:	9c 81       	ldd	r25, Y+4	; 0x04
    2408:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    240c:	dc 01       	movw	r26, r24
    240e:	cb 01       	movw	r24, r22
    2410:	f8 01       	movw	r30, r16
    2412:	80 83       	st	Z, r24
}
    2414:	0f 90       	pop	r0
    2416:	0f 90       	pop	r0
    2418:	0f 90       	pop	r0
    241a:	0f 90       	pop	r0
    241c:	0f 90       	pop	r0
    241e:	cf 91       	pop	r28
    2420:	df 91       	pop	r29
    2422:	1f 91       	pop	r17
    2424:	0f 91       	pop	r16
    2426:	08 95       	ret

00002428 <servo_3>:

//Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
void servo_3(unsigned char degrees)
{
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	df 93       	push	r29
    242e:	cf 93       	push	r28
    2430:	00 d0       	rcall	.+0      	; 0x2432 <servo_3+0xa>
    2432:	0f 92       	push	r0
    2434:	0f 92       	push	r0
    2436:	cd b7       	in	r28, 0x3d	; 61
    2438:	de b7       	in	r29, 0x3e	; 62
    243a:	8d 83       	std	Y+5, r24	; 0x05
 float PositionServo = 0;
    243c:	80 e0       	ldi	r24, 0x00	; 0
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	a0 e0       	ldi	r26, 0x00	; 0
    2442:	b0 e0       	ldi	r27, 0x00	; 0
    2444:	89 83       	std	Y+1, r24	; 0x01
    2446:	9a 83       	std	Y+2, r25	; 0x02
    2448:	ab 83       	std	Y+3, r26	; 0x03
    244a:	bc 83       	std	Y+4, r27	; 0x04
 PositionServo = ((float)degrees / 1.86) + 35.0;
    244c:	8d 81       	ldd	r24, Y+5	; 0x05
    244e:	88 2f       	mov	r24, r24
    2450:	90 e0       	ldi	r25, 0x00	; 0
    2452:	a0 e0       	ldi	r26, 0x00	; 0
    2454:	b0 e0       	ldi	r27, 0x00	; 0
    2456:	bc 01       	movw	r22, r24
    2458:	cd 01       	movw	r24, r26
    245a:	0e 94 89 22 	call	0x4512	; 0x4512 <__floatunsisf>
    245e:	dc 01       	movw	r26, r24
    2460:	cb 01       	movw	r24, r22
    2462:	bc 01       	movw	r22, r24
    2464:	cd 01       	movw	r24, r26
    2466:	2b e7       	ldi	r18, 0x7B	; 123
    2468:	34 e1       	ldi	r19, 0x14	; 20
    246a:	4e ee       	ldi	r20, 0xEE	; 238
    246c:	5f e3       	ldi	r21, 0x3F	; 63
    246e:	0e 94 f9 20 	call	0x41f2	; 0x41f2 <__divsf3>
    2472:	dc 01       	movw	r26, r24
    2474:	cb 01       	movw	r24, r22
    2476:	bc 01       	movw	r22, r24
    2478:	cd 01       	movw	r24, r26
    247a:	20 e0       	ldi	r18, 0x00	; 0
    247c:	30 e0       	ldi	r19, 0x00	; 0
    247e:	4c e0       	ldi	r20, 0x0C	; 12
    2480:	52 e4       	ldi	r21, 0x42	; 66
    2482:	0e 94 d2 1f 	call	0x3fa4	; 0x3fa4 <__addsf3>
    2486:	dc 01       	movw	r26, r24
    2488:	cb 01       	movw	r24, r22
    248a:	89 83       	std	Y+1, r24	; 0x01
    248c:	9a 83       	std	Y+2, r25	; 0x02
    248e:	ab 83       	std	Y+3, r26	; 0x03
    2490:	bc 83       	std	Y+4, r27	; 0x04
 OCR1CH = 0x00;
    2492:	ed e8       	ldi	r30, 0x8D	; 141
    2494:	f0 e0       	ldi	r31, 0x00	; 0
    2496:	10 82       	st	Z, r1
 OCR1CL = (unsigned char) PositionServo;
    2498:	0c e8       	ldi	r16, 0x8C	; 140
    249a:	10 e0       	ldi	r17, 0x00	; 0
    249c:	69 81       	ldd	r22, Y+1	; 0x01
    249e:	7a 81       	ldd	r23, Y+2	; 0x02
    24a0:	8b 81       	ldd	r24, Y+3	; 0x03
    24a2:	9c 81       	ldd	r25, Y+4	; 0x04
    24a4:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    24a8:	dc 01       	movw	r26, r24
    24aa:	cb 01       	movw	r24, r22
    24ac:	f8 01       	movw	r30, r16
    24ae:	80 83       	st	Z, r24
}
    24b0:	0f 90       	pop	r0
    24b2:	0f 90       	pop	r0
    24b4:	0f 90       	pop	r0
    24b6:	0f 90       	pop	r0
    24b8:	0f 90       	pop	r0
    24ba:	cf 91       	pop	r28
    24bc:	df 91       	pop	r29
    24be:	1f 91       	pop	r17
    24c0:	0f 91       	pop	r16
    24c2:	08 95       	ret

000024c4 <servo_1_free>:
//servo_free functions unlocks the servo motors from the any angle 
//and make them free by giving 100% duty cycle at the PWM. This function can be used to 
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
    24c4:	df 93       	push	r29
    24c6:	cf 93       	push	r28
    24c8:	cd b7       	in	r28, 0x3d	; 61
    24ca:	de b7       	in	r29, 0x3e	; 62
 OCR1AH = 0x03; 
    24cc:	e9 e8       	ldi	r30, 0x89	; 137
    24ce:	f0 e0       	ldi	r31, 0x00	; 0
    24d0:	83 e0       	ldi	r24, 0x03	; 3
    24d2:	80 83       	st	Z, r24
 OCR1AL = 0xFF; //Servo 1 off
    24d4:	e8 e8       	ldi	r30, 0x88	; 136
    24d6:	f0 e0       	ldi	r31, 0x00	; 0
    24d8:	8f ef       	ldi	r24, 0xFF	; 255
    24da:	80 83       	st	Z, r24
}
    24dc:	cf 91       	pop	r28
    24de:	df 91       	pop	r29
    24e0:	08 95       	ret

000024e2 <servo_2_free>:

void servo_2_free (void) //makes servo 2 free rotating
{
    24e2:	df 93       	push	r29
    24e4:	cf 93       	push	r28
    24e6:	cd b7       	in	r28, 0x3d	; 61
    24e8:	de b7       	in	r29, 0x3e	; 62
 OCR1BH = 0x03;
    24ea:	eb e8       	ldi	r30, 0x8B	; 139
    24ec:	f0 e0       	ldi	r31, 0x00	; 0
    24ee:	83 e0       	ldi	r24, 0x03	; 3
    24f0:	80 83       	st	Z, r24
 OCR1BL = 0xFF; //Servo 2 off
    24f2:	ea e8       	ldi	r30, 0x8A	; 138
    24f4:	f0 e0       	ldi	r31, 0x00	; 0
    24f6:	8f ef       	ldi	r24, 0xFF	; 255
    24f8:	80 83       	st	Z, r24
}
    24fa:	cf 91       	pop	r28
    24fc:	df 91       	pop	r29
    24fe:	08 95       	ret

00002500 <servo_3_free>:

void servo_3_free (void) //makes servo 3 free rotating
{
    2500:	df 93       	push	r29
    2502:	cf 93       	push	r28
    2504:	cd b7       	in	r28, 0x3d	; 61
    2506:	de b7       	in	r29, 0x3e	; 62
 OCR1CH = 0x03;
    2508:	ed e8       	ldi	r30, 0x8D	; 141
    250a:	f0 e0       	ldi	r31, 0x00	; 0
    250c:	83 e0       	ldi	r24, 0x03	; 3
    250e:	80 83       	st	Z, r24
 OCR1CL = 0xFF; //Servo 3 off
    2510:	ec e8       	ldi	r30, 0x8C	; 140
    2512:	f0 e0       	ldi	r31, 0x00	; 0
    2514:	8f ef       	ldi	r24, 0xFF	; 255
    2516:	80 83       	st	Z, r24
} 
    2518:	cf 91       	pop	r28
    251a:	df 91       	pop	r29
    251c:	08 95       	ret

0000251e <check_color>:



Color check_color(void)
{
    251e:	0f 93       	push	r16
    2520:	1f 93       	push	r17
    2522:	df 93       	push	r29
    2524:	cf 93       	push	r28
    2526:	cd b7       	in	r28, 0x3d	; 61
    2528:	de b7       	in	r29, 0x3e	; 62
    252a:	c8 54       	subi	r28, 0x48	; 72
    252c:	d0 40       	sbci	r29, 0x00	; 0
    252e:	0f b6       	in	r0, 0x3f	; 63
    2530:	f8 94       	cli
    2532:	de bf       	out	0x3e, r29	; 62
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	cd bf       	out	0x3d, r28	; 61
    2538:	fe 01       	movw	r30, r28
    253a:	ed 5b       	subi	r30, 0xBD	; 189
    253c:	ff 4f       	sbci	r31, 0xFF	; 255
    253e:	80 e0       	ldi	r24, 0x00	; 0
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	aa e7       	ldi	r26, 0x7A	; 122
    2544:	b4 e4       	ldi	r27, 0x44	; 68
    2546:	80 83       	st	Z, r24
    2548:	91 83       	std	Z+1, r25	; 0x01
    254a:	a2 83       	std	Z+2, r26	; 0x02
    254c:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    254e:	8e 01       	movw	r16, r28
    2550:	01 5c       	subi	r16, 0xC1	; 193
    2552:	1f 4f       	sbci	r17, 0xFF	; 255
    2554:	fe 01       	movw	r30, r28
    2556:	ed 5b       	subi	r30, 0xBD	; 189
    2558:	ff 4f       	sbci	r31, 0xFF	; 255
    255a:	60 81       	ld	r22, Z
    255c:	71 81       	ldd	r23, Z+1	; 0x01
    255e:	82 81       	ldd	r24, Z+2	; 0x02
    2560:	93 81       	ldd	r25, Z+3	; 0x03
    2562:	26 e6       	ldi	r18, 0x66	; 102
    2564:	36 e6       	ldi	r19, 0x66	; 102
    2566:	46 e6       	ldi	r20, 0x66	; 102
    2568:	55 e4       	ldi	r21, 0x45	; 69
    256a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    256e:	dc 01       	movw	r26, r24
    2570:	cb 01       	movw	r24, r22
    2572:	f8 01       	movw	r30, r16
    2574:	80 83       	st	Z, r24
    2576:	91 83       	std	Z+1, r25	; 0x01
    2578:	a2 83       	std	Z+2, r26	; 0x02
    257a:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    257c:	fe 01       	movw	r30, r28
    257e:	ff 96       	adiw	r30, 0x3f	; 63
    2580:	60 81       	ld	r22, Z
    2582:	71 81       	ldd	r23, Z+1	; 0x01
    2584:	82 81       	ldd	r24, Z+2	; 0x02
    2586:	93 81       	ldd	r25, Z+3	; 0x03
    2588:	20 e0       	ldi	r18, 0x00	; 0
    258a:	30 e0       	ldi	r19, 0x00	; 0
    258c:	40 e8       	ldi	r20, 0x80	; 128
    258e:	5f e3       	ldi	r21, 0x3F	; 63
    2590:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2594:	88 23       	and	r24, r24
    2596:	2c f4       	brge	.+10     	; 0x25a2 <check_color+0x84>
		__ticks = 1;
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	9e af       	std	Y+62, r25	; 0x3e
    259e:	8d af       	std	Y+61, r24	; 0x3d
    25a0:	46 c0       	rjmp	.+140    	; 0x262e <check_color+0x110>
	else if (__tmp > 65535)
    25a2:	fe 01       	movw	r30, r28
    25a4:	ff 96       	adiw	r30, 0x3f	; 63
    25a6:	60 81       	ld	r22, Z
    25a8:	71 81       	ldd	r23, Z+1	; 0x01
    25aa:	82 81       	ldd	r24, Z+2	; 0x02
    25ac:	93 81       	ldd	r25, Z+3	; 0x03
    25ae:	20 e0       	ldi	r18, 0x00	; 0
    25b0:	3f ef       	ldi	r19, 0xFF	; 255
    25b2:	4f e7       	ldi	r20, 0x7F	; 127
    25b4:	57 e4       	ldi	r21, 0x47	; 71
    25b6:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    25ba:	18 16       	cp	r1, r24
    25bc:	64 f5       	brge	.+88     	; 0x2616 <check_color+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25be:	fe 01       	movw	r30, r28
    25c0:	ed 5b       	subi	r30, 0xBD	; 189
    25c2:	ff 4f       	sbci	r31, 0xFF	; 255
    25c4:	60 81       	ld	r22, Z
    25c6:	71 81       	ldd	r23, Z+1	; 0x01
    25c8:	82 81       	ldd	r24, Z+2	; 0x02
    25ca:	93 81       	ldd	r25, Z+3	; 0x03
    25cc:	20 e0       	ldi	r18, 0x00	; 0
    25ce:	30 e0       	ldi	r19, 0x00	; 0
    25d0:	40 e2       	ldi	r20, 0x20	; 32
    25d2:	51 e4       	ldi	r21, 0x41	; 65
    25d4:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    25d8:	dc 01       	movw	r26, r24
    25da:	cb 01       	movw	r24, r22
    25dc:	bc 01       	movw	r22, r24
    25de:	cd 01       	movw	r24, r26
    25e0:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    25e4:	dc 01       	movw	r26, r24
    25e6:	cb 01       	movw	r24, r22
    25e8:	9e af       	std	Y+62, r25	; 0x3e
    25ea:	8d af       	std	Y+61, r24	; 0x3d
    25ec:	0f c0       	rjmp	.+30     	; 0x260c <check_color+0xee>
    25ee:	80 e7       	ldi	r24, 0x70	; 112
    25f0:	91 e0       	ldi	r25, 0x01	; 1
    25f2:	9c af       	std	Y+60, r25	; 0x3c
    25f4:	8b af       	std	Y+59, r24	; 0x3b
    25f6:	8b ad       	ldd	r24, Y+59	; 0x3b
    25f8:	9c ad       	ldd	r25, Y+60	; 0x3c
    25fa:	01 97       	sbiw	r24, 0x01	; 1
    25fc:	f1 f7       	brne	.-4      	; 0x25fa <check_color+0xdc>
    25fe:	9c af       	std	Y+60, r25	; 0x3c
    2600:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2602:	8d ad       	ldd	r24, Y+61	; 0x3d
    2604:	9e ad       	ldd	r25, Y+62	; 0x3e
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	9e af       	std	Y+62, r25	; 0x3e
    260a:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    260c:	8d ad       	ldd	r24, Y+61	; 0x3d
    260e:	9e ad       	ldd	r25, Y+62	; 0x3e
    2610:	00 97       	sbiw	r24, 0x00	; 0
    2612:	69 f7       	brne	.-38     	; 0x25ee <check_color+0xd0>
    2614:	16 c0       	rjmp	.+44     	; 0x2642 <check_color+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2616:	fe 01       	movw	r30, r28
    2618:	ff 96       	adiw	r30, 0x3f	; 63
    261a:	60 81       	ld	r22, Z
    261c:	71 81       	ldd	r23, Z+1	; 0x01
    261e:	82 81       	ldd	r24, Z+2	; 0x02
    2620:	93 81       	ldd	r25, Z+3	; 0x03
    2622:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2626:	dc 01       	movw	r26, r24
    2628:	cb 01       	movw	r24, r22
    262a:	9e af       	std	Y+62, r25	; 0x3e
    262c:	8d af       	std	Y+61, r24	; 0x3d
    262e:	8d ad       	ldd	r24, Y+61	; 0x3d
    2630:	9e ad       	ldd	r25, Y+62	; 0x3e
    2632:	9a af       	std	Y+58, r25	; 0x3a
    2634:	89 af       	std	Y+57, r24	; 0x39
    2636:	89 ad       	ldd	r24, Y+57	; 0x39
    2638:	9a ad       	ldd	r25, Y+58	; 0x3a
    263a:	01 97       	sbiw	r24, 0x01	; 1
    263c:	f1 f7       	brne	.-4      	; 0x263a <check_color+0x11c>
    263e:	9a af       	std	Y+58, r25	; 0x3a
    2640:	89 af       	std	Y+57, r24	; 0x39
  
    _delay_ms(1000);  

    red_read();   //display the pulse count when red filter is selected
    2642:	0e 94 9b 0f 	call	0x1f36	; 0x1f36 <red_read>
    
    green_read();   //display the pulse count when green filter is selected
    2646:	0e 94 3a 10 	call	0x2074	; 0x2074 <green_read>
    
    blue_read();  //display the pulse count when blue filter is selected
    264a:	0e 94 d9 10 	call	0x21b2	; 0x21b2 <blue_read>
     
     
     
     if((red>green) && (red>blue) && (red>2500))
    264e:	20 91 42 03 	lds	r18, 0x0342
    2652:	30 91 43 03 	lds	r19, 0x0343
    2656:	40 91 44 03 	lds	r20, 0x0344
    265a:	50 91 45 03 	lds	r21, 0x0345
    265e:	80 91 3e 03 	lds	r24, 0x033E
    2662:	90 91 3f 03 	lds	r25, 0x033F
    2666:	a0 91 40 03 	lds	r26, 0x0340
    266a:	b0 91 41 03 	lds	r27, 0x0341
    266e:	82 17       	cp	r24, r18
    2670:	93 07       	cpc	r25, r19
    2672:	a4 07       	cpc	r26, r20
    2674:	b5 07       	cpc	r27, r21
    2676:	08 f0       	brcs	.+2      	; 0x267a <check_color+0x15c>
    2678:	a8 c0       	rjmp	.+336    	; 0x27ca <check_color+0x2ac>
    267a:	20 91 42 03 	lds	r18, 0x0342
    267e:	30 91 43 03 	lds	r19, 0x0343
    2682:	40 91 44 03 	lds	r20, 0x0344
    2686:	50 91 45 03 	lds	r21, 0x0345
    268a:	80 91 34 03 	lds	r24, 0x0334
    268e:	90 91 35 03 	lds	r25, 0x0335
    2692:	a0 91 36 03 	lds	r26, 0x0336
    2696:	b0 91 37 03 	lds	r27, 0x0337
    269a:	82 17       	cp	r24, r18
    269c:	93 07       	cpc	r25, r19
    269e:	a4 07       	cpc	r26, r20
    26a0:	b5 07       	cpc	r27, r21
    26a2:	08 f0       	brcs	.+2      	; 0x26a6 <check_color+0x188>
    26a4:	92 c0       	rjmp	.+292    	; 0x27ca <check_color+0x2ac>
    26a6:	80 91 42 03 	lds	r24, 0x0342
    26aa:	90 91 43 03 	lds	r25, 0x0343
    26ae:	a0 91 44 03 	lds	r26, 0x0344
    26b2:	b0 91 45 03 	lds	r27, 0x0345
    26b6:	85 3c       	cpi	r24, 0xC5	; 197
    26b8:	f9 e0       	ldi	r31, 0x09	; 9
    26ba:	9f 07       	cpc	r25, r31
    26bc:	f0 e0       	ldi	r31, 0x00	; 0
    26be:	af 07       	cpc	r26, r31
    26c0:	f0 e0       	ldi	r31, 0x00	; 0
    26c2:	bf 07       	cpc	r27, r31
    26c4:	08 f4       	brcc	.+2      	; 0x26c8 <check_color+0x1aa>
    26c6:	81 c0       	rjmp	.+258    	; 0x27ca <check_color+0x2ac>
     {
        
      lcd_cursor(1,1);      //set the cursor on row 1, column 1
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	61 e0       	ldi	r22, 0x01	; 1
    26cc:	0e 94 05 09 	call	0x120a	; 0x120a <lcd_cursor>
      lcd_string("Red"); 
    26d0:	82 e0       	ldi	r24, 0x02	; 2
    26d2:	92 e0       	ldi	r25, 0x02	; 2
    26d4:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
    26d8:	80 e0       	ldi	r24, 0x00	; 0
    26da:	90 e0       	ldi	r25, 0x00	; 0
    26dc:	aa e7       	ldi	r26, 0x7A	; 122
    26de:	b4 e4       	ldi	r27, 0x44	; 68
    26e0:	8d ab       	std	Y+53, r24	; 0x35
    26e2:	9e ab       	std	Y+54, r25	; 0x36
    26e4:	af ab       	std	Y+55, r26	; 0x37
    26e6:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    26e8:	6d a9       	ldd	r22, Y+53	; 0x35
    26ea:	7e a9       	ldd	r23, Y+54	; 0x36
    26ec:	8f a9       	ldd	r24, Y+55	; 0x37
    26ee:	98 ad       	ldd	r25, Y+56	; 0x38
    26f0:	26 e6       	ldi	r18, 0x66	; 102
    26f2:	36 e6       	ldi	r19, 0x66	; 102
    26f4:	46 e6       	ldi	r20, 0x66	; 102
    26f6:	55 e4       	ldi	r21, 0x45	; 69
    26f8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    26fc:	dc 01       	movw	r26, r24
    26fe:	cb 01       	movw	r24, r22
    2700:	89 ab       	std	Y+49, r24	; 0x31
    2702:	9a ab       	std	Y+50, r25	; 0x32
    2704:	ab ab       	std	Y+51, r26	; 0x33
    2706:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2708:	69 a9       	ldd	r22, Y+49	; 0x31
    270a:	7a a9       	ldd	r23, Y+50	; 0x32
    270c:	8b a9       	ldd	r24, Y+51	; 0x33
    270e:	9c a9       	ldd	r25, Y+52	; 0x34
    2710:	20 e0       	ldi	r18, 0x00	; 0
    2712:	30 e0       	ldi	r19, 0x00	; 0
    2714:	40 e8       	ldi	r20, 0x80	; 128
    2716:	5f e3       	ldi	r21, 0x3F	; 63
    2718:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    271c:	88 23       	and	r24, r24
    271e:	2c f4       	brge	.+10     	; 0x272a <check_color+0x20c>
		__ticks = 1;
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	90 e0       	ldi	r25, 0x00	; 0
    2724:	98 ab       	std	Y+48, r25	; 0x30
    2726:	8f a7       	std	Y+47, r24	; 0x2f
    2728:	3f c0       	rjmp	.+126    	; 0x27a8 <check_color+0x28a>
	else if (__tmp > 65535)
    272a:	69 a9       	ldd	r22, Y+49	; 0x31
    272c:	7a a9       	ldd	r23, Y+50	; 0x32
    272e:	8b a9       	ldd	r24, Y+51	; 0x33
    2730:	9c a9       	ldd	r25, Y+52	; 0x34
    2732:	20 e0       	ldi	r18, 0x00	; 0
    2734:	3f ef       	ldi	r19, 0xFF	; 255
    2736:	4f e7       	ldi	r20, 0x7F	; 127
    2738:	57 e4       	ldi	r21, 0x47	; 71
    273a:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    273e:	18 16       	cp	r1, r24
    2740:	4c f5       	brge	.+82     	; 0x2794 <check_color+0x276>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2742:	6d a9       	ldd	r22, Y+53	; 0x35
    2744:	7e a9       	ldd	r23, Y+54	; 0x36
    2746:	8f a9       	ldd	r24, Y+55	; 0x37
    2748:	98 ad       	ldd	r25, Y+56	; 0x38
    274a:	20 e0       	ldi	r18, 0x00	; 0
    274c:	30 e0       	ldi	r19, 0x00	; 0
    274e:	40 e2       	ldi	r20, 0x20	; 32
    2750:	51 e4       	ldi	r21, 0x41	; 65
    2752:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2756:	dc 01       	movw	r26, r24
    2758:	cb 01       	movw	r24, r22
    275a:	bc 01       	movw	r22, r24
    275c:	cd 01       	movw	r24, r26
    275e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2762:	dc 01       	movw	r26, r24
    2764:	cb 01       	movw	r24, r22
    2766:	98 ab       	std	Y+48, r25	; 0x30
    2768:	8f a7       	std	Y+47, r24	; 0x2f
    276a:	0f c0       	rjmp	.+30     	; 0x278a <check_color+0x26c>
    276c:	80 e7       	ldi	r24, 0x70	; 112
    276e:	91 e0       	ldi	r25, 0x01	; 1
    2770:	9e a7       	std	Y+46, r25	; 0x2e
    2772:	8d a7       	std	Y+45, r24	; 0x2d
    2774:	8d a5       	ldd	r24, Y+45	; 0x2d
    2776:	9e a5       	ldd	r25, Y+46	; 0x2e
    2778:	01 97       	sbiw	r24, 0x01	; 1
    277a:	f1 f7       	brne	.-4      	; 0x2778 <check_color+0x25a>
    277c:	9e a7       	std	Y+46, r25	; 0x2e
    277e:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2780:	8f a5       	ldd	r24, Y+47	; 0x2f
    2782:	98 a9       	ldd	r25, Y+48	; 0x30
    2784:	01 97       	sbiw	r24, 0x01	; 1
    2786:	98 ab       	std	Y+48, r25	; 0x30
    2788:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    278a:	8f a5       	ldd	r24, Y+47	; 0x2f
    278c:	98 a9       	ldd	r25, Y+48	; 0x30
    278e:	00 97       	sbiw	r24, 0x00	; 0
    2790:	69 f7       	brne	.-38     	; 0x276c <check_color+0x24e>
    2792:	14 c0       	rjmp	.+40     	; 0x27bc <check_color+0x29e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2794:	69 a9       	ldd	r22, Y+49	; 0x31
    2796:	7a a9       	ldd	r23, Y+50	; 0x32
    2798:	8b a9       	ldd	r24, Y+51	; 0x33
    279a:	9c a9       	ldd	r25, Y+52	; 0x34
    279c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    27a0:	dc 01       	movw	r26, r24
    27a2:	cb 01       	movw	r24, r22
    27a4:	98 ab       	std	Y+48, r25	; 0x30
    27a6:	8f a7       	std	Y+47, r24	; 0x2f
    27a8:	8f a5       	ldd	r24, Y+47	; 0x2f
    27aa:	98 a9       	ldd	r25, Y+48	; 0x30
    27ac:	9c a7       	std	Y+44, r25	; 0x2c
    27ae:	8b a7       	std	Y+43, r24	; 0x2b
    27b0:	8b a5       	ldd	r24, Y+43	; 0x2b
    27b2:	9c a5       	ldd	r25, Y+44	; 0x2c
    27b4:	01 97       	sbiw	r24, 0x01	; 1
    27b6:	f1 f7       	brne	.-4      	; 0x27b4 <check_color+0x296>
    27b8:	9c a7       	std	Y+44, r25	; 0x2c
    27ba:	8b a7       	std	Y+43, r24	; 0x2b
      _delay_ms(1000);    // Display for 1000ms or 1 second
      lcd_wr_command(0x01);   //Clear the LCD
    27bc:	81 e0       	ldi	r24, 0x01	; 1
    27be:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
      return Red;
    27c2:	28 96       	adiw	r28, 0x08	; 8
    27c4:	1f ae       	std	Y+63, r1	; 0x3f
    27c6:	28 97       	sbiw	r28, 0x08	; 8
    27c8:	67 c2       	rjmp	.+1230   	; 0x2c98 <check_color+0x77a>
     
     }
     
     if((blue>green) && (blue>red) && (blue>3000))
    27ca:	20 91 34 03 	lds	r18, 0x0334
    27ce:	30 91 35 03 	lds	r19, 0x0335
    27d2:	40 91 36 03 	lds	r20, 0x0336
    27d6:	50 91 37 03 	lds	r21, 0x0337
    27da:	80 91 3e 03 	lds	r24, 0x033E
    27de:	90 91 3f 03 	lds	r25, 0x033F
    27e2:	a0 91 40 03 	lds	r26, 0x0340
    27e6:	b0 91 41 03 	lds	r27, 0x0341
    27ea:	82 17       	cp	r24, r18
    27ec:	93 07       	cpc	r25, r19
    27ee:	a4 07       	cpc	r26, r20
    27f0:	b5 07       	cpc	r27, r21
    27f2:	08 f0       	brcs	.+2      	; 0x27f6 <check_color+0x2d8>
    27f4:	a9 c0       	rjmp	.+338    	; 0x2948 <check_color+0x42a>
    27f6:	20 91 34 03 	lds	r18, 0x0334
    27fa:	30 91 35 03 	lds	r19, 0x0335
    27fe:	40 91 36 03 	lds	r20, 0x0336
    2802:	50 91 37 03 	lds	r21, 0x0337
    2806:	80 91 42 03 	lds	r24, 0x0342
    280a:	90 91 43 03 	lds	r25, 0x0343
    280e:	a0 91 44 03 	lds	r26, 0x0344
    2812:	b0 91 45 03 	lds	r27, 0x0345
    2816:	82 17       	cp	r24, r18
    2818:	93 07       	cpc	r25, r19
    281a:	a4 07       	cpc	r26, r20
    281c:	b5 07       	cpc	r27, r21
    281e:	08 f0       	brcs	.+2      	; 0x2822 <check_color+0x304>
    2820:	93 c0       	rjmp	.+294    	; 0x2948 <check_color+0x42a>
    2822:	80 91 34 03 	lds	r24, 0x0334
    2826:	90 91 35 03 	lds	r25, 0x0335
    282a:	a0 91 36 03 	lds	r26, 0x0336
    282e:	b0 91 37 03 	lds	r27, 0x0337
    2832:	89 3b       	cpi	r24, 0xB9	; 185
    2834:	2b e0       	ldi	r18, 0x0B	; 11
    2836:	92 07       	cpc	r25, r18
    2838:	20 e0       	ldi	r18, 0x00	; 0
    283a:	a2 07       	cpc	r26, r18
    283c:	20 e0       	ldi	r18, 0x00	; 0
    283e:	b2 07       	cpc	r27, r18
    2840:	08 f4       	brcc	.+2      	; 0x2844 <check_color+0x326>
    2842:	82 c0       	rjmp	.+260    	; 0x2948 <check_color+0x42a>
     {
        
      lcd_cursor(1,1);      //set the cursor on row 1, column 1
    2844:	81 e0       	ldi	r24, 0x01	; 1
    2846:	61 e0       	ldi	r22, 0x01	; 1
    2848:	0e 94 05 09 	call	0x120a	; 0x120a <lcd_cursor>
      lcd_string("Blue"); 
    284c:	86 e0       	ldi	r24, 0x06	; 6
    284e:	92 e0       	ldi	r25, 0x02	; 2
    2850:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
    2854:	80 e0       	ldi	r24, 0x00	; 0
    2856:	90 e0       	ldi	r25, 0x00	; 0
    2858:	aa e7       	ldi	r26, 0x7A	; 122
    285a:	b4 e4       	ldi	r27, 0x44	; 68
    285c:	8f a3       	std	Y+39, r24	; 0x27
    285e:	98 a7       	std	Y+40, r25	; 0x28
    2860:	a9 a7       	std	Y+41, r26	; 0x29
    2862:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2864:	6f a1       	ldd	r22, Y+39	; 0x27
    2866:	78 a5       	ldd	r23, Y+40	; 0x28
    2868:	89 a5       	ldd	r24, Y+41	; 0x29
    286a:	9a a5       	ldd	r25, Y+42	; 0x2a
    286c:	26 e6       	ldi	r18, 0x66	; 102
    286e:	36 e6       	ldi	r19, 0x66	; 102
    2870:	46 e6       	ldi	r20, 0x66	; 102
    2872:	55 e4       	ldi	r21, 0x45	; 69
    2874:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2878:	dc 01       	movw	r26, r24
    287a:	cb 01       	movw	r24, r22
    287c:	8b a3       	std	Y+35, r24	; 0x23
    287e:	9c a3       	std	Y+36, r25	; 0x24
    2880:	ad a3       	std	Y+37, r26	; 0x25
    2882:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2884:	6b a1       	ldd	r22, Y+35	; 0x23
    2886:	7c a1       	ldd	r23, Y+36	; 0x24
    2888:	8d a1       	ldd	r24, Y+37	; 0x25
    288a:	9e a1       	ldd	r25, Y+38	; 0x26
    288c:	20 e0       	ldi	r18, 0x00	; 0
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	40 e8       	ldi	r20, 0x80	; 128
    2892:	5f e3       	ldi	r21, 0x3F	; 63
    2894:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2898:	88 23       	and	r24, r24
    289a:	2c f4       	brge	.+10     	; 0x28a6 <check_color+0x388>
		__ticks = 1;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	9a a3       	std	Y+34, r25	; 0x22
    28a2:	89 a3       	std	Y+33, r24	; 0x21
    28a4:	3f c0       	rjmp	.+126    	; 0x2924 <check_color+0x406>
	else if (__tmp > 65535)
    28a6:	6b a1       	ldd	r22, Y+35	; 0x23
    28a8:	7c a1       	ldd	r23, Y+36	; 0x24
    28aa:	8d a1       	ldd	r24, Y+37	; 0x25
    28ac:	9e a1       	ldd	r25, Y+38	; 0x26
    28ae:	20 e0       	ldi	r18, 0x00	; 0
    28b0:	3f ef       	ldi	r19, 0xFF	; 255
    28b2:	4f e7       	ldi	r20, 0x7F	; 127
    28b4:	57 e4       	ldi	r21, 0x47	; 71
    28b6:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    28ba:	18 16       	cp	r1, r24
    28bc:	4c f5       	brge	.+82     	; 0x2910 <check_color+0x3f2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    28be:	6f a1       	ldd	r22, Y+39	; 0x27
    28c0:	78 a5       	ldd	r23, Y+40	; 0x28
    28c2:	89 a5       	ldd	r24, Y+41	; 0x29
    28c4:	9a a5       	ldd	r25, Y+42	; 0x2a
    28c6:	20 e0       	ldi	r18, 0x00	; 0
    28c8:	30 e0       	ldi	r19, 0x00	; 0
    28ca:	40 e2       	ldi	r20, 0x20	; 32
    28cc:	51 e4       	ldi	r21, 0x41	; 65
    28ce:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    28d2:	dc 01       	movw	r26, r24
    28d4:	cb 01       	movw	r24, r22
    28d6:	bc 01       	movw	r22, r24
    28d8:	cd 01       	movw	r24, r26
    28da:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    28de:	dc 01       	movw	r26, r24
    28e0:	cb 01       	movw	r24, r22
    28e2:	9a a3       	std	Y+34, r25	; 0x22
    28e4:	89 a3       	std	Y+33, r24	; 0x21
    28e6:	0f c0       	rjmp	.+30     	; 0x2906 <check_color+0x3e8>
    28e8:	80 e7       	ldi	r24, 0x70	; 112
    28ea:	91 e0       	ldi	r25, 0x01	; 1
    28ec:	98 a3       	std	Y+32, r25	; 0x20
    28ee:	8f 8f       	std	Y+31, r24	; 0x1f
    28f0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    28f2:	98 a1       	ldd	r25, Y+32	; 0x20
    28f4:	01 97       	sbiw	r24, 0x01	; 1
    28f6:	f1 f7       	brne	.-4      	; 0x28f4 <check_color+0x3d6>
    28f8:	98 a3       	std	Y+32, r25	; 0x20
    28fa:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28fc:	89 a1       	ldd	r24, Y+33	; 0x21
    28fe:	9a a1       	ldd	r25, Y+34	; 0x22
    2900:	01 97       	sbiw	r24, 0x01	; 1
    2902:	9a a3       	std	Y+34, r25	; 0x22
    2904:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2906:	89 a1       	ldd	r24, Y+33	; 0x21
    2908:	9a a1       	ldd	r25, Y+34	; 0x22
    290a:	00 97       	sbiw	r24, 0x00	; 0
    290c:	69 f7       	brne	.-38     	; 0x28e8 <check_color+0x3ca>
    290e:	14 c0       	rjmp	.+40     	; 0x2938 <check_color+0x41a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2910:	6b a1       	ldd	r22, Y+35	; 0x23
    2912:	7c a1       	ldd	r23, Y+36	; 0x24
    2914:	8d a1       	ldd	r24, Y+37	; 0x25
    2916:	9e a1       	ldd	r25, Y+38	; 0x26
    2918:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    291c:	dc 01       	movw	r26, r24
    291e:	cb 01       	movw	r24, r22
    2920:	9a a3       	std	Y+34, r25	; 0x22
    2922:	89 a3       	std	Y+33, r24	; 0x21
    2924:	89 a1       	ldd	r24, Y+33	; 0x21
    2926:	9a a1       	ldd	r25, Y+34	; 0x22
    2928:	9e 8f       	std	Y+30, r25	; 0x1e
    292a:	8d 8f       	std	Y+29, r24	; 0x1d
    292c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    292e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2930:	01 97       	sbiw	r24, 0x01	; 1
    2932:	f1 f7       	brne	.-4      	; 0x2930 <check_color+0x412>
    2934:	9e 8f       	std	Y+30, r25	; 0x1e
    2936:	8d 8f       	std	Y+29, r24	; 0x1d
      _delay_ms(1000);    // Display for 1000ms or 1 second
      lcd_wr_command(0x01);   //Clear the LCD
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
        return Blue;
    293e:	82 e0       	ldi	r24, 0x02	; 2
    2940:	28 96       	adiw	r28, 0x08	; 8
    2942:	8f af       	std	Y+63, r24	; 0x3f
    2944:	28 97       	sbiw	r28, 0x08	; 8
    2946:	a8 c1       	rjmp	.+848    	; 0x2c98 <check_color+0x77a>
     
     }
     if((green>red) && (green>blue) && (green>2800))
    2948:	20 91 3e 03 	lds	r18, 0x033E
    294c:	30 91 3f 03 	lds	r19, 0x033F
    2950:	40 91 40 03 	lds	r20, 0x0340
    2954:	50 91 41 03 	lds	r21, 0x0341
    2958:	80 91 42 03 	lds	r24, 0x0342
    295c:	90 91 43 03 	lds	r25, 0x0343
    2960:	a0 91 44 03 	lds	r26, 0x0344
    2964:	b0 91 45 03 	lds	r27, 0x0345
    2968:	82 17       	cp	r24, r18
    296a:	93 07       	cpc	r25, r19
    296c:	a4 07       	cpc	r26, r20
    296e:	b5 07       	cpc	r27, r21
    2970:	08 f0       	brcs	.+2      	; 0x2974 <check_color+0x456>
    2972:	a9 c0       	rjmp	.+338    	; 0x2ac6 <check_color+0x5a8>
    2974:	20 91 3e 03 	lds	r18, 0x033E
    2978:	30 91 3f 03 	lds	r19, 0x033F
    297c:	40 91 40 03 	lds	r20, 0x0340
    2980:	50 91 41 03 	lds	r21, 0x0341
    2984:	80 91 34 03 	lds	r24, 0x0334
    2988:	90 91 35 03 	lds	r25, 0x0335
    298c:	a0 91 36 03 	lds	r26, 0x0336
    2990:	b0 91 37 03 	lds	r27, 0x0337
    2994:	82 17       	cp	r24, r18
    2996:	93 07       	cpc	r25, r19
    2998:	a4 07       	cpc	r26, r20
    299a:	b5 07       	cpc	r27, r21
    299c:	08 f0       	brcs	.+2      	; 0x29a0 <check_color+0x482>
    299e:	93 c0       	rjmp	.+294    	; 0x2ac6 <check_color+0x5a8>
    29a0:	80 91 3e 03 	lds	r24, 0x033E
    29a4:	90 91 3f 03 	lds	r25, 0x033F
    29a8:	a0 91 40 03 	lds	r26, 0x0340
    29ac:	b0 91 41 03 	lds	r27, 0x0341
    29b0:	81 3f       	cpi	r24, 0xF1	; 241
    29b2:	ea e0       	ldi	r30, 0x0A	; 10
    29b4:	9e 07       	cpc	r25, r30
    29b6:	e0 e0       	ldi	r30, 0x00	; 0
    29b8:	ae 07       	cpc	r26, r30
    29ba:	e0 e0       	ldi	r30, 0x00	; 0
    29bc:	be 07       	cpc	r27, r30
    29be:	08 f4       	brcc	.+2      	; 0x29c2 <check_color+0x4a4>
    29c0:	82 c0       	rjmp	.+260    	; 0x2ac6 <check_color+0x5a8>
     {
        lcd_cursor(1,1);      //set the cursor on row 1, column 1
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	61 e0       	ldi	r22, 0x01	; 1
    29c6:	0e 94 05 09 	call	0x120a	; 0x120a <lcd_cursor>
      lcd_string("Green"); 
    29ca:	8b e0       	ldi	r24, 0x0B	; 11
    29cc:	92 e0       	ldi	r25, 0x02	; 2
    29ce:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
    29d2:	80 e0       	ldi	r24, 0x00	; 0
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	aa e7       	ldi	r26, 0x7A	; 122
    29d8:	b4 e4       	ldi	r27, 0x44	; 68
    29da:	89 8f       	std	Y+25, r24	; 0x19
    29dc:	9a 8f       	std	Y+26, r25	; 0x1a
    29de:	ab 8f       	std	Y+27, r26	; 0x1b
    29e0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    29e2:	69 8d       	ldd	r22, Y+25	; 0x19
    29e4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    29e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    29e8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    29ea:	26 e6       	ldi	r18, 0x66	; 102
    29ec:	36 e6       	ldi	r19, 0x66	; 102
    29ee:	46 e6       	ldi	r20, 0x66	; 102
    29f0:	55 e4       	ldi	r21, 0x45	; 69
    29f2:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    29f6:	dc 01       	movw	r26, r24
    29f8:	cb 01       	movw	r24, r22
    29fa:	8d 8b       	std	Y+21, r24	; 0x15
    29fc:	9e 8b       	std	Y+22, r25	; 0x16
    29fe:	af 8b       	std	Y+23, r26	; 0x17
    2a00:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2a02:	6d 89       	ldd	r22, Y+21	; 0x15
    2a04:	7e 89       	ldd	r23, Y+22	; 0x16
    2a06:	8f 89       	ldd	r24, Y+23	; 0x17
    2a08:	98 8d       	ldd	r25, Y+24	; 0x18
    2a0a:	20 e0       	ldi	r18, 0x00	; 0
    2a0c:	30 e0       	ldi	r19, 0x00	; 0
    2a0e:	40 e8       	ldi	r20, 0x80	; 128
    2a10:	5f e3       	ldi	r21, 0x3F	; 63
    2a12:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2a16:	88 23       	and	r24, r24
    2a18:	2c f4       	brge	.+10     	; 0x2a24 <check_color+0x506>
		__ticks = 1;
    2a1a:	81 e0       	ldi	r24, 0x01	; 1
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	9c 8b       	std	Y+20, r25	; 0x14
    2a20:	8b 8b       	std	Y+19, r24	; 0x13
    2a22:	3f c0       	rjmp	.+126    	; 0x2aa2 <check_color+0x584>
	else if (__tmp > 65535)
    2a24:	6d 89       	ldd	r22, Y+21	; 0x15
    2a26:	7e 89       	ldd	r23, Y+22	; 0x16
    2a28:	8f 89       	ldd	r24, Y+23	; 0x17
    2a2a:	98 8d       	ldd	r25, Y+24	; 0x18
    2a2c:	20 e0       	ldi	r18, 0x00	; 0
    2a2e:	3f ef       	ldi	r19, 0xFF	; 255
    2a30:	4f e7       	ldi	r20, 0x7F	; 127
    2a32:	57 e4       	ldi	r21, 0x47	; 71
    2a34:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2a38:	18 16       	cp	r1, r24
    2a3a:	4c f5       	brge	.+82     	; 0x2a8e <check_color+0x570>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2a3c:	69 8d       	ldd	r22, Y+25	; 0x19
    2a3e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2a40:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2a42:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2a44:	20 e0       	ldi	r18, 0x00	; 0
    2a46:	30 e0       	ldi	r19, 0x00	; 0
    2a48:	40 e2       	ldi	r20, 0x20	; 32
    2a4a:	51 e4       	ldi	r21, 0x41	; 65
    2a4c:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2a50:	dc 01       	movw	r26, r24
    2a52:	cb 01       	movw	r24, r22
    2a54:	bc 01       	movw	r22, r24
    2a56:	cd 01       	movw	r24, r26
    2a58:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2a5c:	dc 01       	movw	r26, r24
    2a5e:	cb 01       	movw	r24, r22
    2a60:	9c 8b       	std	Y+20, r25	; 0x14
    2a62:	8b 8b       	std	Y+19, r24	; 0x13
    2a64:	0f c0       	rjmp	.+30     	; 0x2a84 <check_color+0x566>
    2a66:	80 e7       	ldi	r24, 0x70	; 112
    2a68:	91 e0       	ldi	r25, 0x01	; 1
    2a6a:	9a 8b       	std	Y+18, r25	; 0x12
    2a6c:	89 8b       	std	Y+17, r24	; 0x11
    2a6e:	89 89       	ldd	r24, Y+17	; 0x11
    2a70:	9a 89       	ldd	r25, Y+18	; 0x12
    2a72:	01 97       	sbiw	r24, 0x01	; 1
    2a74:	f1 f7       	brne	.-4      	; 0x2a72 <check_color+0x554>
    2a76:	9a 8b       	std	Y+18, r25	; 0x12
    2a78:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a7a:	8b 89       	ldd	r24, Y+19	; 0x13
    2a7c:	9c 89       	ldd	r25, Y+20	; 0x14
    2a7e:	01 97       	sbiw	r24, 0x01	; 1
    2a80:	9c 8b       	std	Y+20, r25	; 0x14
    2a82:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a84:	8b 89       	ldd	r24, Y+19	; 0x13
    2a86:	9c 89       	ldd	r25, Y+20	; 0x14
    2a88:	00 97       	sbiw	r24, 0x00	; 0
    2a8a:	69 f7       	brne	.-38     	; 0x2a66 <check_color+0x548>
    2a8c:	14 c0       	rjmp	.+40     	; 0x2ab6 <check_color+0x598>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a8e:	6d 89       	ldd	r22, Y+21	; 0x15
    2a90:	7e 89       	ldd	r23, Y+22	; 0x16
    2a92:	8f 89       	ldd	r24, Y+23	; 0x17
    2a94:	98 8d       	ldd	r25, Y+24	; 0x18
    2a96:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2a9a:	dc 01       	movw	r26, r24
    2a9c:	cb 01       	movw	r24, r22
    2a9e:	9c 8b       	std	Y+20, r25	; 0x14
    2aa0:	8b 8b       	std	Y+19, r24	; 0x13
    2aa2:	8b 89       	ldd	r24, Y+19	; 0x13
    2aa4:	9c 89       	ldd	r25, Y+20	; 0x14
    2aa6:	98 8b       	std	Y+16, r25	; 0x10
    2aa8:	8f 87       	std	Y+15, r24	; 0x0f
    2aaa:	8f 85       	ldd	r24, Y+15	; 0x0f
    2aac:	98 89       	ldd	r25, Y+16	; 0x10
    2aae:	01 97       	sbiw	r24, 0x01	; 1
    2ab0:	f1 f7       	brne	.-4      	; 0x2aae <check_color+0x590>
    2ab2:	98 8b       	std	Y+16, r25	; 0x10
    2ab4:	8f 87       	std	Y+15, r24	; 0x0f
      _delay_ms(1000);    // Display for 1000ms or 1 second
      lcd_wr_command(0x01);   //Clear the LCD
    2ab6:	81 e0       	ldi	r24, 0x01	; 1
    2ab8:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
        return Green;
    2abc:	f1 e0       	ldi	r31, 0x01	; 1
    2abe:	28 96       	adiw	r28, 0x08	; 8
    2ac0:	ff af       	std	Y+63, r31	; 0x3f
    2ac2:	28 97       	sbiw	r28, 0x08	; 8
    2ac4:	e9 c0       	rjmp	.+466    	; 0x2c98 <check_color+0x77a>

     }
    if((green<2000 && green>900) && (blue<2000 && blue>1000) && (red<2000 && red>1000))
    2ac6:	80 91 3e 03 	lds	r24, 0x033E
    2aca:	90 91 3f 03 	lds	r25, 0x033F
    2ace:	a0 91 40 03 	lds	r26, 0x0340
    2ad2:	b0 91 41 03 	lds	r27, 0x0341
    2ad6:	80 3d       	cpi	r24, 0xD0	; 208
    2ad8:	27 e0       	ldi	r18, 0x07	; 7
    2ada:	92 07       	cpc	r25, r18
    2adc:	20 e0       	ldi	r18, 0x00	; 0
    2ade:	a2 07       	cpc	r26, r18
    2ae0:	20 e0       	ldi	r18, 0x00	; 0
    2ae2:	b2 07       	cpc	r27, r18
    2ae4:	08 f0       	brcs	.+2      	; 0x2ae8 <check_color+0x5ca>
    2ae6:	d7 c0       	rjmp	.+430    	; 0x2c96 <check_color+0x778>
    2ae8:	80 91 3e 03 	lds	r24, 0x033E
    2aec:	90 91 3f 03 	lds	r25, 0x033F
    2af0:	a0 91 40 03 	lds	r26, 0x0340
    2af4:	b0 91 41 03 	lds	r27, 0x0341
    2af8:	85 38       	cpi	r24, 0x85	; 133
    2afa:	e3 e0       	ldi	r30, 0x03	; 3
    2afc:	9e 07       	cpc	r25, r30
    2afe:	e0 e0       	ldi	r30, 0x00	; 0
    2b00:	ae 07       	cpc	r26, r30
    2b02:	e0 e0       	ldi	r30, 0x00	; 0
    2b04:	be 07       	cpc	r27, r30
    2b06:	08 f4       	brcc	.+2      	; 0x2b0a <check_color+0x5ec>
    2b08:	c6 c0       	rjmp	.+396    	; 0x2c96 <check_color+0x778>
    2b0a:	80 91 34 03 	lds	r24, 0x0334
    2b0e:	90 91 35 03 	lds	r25, 0x0335
    2b12:	a0 91 36 03 	lds	r26, 0x0336
    2b16:	b0 91 37 03 	lds	r27, 0x0337
    2b1a:	80 3d       	cpi	r24, 0xD0	; 208
    2b1c:	f7 e0       	ldi	r31, 0x07	; 7
    2b1e:	9f 07       	cpc	r25, r31
    2b20:	f0 e0       	ldi	r31, 0x00	; 0
    2b22:	af 07       	cpc	r26, r31
    2b24:	f0 e0       	ldi	r31, 0x00	; 0
    2b26:	bf 07       	cpc	r27, r31
    2b28:	08 f0       	brcs	.+2      	; 0x2b2c <check_color+0x60e>
    2b2a:	b5 c0       	rjmp	.+362    	; 0x2c96 <check_color+0x778>
    2b2c:	80 91 34 03 	lds	r24, 0x0334
    2b30:	90 91 35 03 	lds	r25, 0x0335
    2b34:	a0 91 36 03 	lds	r26, 0x0336
    2b38:	b0 91 37 03 	lds	r27, 0x0337
    2b3c:	89 3e       	cpi	r24, 0xE9	; 233
    2b3e:	23 e0       	ldi	r18, 0x03	; 3
    2b40:	92 07       	cpc	r25, r18
    2b42:	20 e0       	ldi	r18, 0x00	; 0
    2b44:	a2 07       	cpc	r26, r18
    2b46:	20 e0       	ldi	r18, 0x00	; 0
    2b48:	b2 07       	cpc	r27, r18
    2b4a:	08 f4       	brcc	.+2      	; 0x2b4e <check_color+0x630>
    2b4c:	a4 c0       	rjmp	.+328    	; 0x2c96 <check_color+0x778>
    2b4e:	80 91 42 03 	lds	r24, 0x0342
    2b52:	90 91 43 03 	lds	r25, 0x0343
    2b56:	a0 91 44 03 	lds	r26, 0x0344
    2b5a:	b0 91 45 03 	lds	r27, 0x0345
    2b5e:	80 3d       	cpi	r24, 0xD0	; 208
    2b60:	e7 e0       	ldi	r30, 0x07	; 7
    2b62:	9e 07       	cpc	r25, r30
    2b64:	e0 e0       	ldi	r30, 0x00	; 0
    2b66:	ae 07       	cpc	r26, r30
    2b68:	e0 e0       	ldi	r30, 0x00	; 0
    2b6a:	be 07       	cpc	r27, r30
    2b6c:	08 f0       	brcs	.+2      	; 0x2b70 <check_color+0x652>
    2b6e:	93 c0       	rjmp	.+294    	; 0x2c96 <check_color+0x778>
    2b70:	80 91 42 03 	lds	r24, 0x0342
    2b74:	90 91 43 03 	lds	r25, 0x0343
    2b78:	a0 91 44 03 	lds	r26, 0x0344
    2b7c:	b0 91 45 03 	lds	r27, 0x0345
    2b80:	89 3e       	cpi	r24, 0xE9	; 233
    2b82:	f3 e0       	ldi	r31, 0x03	; 3
    2b84:	9f 07       	cpc	r25, r31
    2b86:	f0 e0       	ldi	r31, 0x00	; 0
    2b88:	af 07       	cpc	r26, r31
    2b8a:	f0 e0       	ldi	r31, 0x00	; 0
    2b8c:	bf 07       	cpc	r27, r31
    2b8e:	08 f4       	brcc	.+2      	; 0x2b92 <check_color+0x674>
    2b90:	82 c0       	rjmp	.+260    	; 0x2c96 <check_color+0x778>
     {
        lcd_cursor(1,1);      //set the cursor on row 1, column 1
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	61 e0       	ldi	r22, 0x01	; 1
    2b96:	0e 94 05 09 	call	0x120a	; 0x120a <lcd_cursor>
      lcd_string("Black"); 
    2b9a:	81 e1       	ldi	r24, 0x11	; 17
    2b9c:	92 e0       	ldi	r25, 0x02	; 2
    2b9e:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
    2ba2:	80 e0       	ldi	r24, 0x00	; 0
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	aa e7       	ldi	r26, 0x7A	; 122
    2ba8:	b4 e4       	ldi	r27, 0x44	; 68
    2baa:	8b 87       	std	Y+11, r24	; 0x0b
    2bac:	9c 87       	std	Y+12, r25	; 0x0c
    2bae:	ad 87       	std	Y+13, r26	; 0x0d
    2bb0:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2bb2:	6b 85       	ldd	r22, Y+11	; 0x0b
    2bb4:	7c 85       	ldd	r23, Y+12	; 0x0c
    2bb6:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bb8:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bba:	26 e6       	ldi	r18, 0x66	; 102
    2bbc:	36 e6       	ldi	r19, 0x66	; 102
    2bbe:	46 e6       	ldi	r20, 0x66	; 102
    2bc0:	55 e4       	ldi	r21, 0x45	; 69
    2bc2:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2bc6:	dc 01       	movw	r26, r24
    2bc8:	cb 01       	movw	r24, r22
    2bca:	8f 83       	std	Y+7, r24	; 0x07
    2bcc:	98 87       	std	Y+8, r25	; 0x08
    2bce:	a9 87       	std	Y+9, r26	; 0x09
    2bd0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2bd2:	6f 81       	ldd	r22, Y+7	; 0x07
    2bd4:	78 85       	ldd	r23, Y+8	; 0x08
    2bd6:	89 85       	ldd	r24, Y+9	; 0x09
    2bd8:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bda:	20 e0       	ldi	r18, 0x00	; 0
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	40 e8       	ldi	r20, 0x80	; 128
    2be0:	5f e3       	ldi	r21, 0x3F	; 63
    2be2:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2be6:	88 23       	and	r24, r24
    2be8:	2c f4       	brge	.+10     	; 0x2bf4 <check_color+0x6d6>
		__ticks = 1;
    2bea:	81 e0       	ldi	r24, 0x01	; 1
    2bec:	90 e0       	ldi	r25, 0x00	; 0
    2bee:	9e 83       	std	Y+6, r25	; 0x06
    2bf0:	8d 83       	std	Y+5, r24	; 0x05
    2bf2:	3f c0       	rjmp	.+126    	; 0x2c72 <check_color+0x754>
	else if (__tmp > 65535)
    2bf4:	6f 81       	ldd	r22, Y+7	; 0x07
    2bf6:	78 85       	ldd	r23, Y+8	; 0x08
    2bf8:	89 85       	ldd	r24, Y+9	; 0x09
    2bfa:	9a 85       	ldd	r25, Y+10	; 0x0a
    2bfc:	20 e0       	ldi	r18, 0x00	; 0
    2bfe:	3f ef       	ldi	r19, 0xFF	; 255
    2c00:	4f e7       	ldi	r20, 0x7F	; 127
    2c02:	57 e4       	ldi	r21, 0x47	; 71
    2c04:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2c08:	18 16       	cp	r1, r24
    2c0a:	4c f5       	brge	.+82     	; 0x2c5e <check_color+0x740>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c0c:	6b 85       	ldd	r22, Y+11	; 0x0b
    2c0e:	7c 85       	ldd	r23, Y+12	; 0x0c
    2c10:	8d 85       	ldd	r24, Y+13	; 0x0d
    2c12:	9e 85       	ldd	r25, Y+14	; 0x0e
    2c14:	20 e0       	ldi	r18, 0x00	; 0
    2c16:	30 e0       	ldi	r19, 0x00	; 0
    2c18:	40 e2       	ldi	r20, 0x20	; 32
    2c1a:	51 e4       	ldi	r21, 0x41	; 65
    2c1c:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2c20:	dc 01       	movw	r26, r24
    2c22:	cb 01       	movw	r24, r22
    2c24:	bc 01       	movw	r22, r24
    2c26:	cd 01       	movw	r24, r26
    2c28:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2c2c:	dc 01       	movw	r26, r24
    2c2e:	cb 01       	movw	r24, r22
    2c30:	9e 83       	std	Y+6, r25	; 0x06
    2c32:	8d 83       	std	Y+5, r24	; 0x05
    2c34:	0f c0       	rjmp	.+30     	; 0x2c54 <check_color+0x736>
    2c36:	80 e7       	ldi	r24, 0x70	; 112
    2c38:	91 e0       	ldi	r25, 0x01	; 1
    2c3a:	9c 83       	std	Y+4, r25	; 0x04
    2c3c:	8b 83       	std	Y+3, r24	; 0x03
    2c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c40:	9c 81       	ldd	r25, Y+4	; 0x04
    2c42:	01 97       	sbiw	r24, 0x01	; 1
    2c44:	f1 f7       	brne	.-4      	; 0x2c42 <check_color+0x724>
    2c46:	9c 83       	std	Y+4, r25	; 0x04
    2c48:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c4e:	01 97       	sbiw	r24, 0x01	; 1
    2c50:	9e 83       	std	Y+6, r25	; 0x06
    2c52:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c54:	8d 81       	ldd	r24, Y+5	; 0x05
    2c56:	9e 81       	ldd	r25, Y+6	; 0x06
    2c58:	00 97       	sbiw	r24, 0x00	; 0
    2c5a:	69 f7       	brne	.-38     	; 0x2c36 <check_color+0x718>
    2c5c:	14 c0       	rjmp	.+40     	; 0x2c86 <check_color+0x768>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c5e:	6f 81       	ldd	r22, Y+7	; 0x07
    2c60:	78 85       	ldd	r23, Y+8	; 0x08
    2c62:	89 85       	ldd	r24, Y+9	; 0x09
    2c64:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c66:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2c6a:	dc 01       	movw	r26, r24
    2c6c:	cb 01       	movw	r24, r22
    2c6e:	9e 83       	std	Y+6, r25	; 0x06
    2c70:	8d 83       	std	Y+5, r24	; 0x05
    2c72:	8d 81       	ldd	r24, Y+5	; 0x05
    2c74:	9e 81       	ldd	r25, Y+6	; 0x06
    2c76:	9a 83       	std	Y+2, r25	; 0x02
    2c78:	89 83       	std	Y+1, r24	; 0x01
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7e:	01 97       	sbiw	r24, 0x01	; 1
    2c80:	f1 f7       	brne	.-4      	; 0x2c7e <check_color+0x760>
    2c82:	9a 83       	std	Y+2, r25	; 0x02
    2c84:	89 83       	std	Y+1, r24	; 0x01
      _delay_ms(1000);    // Display for 1000ms or 1 second
      lcd_wr_command(0x01);   //Clear the LCD
    2c86:	81 e0       	ldi	r24, 0x01	; 1
    2c88:	0e 94 2a 06 	call	0xc54	; 0xc54 <lcd_wr_command>
        return Key;
    2c8c:	23 e0       	ldi	r18, 0x03	; 3
    2c8e:	28 96       	adiw	r28, 0x08	; 8
    2c90:	2f af       	std	Y+63, r18	; 0x3f
    2c92:	28 97       	sbiw	r28, 0x08	; 8
    2c94:	01 c0       	rjmp	.+2      	; 0x2c98 <check_color+0x77a>
    2c96:	06 c0       	rjmp	.+12     	; 0x2ca4 <check_color+0x786>
      
    }
     
      
}
    2c98:	28 96       	adiw	r28, 0x08	; 8
    2c9a:	8f ad       	ldd	r24, Y+63	; 0x3f
    2c9c:	28 97       	sbiw	r28, 0x08	; 8
    2c9e:	29 96       	adiw	r28, 0x09	; 9
    2ca0:	8f af       	std	Y+63, r24	; 0x3f
    2ca2:	29 97       	sbiw	r28, 0x09	; 9
    2ca4:	29 96       	adiw	r28, 0x09	; 9
    2ca6:	8f ad       	ldd	r24, Y+63	; 0x3f
    2ca8:	29 97       	sbiw	r28, 0x09	; 9
    2caa:	c8 5b       	subi	r28, 0xB8	; 184
    2cac:	df 4f       	sbci	r29, 0xFF	; 255
    2cae:	0f b6       	in	r0, 0x3f	; 63
    2cb0:	f8 94       	cli
    2cb2:	de bf       	out	0x3e, r29	; 62
    2cb4:	0f be       	out	0x3f, r0	; 63
    2cb6:	cd bf       	out	0x3d, r28	; 61
    2cb8:	cf 91       	pop	r28
    2cba:	df 91       	pop	r29
    2cbc:	1f 91       	pop	r17
    2cbe:	0f 91       	pop	r16
    2cc0:	08 95       	ret

00002cc2 <pick_box>:

void pick_box()
{
    2cc2:	df 93       	push	r29
    2cc4:	cf 93       	push	r28
    2cc6:	cd b7       	in	r28, 0x3d	; 61
    2cc8:	de b7       	in	r29, 0x3e	; 62
    2cca:	e8 97       	sbiw	r28, 0x38	; 56
    2ccc:	0f b6       	in	r0, 0x3f	; 63
    2cce:	f8 94       	cli
    2cd0:	de bf       	out	0x3e, r29	; 62
    2cd2:	0f be       	out	0x3f, r0	; 63
    2cd4:	cd bf       	out	0x3d, r28	; 61
  servo_2(5);         //open the gripper
    2cd6:	85 e0       	ldi	r24, 0x05	; 5
    2cd8:	0e 94 c6 11 	call	0x238c	; 0x238c <servo_2>
    2cdc:	80 e0       	ldi	r24, 0x00	; 0
    2cde:	90 e0       	ldi	r25, 0x00	; 0
    2ce0:	aa e7       	ldi	r26, 0x7A	; 122
    2ce2:	b4 e4       	ldi	r27, 0x44	; 68
    2ce4:	8d ab       	std	Y+53, r24	; 0x35
    2ce6:	9e ab       	std	Y+54, r25	; 0x36
    2ce8:	af ab       	std	Y+55, r26	; 0x37
    2cea:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2cec:	6d a9       	ldd	r22, Y+53	; 0x35
    2cee:	7e a9       	ldd	r23, Y+54	; 0x36
    2cf0:	8f a9       	ldd	r24, Y+55	; 0x37
    2cf2:	98 ad       	ldd	r25, Y+56	; 0x38
    2cf4:	26 e6       	ldi	r18, 0x66	; 102
    2cf6:	36 e6       	ldi	r19, 0x66	; 102
    2cf8:	46 e6       	ldi	r20, 0x66	; 102
    2cfa:	55 e4       	ldi	r21, 0x45	; 69
    2cfc:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2d00:	dc 01       	movw	r26, r24
    2d02:	cb 01       	movw	r24, r22
    2d04:	89 ab       	std	Y+49, r24	; 0x31
    2d06:	9a ab       	std	Y+50, r25	; 0x32
    2d08:	ab ab       	std	Y+51, r26	; 0x33
    2d0a:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2d0c:	69 a9       	ldd	r22, Y+49	; 0x31
    2d0e:	7a a9       	ldd	r23, Y+50	; 0x32
    2d10:	8b a9       	ldd	r24, Y+51	; 0x33
    2d12:	9c a9       	ldd	r25, Y+52	; 0x34
    2d14:	20 e0       	ldi	r18, 0x00	; 0
    2d16:	30 e0       	ldi	r19, 0x00	; 0
    2d18:	40 e8       	ldi	r20, 0x80	; 128
    2d1a:	5f e3       	ldi	r21, 0x3F	; 63
    2d1c:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2d20:	88 23       	and	r24, r24
    2d22:	2c f4       	brge	.+10     	; 0x2d2e <pick_box+0x6c>
		__ticks = 1;
    2d24:	81 e0       	ldi	r24, 0x01	; 1
    2d26:	90 e0       	ldi	r25, 0x00	; 0
    2d28:	98 ab       	std	Y+48, r25	; 0x30
    2d2a:	8f a7       	std	Y+47, r24	; 0x2f
    2d2c:	3f c0       	rjmp	.+126    	; 0x2dac <pick_box+0xea>
	else if (__tmp > 65535)
    2d2e:	69 a9       	ldd	r22, Y+49	; 0x31
    2d30:	7a a9       	ldd	r23, Y+50	; 0x32
    2d32:	8b a9       	ldd	r24, Y+51	; 0x33
    2d34:	9c a9       	ldd	r25, Y+52	; 0x34
    2d36:	20 e0       	ldi	r18, 0x00	; 0
    2d38:	3f ef       	ldi	r19, 0xFF	; 255
    2d3a:	4f e7       	ldi	r20, 0x7F	; 127
    2d3c:	57 e4       	ldi	r21, 0x47	; 71
    2d3e:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2d42:	18 16       	cp	r1, r24
    2d44:	4c f5       	brge	.+82     	; 0x2d98 <pick_box+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2d46:	6d a9       	ldd	r22, Y+53	; 0x35
    2d48:	7e a9       	ldd	r23, Y+54	; 0x36
    2d4a:	8f a9       	ldd	r24, Y+55	; 0x37
    2d4c:	98 ad       	ldd	r25, Y+56	; 0x38
    2d4e:	20 e0       	ldi	r18, 0x00	; 0
    2d50:	30 e0       	ldi	r19, 0x00	; 0
    2d52:	40 e2       	ldi	r20, 0x20	; 32
    2d54:	51 e4       	ldi	r21, 0x41	; 65
    2d56:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2d5a:	dc 01       	movw	r26, r24
    2d5c:	cb 01       	movw	r24, r22
    2d5e:	bc 01       	movw	r22, r24
    2d60:	cd 01       	movw	r24, r26
    2d62:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2d66:	dc 01       	movw	r26, r24
    2d68:	cb 01       	movw	r24, r22
    2d6a:	98 ab       	std	Y+48, r25	; 0x30
    2d6c:	8f a7       	std	Y+47, r24	; 0x2f
    2d6e:	0f c0       	rjmp	.+30     	; 0x2d8e <pick_box+0xcc>
    2d70:	80 e7       	ldi	r24, 0x70	; 112
    2d72:	91 e0       	ldi	r25, 0x01	; 1
    2d74:	9e a7       	std	Y+46, r25	; 0x2e
    2d76:	8d a7       	std	Y+45, r24	; 0x2d
    2d78:	8d a5       	ldd	r24, Y+45	; 0x2d
    2d7a:	9e a5       	ldd	r25, Y+46	; 0x2e
    2d7c:	01 97       	sbiw	r24, 0x01	; 1
    2d7e:	f1 f7       	brne	.-4      	; 0x2d7c <pick_box+0xba>
    2d80:	9e a7       	std	Y+46, r25	; 0x2e
    2d82:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d84:	8f a5       	ldd	r24, Y+47	; 0x2f
    2d86:	98 a9       	ldd	r25, Y+48	; 0x30
    2d88:	01 97       	sbiw	r24, 0x01	; 1
    2d8a:	98 ab       	std	Y+48, r25	; 0x30
    2d8c:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2d8e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2d90:	98 a9       	ldd	r25, Y+48	; 0x30
    2d92:	00 97       	sbiw	r24, 0x00	; 0
    2d94:	69 f7       	brne	.-38     	; 0x2d70 <pick_box+0xae>
    2d96:	14 c0       	rjmp	.+40     	; 0x2dc0 <pick_box+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2d98:	69 a9       	ldd	r22, Y+49	; 0x31
    2d9a:	7a a9       	ldd	r23, Y+50	; 0x32
    2d9c:	8b a9       	ldd	r24, Y+51	; 0x33
    2d9e:	9c a9       	ldd	r25, Y+52	; 0x34
    2da0:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2da4:	dc 01       	movw	r26, r24
    2da6:	cb 01       	movw	r24, r22
    2da8:	98 ab       	std	Y+48, r25	; 0x30
    2daa:	8f a7       	std	Y+47, r24	; 0x2f
    2dac:	8f a5       	ldd	r24, Y+47	; 0x2f
    2dae:	98 a9       	ldd	r25, Y+48	; 0x30
    2db0:	9c a7       	std	Y+44, r25	; 0x2c
    2db2:	8b a7       	std	Y+43, r24	; 0x2b
    2db4:	8b a5       	ldd	r24, Y+43	; 0x2b
    2db6:	9c a5       	ldd	r25, Y+44	; 0x2c
    2db8:	01 97       	sbiw	r24, 0x01	; 1
    2dba:	f1 f7       	brne	.-4      	; 0x2db8 <pick_box+0xf6>
    2dbc:	9c a7       	std	Y+44, r25	; 0x2c
    2dbe:	8b a7       	std	Y+43, r24	; 0x2b
  _delay_ms(1000);
  servo_1(60);        //lower the arm
    2dc0:	8c e3       	ldi	r24, 0x3C	; 60
    2dc2:	0e 94 78 11 	call	0x22f0	; 0x22f0 <servo_1>
    2dc6:	80 e0       	ldi	r24, 0x00	; 0
    2dc8:	90 e0       	ldi	r25, 0x00	; 0
    2dca:	aa e7       	ldi	r26, 0x7A	; 122
    2dcc:	b4 e4       	ldi	r27, 0x44	; 68
    2dce:	8f a3       	std	Y+39, r24	; 0x27
    2dd0:	98 a7       	std	Y+40, r25	; 0x28
    2dd2:	a9 a7       	std	Y+41, r26	; 0x29
    2dd4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2dd6:	6f a1       	ldd	r22, Y+39	; 0x27
    2dd8:	78 a5       	ldd	r23, Y+40	; 0x28
    2dda:	89 a5       	ldd	r24, Y+41	; 0x29
    2ddc:	9a a5       	ldd	r25, Y+42	; 0x2a
    2dde:	26 e6       	ldi	r18, 0x66	; 102
    2de0:	36 e6       	ldi	r19, 0x66	; 102
    2de2:	46 e6       	ldi	r20, 0x66	; 102
    2de4:	55 e4       	ldi	r21, 0x45	; 69
    2de6:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2dea:	dc 01       	movw	r26, r24
    2dec:	cb 01       	movw	r24, r22
    2dee:	8b a3       	std	Y+35, r24	; 0x23
    2df0:	9c a3       	std	Y+36, r25	; 0x24
    2df2:	ad a3       	std	Y+37, r26	; 0x25
    2df4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2df6:	6b a1       	ldd	r22, Y+35	; 0x23
    2df8:	7c a1       	ldd	r23, Y+36	; 0x24
    2dfa:	8d a1       	ldd	r24, Y+37	; 0x25
    2dfc:	9e a1       	ldd	r25, Y+38	; 0x26
    2dfe:	20 e0       	ldi	r18, 0x00	; 0
    2e00:	30 e0       	ldi	r19, 0x00	; 0
    2e02:	40 e8       	ldi	r20, 0x80	; 128
    2e04:	5f e3       	ldi	r21, 0x3F	; 63
    2e06:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2e0a:	88 23       	and	r24, r24
    2e0c:	2c f4       	brge	.+10     	; 0x2e18 <pick_box+0x156>
		__ticks = 1;
    2e0e:	81 e0       	ldi	r24, 0x01	; 1
    2e10:	90 e0       	ldi	r25, 0x00	; 0
    2e12:	9a a3       	std	Y+34, r25	; 0x22
    2e14:	89 a3       	std	Y+33, r24	; 0x21
    2e16:	3f c0       	rjmp	.+126    	; 0x2e96 <pick_box+0x1d4>
	else if (__tmp > 65535)
    2e18:	6b a1       	ldd	r22, Y+35	; 0x23
    2e1a:	7c a1       	ldd	r23, Y+36	; 0x24
    2e1c:	8d a1       	ldd	r24, Y+37	; 0x25
    2e1e:	9e a1       	ldd	r25, Y+38	; 0x26
    2e20:	20 e0       	ldi	r18, 0x00	; 0
    2e22:	3f ef       	ldi	r19, 0xFF	; 255
    2e24:	4f e7       	ldi	r20, 0x7F	; 127
    2e26:	57 e4       	ldi	r21, 0x47	; 71
    2e28:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2e2c:	18 16       	cp	r1, r24
    2e2e:	4c f5       	brge	.+82     	; 0x2e82 <pick_box+0x1c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2e30:	6f a1       	ldd	r22, Y+39	; 0x27
    2e32:	78 a5       	ldd	r23, Y+40	; 0x28
    2e34:	89 a5       	ldd	r24, Y+41	; 0x29
    2e36:	9a a5       	ldd	r25, Y+42	; 0x2a
    2e38:	20 e0       	ldi	r18, 0x00	; 0
    2e3a:	30 e0       	ldi	r19, 0x00	; 0
    2e3c:	40 e2       	ldi	r20, 0x20	; 32
    2e3e:	51 e4       	ldi	r21, 0x41	; 65
    2e40:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2e44:	dc 01       	movw	r26, r24
    2e46:	cb 01       	movw	r24, r22
    2e48:	bc 01       	movw	r22, r24
    2e4a:	cd 01       	movw	r24, r26
    2e4c:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2e50:	dc 01       	movw	r26, r24
    2e52:	cb 01       	movw	r24, r22
    2e54:	9a a3       	std	Y+34, r25	; 0x22
    2e56:	89 a3       	std	Y+33, r24	; 0x21
    2e58:	0f c0       	rjmp	.+30     	; 0x2e78 <pick_box+0x1b6>
    2e5a:	80 e7       	ldi	r24, 0x70	; 112
    2e5c:	91 e0       	ldi	r25, 0x01	; 1
    2e5e:	98 a3       	std	Y+32, r25	; 0x20
    2e60:	8f 8f       	std	Y+31, r24	; 0x1f
    2e62:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2e64:	98 a1       	ldd	r25, Y+32	; 0x20
    2e66:	01 97       	sbiw	r24, 0x01	; 1
    2e68:	f1 f7       	brne	.-4      	; 0x2e66 <pick_box+0x1a4>
    2e6a:	98 a3       	std	Y+32, r25	; 0x20
    2e6c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e6e:	89 a1       	ldd	r24, Y+33	; 0x21
    2e70:	9a a1       	ldd	r25, Y+34	; 0x22
    2e72:	01 97       	sbiw	r24, 0x01	; 1
    2e74:	9a a3       	std	Y+34, r25	; 0x22
    2e76:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e78:	89 a1       	ldd	r24, Y+33	; 0x21
    2e7a:	9a a1       	ldd	r25, Y+34	; 0x22
    2e7c:	00 97       	sbiw	r24, 0x00	; 0
    2e7e:	69 f7       	brne	.-38     	; 0x2e5a <pick_box+0x198>
    2e80:	14 c0       	rjmp	.+40     	; 0x2eaa <pick_box+0x1e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e82:	6b a1       	ldd	r22, Y+35	; 0x23
    2e84:	7c a1       	ldd	r23, Y+36	; 0x24
    2e86:	8d a1       	ldd	r24, Y+37	; 0x25
    2e88:	9e a1       	ldd	r25, Y+38	; 0x26
    2e8a:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2e8e:	dc 01       	movw	r26, r24
    2e90:	cb 01       	movw	r24, r22
    2e92:	9a a3       	std	Y+34, r25	; 0x22
    2e94:	89 a3       	std	Y+33, r24	; 0x21
    2e96:	89 a1       	ldd	r24, Y+33	; 0x21
    2e98:	9a a1       	ldd	r25, Y+34	; 0x22
    2e9a:	9e 8f       	std	Y+30, r25	; 0x1e
    2e9c:	8d 8f       	std	Y+29, r24	; 0x1d
    2e9e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2ea0:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2ea2:	01 97       	sbiw	r24, 0x01	; 1
    2ea4:	f1 f7       	brne	.-4      	; 0x2ea2 <pick_box+0x1e0>
    2ea6:	9e 8f       	std	Y+30, r25	; 0x1e
    2ea8:	8d 8f       	std	Y+29, r24	; 0x1d
  _delay_ms(1000);
 
  servo_2(50);        //grip the box 
    2eaa:	82 e3       	ldi	r24, 0x32	; 50
    2eac:	0e 94 c6 11 	call	0x238c	; 0x238c <servo_2>
    2eb0:	80 e0       	ldi	r24, 0x00	; 0
    2eb2:	90 e0       	ldi	r25, 0x00	; 0
    2eb4:	aa e7       	ldi	r26, 0x7A	; 122
    2eb6:	b4 e4       	ldi	r27, 0x44	; 68
    2eb8:	89 8f       	std	Y+25, r24	; 0x19
    2eba:	9a 8f       	std	Y+26, r25	; 0x1a
    2ebc:	ab 8f       	std	Y+27, r26	; 0x1b
    2ebe:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ec0:	69 8d       	ldd	r22, Y+25	; 0x19
    2ec2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2ec4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2ec6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2ec8:	26 e6       	ldi	r18, 0x66	; 102
    2eca:	36 e6       	ldi	r19, 0x66	; 102
    2ecc:	46 e6       	ldi	r20, 0x66	; 102
    2ece:	55 e4       	ldi	r21, 0x45	; 69
    2ed0:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2ed4:	dc 01       	movw	r26, r24
    2ed6:	cb 01       	movw	r24, r22
    2ed8:	8d 8b       	std	Y+21, r24	; 0x15
    2eda:	9e 8b       	std	Y+22, r25	; 0x16
    2edc:	af 8b       	std	Y+23, r26	; 0x17
    2ede:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2ee0:	6d 89       	ldd	r22, Y+21	; 0x15
    2ee2:	7e 89       	ldd	r23, Y+22	; 0x16
    2ee4:	8f 89       	ldd	r24, Y+23	; 0x17
    2ee6:	98 8d       	ldd	r25, Y+24	; 0x18
    2ee8:	20 e0       	ldi	r18, 0x00	; 0
    2eea:	30 e0       	ldi	r19, 0x00	; 0
    2eec:	40 e8       	ldi	r20, 0x80	; 128
    2eee:	5f e3       	ldi	r21, 0x3F	; 63
    2ef0:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2ef4:	88 23       	and	r24, r24
    2ef6:	2c f4       	brge	.+10     	; 0x2f02 <pick_box+0x240>
		__ticks = 1;
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	9c 8b       	std	Y+20, r25	; 0x14
    2efe:	8b 8b       	std	Y+19, r24	; 0x13
    2f00:	3f c0       	rjmp	.+126    	; 0x2f80 <pick_box+0x2be>
	else if (__tmp > 65535)
    2f02:	6d 89       	ldd	r22, Y+21	; 0x15
    2f04:	7e 89       	ldd	r23, Y+22	; 0x16
    2f06:	8f 89       	ldd	r24, Y+23	; 0x17
    2f08:	98 8d       	ldd	r25, Y+24	; 0x18
    2f0a:	20 e0       	ldi	r18, 0x00	; 0
    2f0c:	3f ef       	ldi	r19, 0xFF	; 255
    2f0e:	4f e7       	ldi	r20, 0x7F	; 127
    2f10:	57 e4       	ldi	r21, 0x47	; 71
    2f12:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    2f16:	18 16       	cp	r1, r24
    2f18:	4c f5       	brge	.+82     	; 0x2f6c <pick_box+0x2aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f1a:	69 8d       	ldd	r22, Y+25	; 0x19
    2f1c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2f1e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2f20:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	40 e2       	ldi	r20, 0x20	; 32
    2f28:	51 e4       	ldi	r21, 0x41	; 65
    2f2a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2f2e:	dc 01       	movw	r26, r24
    2f30:	cb 01       	movw	r24, r22
    2f32:	bc 01       	movw	r22, r24
    2f34:	cd 01       	movw	r24, r26
    2f36:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2f3a:	dc 01       	movw	r26, r24
    2f3c:	cb 01       	movw	r24, r22
    2f3e:	9c 8b       	std	Y+20, r25	; 0x14
    2f40:	8b 8b       	std	Y+19, r24	; 0x13
    2f42:	0f c0       	rjmp	.+30     	; 0x2f62 <pick_box+0x2a0>
    2f44:	80 e7       	ldi	r24, 0x70	; 112
    2f46:	91 e0       	ldi	r25, 0x01	; 1
    2f48:	9a 8b       	std	Y+18, r25	; 0x12
    2f4a:	89 8b       	std	Y+17, r24	; 0x11
    2f4c:	89 89       	ldd	r24, Y+17	; 0x11
    2f4e:	9a 89       	ldd	r25, Y+18	; 0x12
    2f50:	01 97       	sbiw	r24, 0x01	; 1
    2f52:	f1 f7       	brne	.-4      	; 0x2f50 <pick_box+0x28e>
    2f54:	9a 8b       	std	Y+18, r25	; 0x12
    2f56:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2f58:	8b 89       	ldd	r24, Y+19	; 0x13
    2f5a:	9c 89       	ldd	r25, Y+20	; 0x14
    2f5c:	01 97       	sbiw	r24, 0x01	; 1
    2f5e:	9c 8b       	std	Y+20, r25	; 0x14
    2f60:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f62:	8b 89       	ldd	r24, Y+19	; 0x13
    2f64:	9c 89       	ldd	r25, Y+20	; 0x14
    2f66:	00 97       	sbiw	r24, 0x00	; 0
    2f68:	69 f7       	brne	.-38     	; 0x2f44 <pick_box+0x282>
    2f6a:	14 c0       	rjmp	.+40     	; 0x2f94 <pick_box+0x2d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2f6c:	6d 89       	ldd	r22, Y+21	; 0x15
    2f6e:	7e 89       	ldd	r23, Y+22	; 0x16
    2f70:	8f 89       	ldd	r24, Y+23	; 0x17
    2f72:	98 8d       	ldd	r25, Y+24	; 0x18
    2f74:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    2f78:	dc 01       	movw	r26, r24
    2f7a:	cb 01       	movw	r24, r22
    2f7c:	9c 8b       	std	Y+20, r25	; 0x14
    2f7e:	8b 8b       	std	Y+19, r24	; 0x13
    2f80:	8b 89       	ldd	r24, Y+19	; 0x13
    2f82:	9c 89       	ldd	r25, Y+20	; 0x14
    2f84:	98 8b       	std	Y+16, r25	; 0x10
    2f86:	8f 87       	std	Y+15, r24	; 0x0f
    2f88:	8f 85       	ldd	r24, Y+15	; 0x0f
    2f8a:	98 89       	ldd	r25, Y+16	; 0x10
    2f8c:	01 97       	sbiw	r24, 0x01	; 1
    2f8e:	f1 f7       	brne	.-4      	; 0x2f8c <pick_box+0x2ca>
    2f90:	98 8b       	std	Y+16, r25	; 0x10
    2f92:	8f 87       	std	Y+15, r24	; 0x0f
  _delay_ms(1000);
  servo_1(0);         //raise the arm
    2f94:	80 e0       	ldi	r24, 0x00	; 0
    2f96:	0e 94 78 11 	call	0x22f0	; 0x22f0 <servo_1>
    2f9a:	80 e0       	ldi	r24, 0x00	; 0
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	aa e7       	ldi	r26, 0x7A	; 122
    2fa0:	b4 e4       	ldi	r27, 0x44	; 68
    2fa2:	8b 87       	std	Y+11, r24	; 0x0b
    2fa4:	9c 87       	std	Y+12, r25	; 0x0c
    2fa6:	ad 87       	std	Y+13, r26	; 0x0d
    2fa8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2faa:	6b 85       	ldd	r22, Y+11	; 0x0b
    2fac:	7c 85       	ldd	r23, Y+12	; 0x0c
    2fae:	8d 85       	ldd	r24, Y+13	; 0x0d
    2fb0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2fb2:	26 e6       	ldi	r18, 0x66	; 102
    2fb4:	36 e6       	ldi	r19, 0x66	; 102
    2fb6:	46 e6       	ldi	r20, 0x66	; 102
    2fb8:	55 e4       	ldi	r21, 0x45	; 69
    2fba:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    2fbe:	dc 01       	movw	r26, r24
    2fc0:	cb 01       	movw	r24, r22
    2fc2:	8f 83       	std	Y+7, r24	; 0x07
    2fc4:	98 87       	std	Y+8, r25	; 0x08
    2fc6:	a9 87       	std	Y+9, r26	; 0x09
    2fc8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2fca:	6f 81       	ldd	r22, Y+7	; 0x07
    2fcc:	78 85       	ldd	r23, Y+8	; 0x08
    2fce:	89 85       	ldd	r24, Y+9	; 0x09
    2fd0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2fd2:	20 e0       	ldi	r18, 0x00	; 0
    2fd4:	30 e0       	ldi	r19, 0x00	; 0
    2fd6:	40 e8       	ldi	r20, 0x80	; 128
    2fd8:	5f e3       	ldi	r21, 0x3F	; 63
    2fda:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    2fde:	88 23       	and	r24, r24
    2fe0:	2c f4       	brge	.+10     	; 0x2fec <pick_box+0x32a>
		__ticks = 1;
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	9e 83       	std	Y+6, r25	; 0x06
    2fe8:	8d 83       	std	Y+5, r24	; 0x05
    2fea:	3f c0       	rjmp	.+126    	; 0x306a <pick_box+0x3a8>
	else if (__tmp > 65535)
    2fec:	6f 81       	ldd	r22, Y+7	; 0x07
    2fee:	78 85       	ldd	r23, Y+8	; 0x08
    2ff0:	89 85       	ldd	r24, Y+9	; 0x09
    2ff2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ff4:	20 e0       	ldi	r18, 0x00	; 0
    2ff6:	3f ef       	ldi	r19, 0xFF	; 255
    2ff8:	4f e7       	ldi	r20, 0x7F	; 127
    2ffa:	57 e4       	ldi	r21, 0x47	; 71
    2ffc:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3000:	18 16       	cp	r1, r24
    3002:	4c f5       	brge	.+82     	; 0x3056 <pick_box+0x394>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3004:	6b 85       	ldd	r22, Y+11	; 0x0b
    3006:	7c 85       	ldd	r23, Y+12	; 0x0c
    3008:	8d 85       	ldd	r24, Y+13	; 0x0d
    300a:	9e 85       	ldd	r25, Y+14	; 0x0e
    300c:	20 e0       	ldi	r18, 0x00	; 0
    300e:	30 e0       	ldi	r19, 0x00	; 0
    3010:	40 e2       	ldi	r20, 0x20	; 32
    3012:	51 e4       	ldi	r21, 0x41	; 65
    3014:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3018:	dc 01       	movw	r26, r24
    301a:	cb 01       	movw	r24, r22
    301c:	bc 01       	movw	r22, r24
    301e:	cd 01       	movw	r24, r26
    3020:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3024:	dc 01       	movw	r26, r24
    3026:	cb 01       	movw	r24, r22
    3028:	9e 83       	std	Y+6, r25	; 0x06
    302a:	8d 83       	std	Y+5, r24	; 0x05
    302c:	0f c0       	rjmp	.+30     	; 0x304c <pick_box+0x38a>
    302e:	80 e7       	ldi	r24, 0x70	; 112
    3030:	91 e0       	ldi	r25, 0x01	; 1
    3032:	9c 83       	std	Y+4, r25	; 0x04
    3034:	8b 83       	std	Y+3, r24	; 0x03
    3036:	8b 81       	ldd	r24, Y+3	; 0x03
    3038:	9c 81       	ldd	r25, Y+4	; 0x04
    303a:	01 97       	sbiw	r24, 0x01	; 1
    303c:	f1 f7       	brne	.-4      	; 0x303a <pick_box+0x378>
    303e:	9c 83       	std	Y+4, r25	; 0x04
    3040:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3042:	8d 81       	ldd	r24, Y+5	; 0x05
    3044:	9e 81       	ldd	r25, Y+6	; 0x06
    3046:	01 97       	sbiw	r24, 0x01	; 1
    3048:	9e 83       	std	Y+6, r25	; 0x06
    304a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    304c:	8d 81       	ldd	r24, Y+5	; 0x05
    304e:	9e 81       	ldd	r25, Y+6	; 0x06
    3050:	00 97       	sbiw	r24, 0x00	; 0
    3052:	69 f7       	brne	.-38     	; 0x302e <pick_box+0x36c>
    3054:	14 c0       	rjmp	.+40     	; 0x307e <pick_box+0x3bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3056:	6f 81       	ldd	r22, Y+7	; 0x07
    3058:	78 85       	ldd	r23, Y+8	; 0x08
    305a:	89 85       	ldd	r24, Y+9	; 0x09
    305c:	9a 85       	ldd	r25, Y+10	; 0x0a
    305e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3062:	dc 01       	movw	r26, r24
    3064:	cb 01       	movw	r24, r22
    3066:	9e 83       	std	Y+6, r25	; 0x06
    3068:	8d 83       	std	Y+5, r24	; 0x05
    306a:	8d 81       	ldd	r24, Y+5	; 0x05
    306c:	9e 81       	ldd	r25, Y+6	; 0x06
    306e:	9a 83       	std	Y+2, r25	; 0x02
    3070:	89 83       	std	Y+1, r24	; 0x01
    3072:	89 81       	ldd	r24, Y+1	; 0x01
    3074:	9a 81       	ldd	r25, Y+2	; 0x02
    3076:	01 97       	sbiw	r24, 0x01	; 1
    3078:	f1 f7       	brne	.-4      	; 0x3076 <pick_box+0x3b4>
    307a:	9a 83       	std	Y+2, r25	; 0x02
    307c:	89 83       	std	Y+1, r24	; 0x01
  _delay_ms(1000);

}
    307e:	e8 96       	adiw	r28, 0x38	; 56
    3080:	0f b6       	in	r0, 0x3f	; 63
    3082:	f8 94       	cli
    3084:	de bf       	out	0x3e, r29	; 62
    3086:	0f be       	out	0x3f, r0	; 63
    3088:	cd bf       	out	0x3d, r28	; 61
    308a:	cf 91       	pop	r28
    308c:	df 91       	pop	r29
    308e:	08 95       	ret

00003090 <keep_box>:
void keep_box()
{
    3090:	0f 93       	push	r16
    3092:	1f 93       	push	r17
    3094:	df 93       	push	r29
    3096:	cf 93       	push	r28
    3098:	cd b7       	in	r28, 0x3d	; 61
    309a:	de b7       	in	r29, 0x3e	; 62
    309c:	c6 54       	subi	r28, 0x46	; 70
    309e:	d0 40       	sbci	r29, 0x00	; 0
    30a0:	0f b6       	in	r0, 0x3f	; 63
    30a2:	f8 94       	cli
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	0f be       	out	0x3f, r0	; 63
    30a8:	cd bf       	out	0x3d, r28	; 61
   servo_1(53);
    30aa:	85 e3       	ldi	r24, 0x35	; 53
    30ac:	0e 94 78 11 	call	0x22f0	; 0x22f0 <servo_1>
    30b0:	fe 01       	movw	r30, r28
    30b2:	ed 5b       	subi	r30, 0xBD	; 189
    30b4:	ff 4f       	sbci	r31, 0xFF	; 255
    30b6:	80 e0       	ldi	r24, 0x00	; 0
    30b8:	90 e0       	ldi	r25, 0x00	; 0
    30ba:	aa e7       	ldi	r26, 0x7A	; 122
    30bc:	b4 e4       	ldi	r27, 0x44	; 68
    30be:	80 83       	st	Z, r24
    30c0:	91 83       	std	Z+1, r25	; 0x01
    30c2:	a2 83       	std	Z+2, r26	; 0x02
    30c4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30c6:	8e 01       	movw	r16, r28
    30c8:	01 5c       	subi	r16, 0xC1	; 193
    30ca:	1f 4f       	sbci	r17, 0xFF	; 255
    30cc:	fe 01       	movw	r30, r28
    30ce:	ed 5b       	subi	r30, 0xBD	; 189
    30d0:	ff 4f       	sbci	r31, 0xFF	; 255
    30d2:	60 81       	ld	r22, Z
    30d4:	71 81       	ldd	r23, Z+1	; 0x01
    30d6:	82 81       	ldd	r24, Z+2	; 0x02
    30d8:	93 81       	ldd	r25, Z+3	; 0x03
    30da:	26 e6       	ldi	r18, 0x66	; 102
    30dc:	36 e6       	ldi	r19, 0x66	; 102
    30de:	46 e6       	ldi	r20, 0x66	; 102
    30e0:	55 e4       	ldi	r21, 0x45	; 69
    30e2:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    30e6:	dc 01       	movw	r26, r24
    30e8:	cb 01       	movw	r24, r22
    30ea:	f8 01       	movw	r30, r16
    30ec:	80 83       	st	Z, r24
    30ee:	91 83       	std	Z+1, r25	; 0x01
    30f0:	a2 83       	std	Z+2, r26	; 0x02
    30f2:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    30f4:	fe 01       	movw	r30, r28
    30f6:	ff 96       	adiw	r30, 0x3f	; 63
    30f8:	60 81       	ld	r22, Z
    30fa:	71 81       	ldd	r23, Z+1	; 0x01
    30fc:	82 81       	ldd	r24, Z+2	; 0x02
    30fe:	93 81       	ldd	r25, Z+3	; 0x03
    3100:	20 e0       	ldi	r18, 0x00	; 0
    3102:	30 e0       	ldi	r19, 0x00	; 0
    3104:	40 e8       	ldi	r20, 0x80	; 128
    3106:	5f e3       	ldi	r21, 0x3F	; 63
    3108:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    310c:	88 23       	and	r24, r24
    310e:	2c f4       	brge	.+10     	; 0x311a <keep_box+0x8a>
		__ticks = 1;
    3110:	81 e0       	ldi	r24, 0x01	; 1
    3112:	90 e0       	ldi	r25, 0x00	; 0
    3114:	9e af       	std	Y+62, r25	; 0x3e
    3116:	8d af       	std	Y+61, r24	; 0x3d
    3118:	46 c0       	rjmp	.+140    	; 0x31a6 <keep_box+0x116>
	else if (__tmp > 65535)
    311a:	fe 01       	movw	r30, r28
    311c:	ff 96       	adiw	r30, 0x3f	; 63
    311e:	60 81       	ld	r22, Z
    3120:	71 81       	ldd	r23, Z+1	; 0x01
    3122:	82 81       	ldd	r24, Z+2	; 0x02
    3124:	93 81       	ldd	r25, Z+3	; 0x03
    3126:	20 e0       	ldi	r18, 0x00	; 0
    3128:	3f ef       	ldi	r19, 0xFF	; 255
    312a:	4f e7       	ldi	r20, 0x7F	; 127
    312c:	57 e4       	ldi	r21, 0x47	; 71
    312e:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3132:	18 16       	cp	r1, r24
    3134:	64 f5       	brge	.+88     	; 0x318e <keep_box+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3136:	fe 01       	movw	r30, r28
    3138:	ed 5b       	subi	r30, 0xBD	; 189
    313a:	ff 4f       	sbci	r31, 0xFF	; 255
    313c:	60 81       	ld	r22, Z
    313e:	71 81       	ldd	r23, Z+1	; 0x01
    3140:	82 81       	ldd	r24, Z+2	; 0x02
    3142:	93 81       	ldd	r25, Z+3	; 0x03
    3144:	20 e0       	ldi	r18, 0x00	; 0
    3146:	30 e0       	ldi	r19, 0x00	; 0
    3148:	40 e2       	ldi	r20, 0x20	; 32
    314a:	51 e4       	ldi	r21, 0x41	; 65
    314c:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3150:	dc 01       	movw	r26, r24
    3152:	cb 01       	movw	r24, r22
    3154:	bc 01       	movw	r22, r24
    3156:	cd 01       	movw	r24, r26
    3158:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    315c:	dc 01       	movw	r26, r24
    315e:	cb 01       	movw	r24, r22
    3160:	9e af       	std	Y+62, r25	; 0x3e
    3162:	8d af       	std	Y+61, r24	; 0x3d
    3164:	0f c0       	rjmp	.+30     	; 0x3184 <keep_box+0xf4>
    3166:	80 e7       	ldi	r24, 0x70	; 112
    3168:	91 e0       	ldi	r25, 0x01	; 1
    316a:	9c af       	std	Y+60, r25	; 0x3c
    316c:	8b af       	std	Y+59, r24	; 0x3b
    316e:	8b ad       	ldd	r24, Y+59	; 0x3b
    3170:	9c ad       	ldd	r25, Y+60	; 0x3c
    3172:	01 97       	sbiw	r24, 0x01	; 1
    3174:	f1 f7       	brne	.-4      	; 0x3172 <keep_box+0xe2>
    3176:	9c af       	std	Y+60, r25	; 0x3c
    3178:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    317a:	8d ad       	ldd	r24, Y+61	; 0x3d
    317c:	9e ad       	ldd	r25, Y+62	; 0x3e
    317e:	01 97       	sbiw	r24, 0x01	; 1
    3180:	9e af       	std	Y+62, r25	; 0x3e
    3182:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3184:	8d ad       	ldd	r24, Y+61	; 0x3d
    3186:	9e ad       	ldd	r25, Y+62	; 0x3e
    3188:	00 97       	sbiw	r24, 0x00	; 0
    318a:	69 f7       	brne	.-38     	; 0x3166 <keep_box+0xd6>
    318c:	16 c0       	rjmp	.+44     	; 0x31ba <keep_box+0x12a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    318e:	fe 01       	movw	r30, r28
    3190:	ff 96       	adiw	r30, 0x3f	; 63
    3192:	60 81       	ld	r22, Z
    3194:	71 81       	ldd	r23, Z+1	; 0x01
    3196:	82 81       	ldd	r24, Z+2	; 0x02
    3198:	93 81       	ldd	r25, Z+3	; 0x03
    319a:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    319e:	dc 01       	movw	r26, r24
    31a0:	cb 01       	movw	r24, r22
    31a2:	9e af       	std	Y+62, r25	; 0x3e
    31a4:	8d af       	std	Y+61, r24	; 0x3d
    31a6:	8d ad       	ldd	r24, Y+61	; 0x3d
    31a8:	9e ad       	ldd	r25, Y+62	; 0x3e
    31aa:	9a af       	std	Y+58, r25	; 0x3a
    31ac:	89 af       	std	Y+57, r24	; 0x39
    31ae:	89 ad       	ldd	r24, Y+57	; 0x39
    31b0:	9a ad       	ldd	r25, Y+58	; 0x3a
    31b2:	01 97       	sbiw	r24, 0x01	; 1
    31b4:	f1 f7       	brne	.-4      	; 0x31b2 <keep_box+0x122>
    31b6:	9a af       	std	Y+58, r25	; 0x3a
    31b8:	89 af       	std	Y+57, r24	; 0x39
   _delay_ms(1000);		//bring it down (set the box a little up from the surface)
   servo_2(35);
    31ba:	83 e2       	ldi	r24, 0x23	; 35
    31bc:	0e 94 c6 11 	call	0x238c	; 0x238c <servo_2>
    31c0:	80 e0       	ldi	r24, 0x00	; 0
    31c2:	90 e0       	ldi	r25, 0x00	; 0
    31c4:	aa e7       	ldi	r26, 0x7A	; 122
    31c6:	b4 e4       	ldi	r27, 0x44	; 68
    31c8:	8d ab       	std	Y+53, r24	; 0x35
    31ca:	9e ab       	std	Y+54, r25	; 0x36
    31cc:	af ab       	std	Y+55, r26	; 0x37
    31ce:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    31d0:	6d a9       	ldd	r22, Y+53	; 0x35
    31d2:	7e a9       	ldd	r23, Y+54	; 0x36
    31d4:	8f a9       	ldd	r24, Y+55	; 0x37
    31d6:	98 ad       	ldd	r25, Y+56	; 0x38
    31d8:	26 e6       	ldi	r18, 0x66	; 102
    31da:	36 e6       	ldi	r19, 0x66	; 102
    31dc:	46 e6       	ldi	r20, 0x66	; 102
    31de:	55 e4       	ldi	r21, 0x45	; 69
    31e0:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    31e4:	dc 01       	movw	r26, r24
    31e6:	cb 01       	movw	r24, r22
    31e8:	89 ab       	std	Y+49, r24	; 0x31
    31ea:	9a ab       	std	Y+50, r25	; 0x32
    31ec:	ab ab       	std	Y+51, r26	; 0x33
    31ee:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    31f0:	69 a9       	ldd	r22, Y+49	; 0x31
    31f2:	7a a9       	ldd	r23, Y+50	; 0x32
    31f4:	8b a9       	ldd	r24, Y+51	; 0x33
    31f6:	9c a9       	ldd	r25, Y+52	; 0x34
    31f8:	20 e0       	ldi	r18, 0x00	; 0
    31fa:	30 e0       	ldi	r19, 0x00	; 0
    31fc:	40 e8       	ldi	r20, 0x80	; 128
    31fe:	5f e3       	ldi	r21, 0x3F	; 63
    3200:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    3204:	88 23       	and	r24, r24
    3206:	2c f4       	brge	.+10     	; 0x3212 <keep_box+0x182>
		__ticks = 1;
    3208:	81 e0       	ldi	r24, 0x01	; 1
    320a:	90 e0       	ldi	r25, 0x00	; 0
    320c:	98 ab       	std	Y+48, r25	; 0x30
    320e:	8f a7       	std	Y+47, r24	; 0x2f
    3210:	3f c0       	rjmp	.+126    	; 0x3290 <keep_box+0x200>
	else if (__tmp > 65535)
    3212:	69 a9       	ldd	r22, Y+49	; 0x31
    3214:	7a a9       	ldd	r23, Y+50	; 0x32
    3216:	8b a9       	ldd	r24, Y+51	; 0x33
    3218:	9c a9       	ldd	r25, Y+52	; 0x34
    321a:	20 e0       	ldi	r18, 0x00	; 0
    321c:	3f ef       	ldi	r19, 0xFF	; 255
    321e:	4f e7       	ldi	r20, 0x7F	; 127
    3220:	57 e4       	ldi	r21, 0x47	; 71
    3222:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3226:	18 16       	cp	r1, r24
    3228:	4c f5       	brge	.+82     	; 0x327c <keep_box+0x1ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    322a:	6d a9       	ldd	r22, Y+53	; 0x35
    322c:	7e a9       	ldd	r23, Y+54	; 0x36
    322e:	8f a9       	ldd	r24, Y+55	; 0x37
    3230:	98 ad       	ldd	r25, Y+56	; 0x38
    3232:	20 e0       	ldi	r18, 0x00	; 0
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	40 e2       	ldi	r20, 0x20	; 32
    3238:	51 e4       	ldi	r21, 0x41	; 65
    323a:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    323e:	dc 01       	movw	r26, r24
    3240:	cb 01       	movw	r24, r22
    3242:	bc 01       	movw	r22, r24
    3244:	cd 01       	movw	r24, r26
    3246:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    324a:	dc 01       	movw	r26, r24
    324c:	cb 01       	movw	r24, r22
    324e:	98 ab       	std	Y+48, r25	; 0x30
    3250:	8f a7       	std	Y+47, r24	; 0x2f
    3252:	0f c0       	rjmp	.+30     	; 0x3272 <keep_box+0x1e2>
    3254:	80 e7       	ldi	r24, 0x70	; 112
    3256:	91 e0       	ldi	r25, 0x01	; 1
    3258:	9e a7       	std	Y+46, r25	; 0x2e
    325a:	8d a7       	std	Y+45, r24	; 0x2d
    325c:	8d a5       	ldd	r24, Y+45	; 0x2d
    325e:	9e a5       	ldd	r25, Y+46	; 0x2e
    3260:	01 97       	sbiw	r24, 0x01	; 1
    3262:	f1 f7       	brne	.-4      	; 0x3260 <keep_box+0x1d0>
    3264:	9e a7       	std	Y+46, r25	; 0x2e
    3266:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3268:	8f a5       	ldd	r24, Y+47	; 0x2f
    326a:	98 a9       	ldd	r25, Y+48	; 0x30
    326c:	01 97       	sbiw	r24, 0x01	; 1
    326e:	98 ab       	std	Y+48, r25	; 0x30
    3270:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3272:	8f a5       	ldd	r24, Y+47	; 0x2f
    3274:	98 a9       	ldd	r25, Y+48	; 0x30
    3276:	00 97       	sbiw	r24, 0x00	; 0
    3278:	69 f7       	brne	.-38     	; 0x3254 <keep_box+0x1c4>
    327a:	14 c0       	rjmp	.+40     	; 0x32a4 <keep_box+0x214>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    327c:	69 a9       	ldd	r22, Y+49	; 0x31
    327e:	7a a9       	ldd	r23, Y+50	; 0x32
    3280:	8b a9       	ldd	r24, Y+51	; 0x33
    3282:	9c a9       	ldd	r25, Y+52	; 0x34
    3284:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3288:	dc 01       	movw	r26, r24
    328a:	cb 01       	movw	r24, r22
    328c:	98 ab       	std	Y+48, r25	; 0x30
    328e:	8f a7       	std	Y+47, r24	; 0x2f
    3290:	8f a5       	ldd	r24, Y+47	; 0x2f
    3292:	98 a9       	ldd	r25, Y+48	; 0x30
    3294:	9c a7       	std	Y+44, r25	; 0x2c
    3296:	8b a7       	std	Y+43, r24	; 0x2b
    3298:	8b a5       	ldd	r24, Y+43	; 0x2b
    329a:	9c a5       	ldd	r25, Y+44	; 0x2c
    329c:	01 97       	sbiw	r24, 0x01	; 1
    329e:	f1 f7       	brne	.-4      	; 0x329c <keep_box+0x20c>
    32a0:	9c a7       	std	Y+44, r25	; 0x2c
    32a2:	8b a7       	std	Y+43, r24	; 0x2b
   _delay_ms(1000);		//release the gripper only at a lesser angle first and then increase the angle later)
  

    servo_2(0);
    32a4:	80 e0       	ldi	r24, 0x00	; 0
    32a6:	0e 94 c6 11 	call	0x238c	; 0x238c <servo_2>
    32aa:	80 e0       	ldi	r24, 0x00	; 0
    32ac:	90 e0       	ldi	r25, 0x00	; 0
    32ae:	aa e7       	ldi	r26, 0x7A	; 122
    32b0:	b4 e4       	ldi	r27, 0x44	; 68
    32b2:	8f a3       	std	Y+39, r24	; 0x27
    32b4:	98 a7       	std	Y+40, r25	; 0x28
    32b6:	a9 a7       	std	Y+41, r26	; 0x29
    32b8:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    32ba:	6f a1       	ldd	r22, Y+39	; 0x27
    32bc:	78 a5       	ldd	r23, Y+40	; 0x28
    32be:	89 a5       	ldd	r24, Y+41	; 0x29
    32c0:	9a a5       	ldd	r25, Y+42	; 0x2a
    32c2:	26 e6       	ldi	r18, 0x66	; 102
    32c4:	36 e6       	ldi	r19, 0x66	; 102
    32c6:	46 e6       	ldi	r20, 0x66	; 102
    32c8:	55 e4       	ldi	r21, 0x45	; 69
    32ca:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    32ce:	dc 01       	movw	r26, r24
    32d0:	cb 01       	movw	r24, r22
    32d2:	8b a3       	std	Y+35, r24	; 0x23
    32d4:	9c a3       	std	Y+36, r25	; 0x24
    32d6:	ad a3       	std	Y+37, r26	; 0x25
    32d8:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    32da:	6b a1       	ldd	r22, Y+35	; 0x23
    32dc:	7c a1       	ldd	r23, Y+36	; 0x24
    32de:	8d a1       	ldd	r24, Y+37	; 0x25
    32e0:	9e a1       	ldd	r25, Y+38	; 0x26
    32e2:	20 e0       	ldi	r18, 0x00	; 0
    32e4:	30 e0       	ldi	r19, 0x00	; 0
    32e6:	40 e8       	ldi	r20, 0x80	; 128
    32e8:	5f e3       	ldi	r21, 0x3F	; 63
    32ea:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    32ee:	88 23       	and	r24, r24
    32f0:	2c f4       	brge	.+10     	; 0x32fc <keep_box+0x26c>
		__ticks = 1;
    32f2:	81 e0       	ldi	r24, 0x01	; 1
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	9a a3       	std	Y+34, r25	; 0x22
    32f8:	89 a3       	std	Y+33, r24	; 0x21
    32fa:	3f c0       	rjmp	.+126    	; 0x337a <keep_box+0x2ea>
	else if (__tmp > 65535)
    32fc:	6b a1       	ldd	r22, Y+35	; 0x23
    32fe:	7c a1       	ldd	r23, Y+36	; 0x24
    3300:	8d a1       	ldd	r24, Y+37	; 0x25
    3302:	9e a1       	ldd	r25, Y+38	; 0x26
    3304:	20 e0       	ldi	r18, 0x00	; 0
    3306:	3f ef       	ldi	r19, 0xFF	; 255
    3308:	4f e7       	ldi	r20, 0x7F	; 127
    330a:	57 e4       	ldi	r21, 0x47	; 71
    330c:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3310:	18 16       	cp	r1, r24
    3312:	4c f5       	brge	.+82     	; 0x3366 <keep_box+0x2d6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3314:	6f a1       	ldd	r22, Y+39	; 0x27
    3316:	78 a5       	ldd	r23, Y+40	; 0x28
    3318:	89 a5       	ldd	r24, Y+41	; 0x29
    331a:	9a a5       	ldd	r25, Y+42	; 0x2a
    331c:	20 e0       	ldi	r18, 0x00	; 0
    331e:	30 e0       	ldi	r19, 0x00	; 0
    3320:	40 e2       	ldi	r20, 0x20	; 32
    3322:	51 e4       	ldi	r21, 0x41	; 65
    3324:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3328:	dc 01       	movw	r26, r24
    332a:	cb 01       	movw	r24, r22
    332c:	bc 01       	movw	r22, r24
    332e:	cd 01       	movw	r24, r26
    3330:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3334:	dc 01       	movw	r26, r24
    3336:	cb 01       	movw	r24, r22
    3338:	9a a3       	std	Y+34, r25	; 0x22
    333a:	89 a3       	std	Y+33, r24	; 0x21
    333c:	0f c0       	rjmp	.+30     	; 0x335c <keep_box+0x2cc>
    333e:	80 e7       	ldi	r24, 0x70	; 112
    3340:	91 e0       	ldi	r25, 0x01	; 1
    3342:	98 a3       	std	Y+32, r25	; 0x20
    3344:	8f 8f       	std	Y+31, r24	; 0x1f
    3346:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3348:	98 a1       	ldd	r25, Y+32	; 0x20
    334a:	01 97       	sbiw	r24, 0x01	; 1
    334c:	f1 f7       	brne	.-4      	; 0x334a <keep_box+0x2ba>
    334e:	98 a3       	std	Y+32, r25	; 0x20
    3350:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3352:	89 a1       	ldd	r24, Y+33	; 0x21
    3354:	9a a1       	ldd	r25, Y+34	; 0x22
    3356:	01 97       	sbiw	r24, 0x01	; 1
    3358:	9a a3       	std	Y+34, r25	; 0x22
    335a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    335c:	89 a1       	ldd	r24, Y+33	; 0x21
    335e:	9a a1       	ldd	r25, Y+34	; 0x22
    3360:	00 97       	sbiw	r24, 0x00	; 0
    3362:	69 f7       	brne	.-38     	; 0x333e <keep_box+0x2ae>
    3364:	14 c0       	rjmp	.+40     	; 0x338e <keep_box+0x2fe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3366:	6b a1       	ldd	r22, Y+35	; 0x23
    3368:	7c a1       	ldd	r23, Y+36	; 0x24
    336a:	8d a1       	ldd	r24, Y+37	; 0x25
    336c:	9e a1       	ldd	r25, Y+38	; 0x26
    336e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3372:	dc 01       	movw	r26, r24
    3374:	cb 01       	movw	r24, r22
    3376:	9a a3       	std	Y+34, r25	; 0x22
    3378:	89 a3       	std	Y+33, r24	; 0x21
    337a:	89 a1       	ldd	r24, Y+33	; 0x21
    337c:	9a a1       	ldd	r25, Y+34	; 0x22
    337e:	9e 8f       	std	Y+30, r25	; 0x1e
    3380:	8d 8f       	std	Y+29, r24	; 0x1d
    3382:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3384:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3386:	01 97       	sbiw	r24, 0x01	; 1
    3388:	f1 f7       	brne	.-4      	; 0x3386 <keep_box+0x2f6>
    338a:	9e 8f       	std	Y+30, r25	; 0x1e
    338c:	8d 8f       	std	Y+29, r24	; 0x1d
   _delay_ms(1000);
   servo_1(0);			//bring the arm back	
    338e:	80 e0       	ldi	r24, 0x00	; 0
    3390:	0e 94 78 11 	call	0x22f0	; 0x22f0 <servo_1>
    3394:	80 e0       	ldi	r24, 0x00	; 0
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	aa e7       	ldi	r26, 0x7A	; 122
    339a:	b4 e4       	ldi	r27, 0x44	; 68
    339c:	89 8f       	std	Y+25, r24	; 0x19
    339e:	9a 8f       	std	Y+26, r25	; 0x1a
    33a0:	ab 8f       	std	Y+27, r26	; 0x1b
    33a2:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33a4:	69 8d       	ldd	r22, Y+25	; 0x19
    33a6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    33a8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    33aa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    33ac:	26 e6       	ldi	r18, 0x66	; 102
    33ae:	36 e6       	ldi	r19, 0x66	; 102
    33b0:	46 e6       	ldi	r20, 0x66	; 102
    33b2:	55 e4       	ldi	r21, 0x45	; 69
    33b4:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    33b8:	dc 01       	movw	r26, r24
    33ba:	cb 01       	movw	r24, r22
    33bc:	8d 8b       	std	Y+21, r24	; 0x15
    33be:	9e 8b       	std	Y+22, r25	; 0x16
    33c0:	af 8b       	std	Y+23, r26	; 0x17
    33c2:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    33c4:	6d 89       	ldd	r22, Y+21	; 0x15
    33c6:	7e 89       	ldd	r23, Y+22	; 0x16
    33c8:	8f 89       	ldd	r24, Y+23	; 0x17
    33ca:	98 8d       	ldd	r25, Y+24	; 0x18
    33cc:	20 e0       	ldi	r18, 0x00	; 0
    33ce:	30 e0       	ldi	r19, 0x00	; 0
    33d0:	40 e8       	ldi	r20, 0x80	; 128
    33d2:	5f e3       	ldi	r21, 0x3F	; 63
    33d4:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    33d8:	88 23       	and	r24, r24
    33da:	2c f4       	brge	.+10     	; 0x33e6 <keep_box+0x356>
		__ticks = 1;
    33dc:	81 e0       	ldi	r24, 0x01	; 1
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	9c 8b       	std	Y+20, r25	; 0x14
    33e2:	8b 8b       	std	Y+19, r24	; 0x13
    33e4:	3f c0       	rjmp	.+126    	; 0x3464 <keep_box+0x3d4>
	else if (__tmp > 65535)
    33e6:	6d 89       	ldd	r22, Y+21	; 0x15
    33e8:	7e 89       	ldd	r23, Y+22	; 0x16
    33ea:	8f 89       	ldd	r24, Y+23	; 0x17
    33ec:	98 8d       	ldd	r25, Y+24	; 0x18
    33ee:	20 e0       	ldi	r18, 0x00	; 0
    33f0:	3f ef       	ldi	r19, 0xFF	; 255
    33f2:	4f e7       	ldi	r20, 0x7F	; 127
    33f4:	57 e4       	ldi	r21, 0x47	; 71
    33f6:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    33fa:	18 16       	cp	r1, r24
    33fc:	4c f5       	brge	.+82     	; 0x3450 <keep_box+0x3c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33fe:	69 8d       	ldd	r22, Y+25	; 0x19
    3400:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3402:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3404:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3406:	20 e0       	ldi	r18, 0x00	; 0
    3408:	30 e0       	ldi	r19, 0x00	; 0
    340a:	40 e2       	ldi	r20, 0x20	; 32
    340c:	51 e4       	ldi	r21, 0x41	; 65
    340e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3412:	dc 01       	movw	r26, r24
    3414:	cb 01       	movw	r24, r22
    3416:	bc 01       	movw	r22, r24
    3418:	cd 01       	movw	r24, r26
    341a:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    341e:	dc 01       	movw	r26, r24
    3420:	cb 01       	movw	r24, r22
    3422:	9c 8b       	std	Y+20, r25	; 0x14
    3424:	8b 8b       	std	Y+19, r24	; 0x13
    3426:	0f c0       	rjmp	.+30     	; 0x3446 <keep_box+0x3b6>
    3428:	80 e7       	ldi	r24, 0x70	; 112
    342a:	91 e0       	ldi	r25, 0x01	; 1
    342c:	9a 8b       	std	Y+18, r25	; 0x12
    342e:	89 8b       	std	Y+17, r24	; 0x11
    3430:	89 89       	ldd	r24, Y+17	; 0x11
    3432:	9a 89       	ldd	r25, Y+18	; 0x12
    3434:	01 97       	sbiw	r24, 0x01	; 1
    3436:	f1 f7       	brne	.-4      	; 0x3434 <keep_box+0x3a4>
    3438:	9a 8b       	std	Y+18, r25	; 0x12
    343a:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    343c:	8b 89       	ldd	r24, Y+19	; 0x13
    343e:	9c 89       	ldd	r25, Y+20	; 0x14
    3440:	01 97       	sbiw	r24, 0x01	; 1
    3442:	9c 8b       	std	Y+20, r25	; 0x14
    3444:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3446:	8b 89       	ldd	r24, Y+19	; 0x13
    3448:	9c 89       	ldd	r25, Y+20	; 0x14
    344a:	00 97       	sbiw	r24, 0x00	; 0
    344c:	69 f7       	brne	.-38     	; 0x3428 <keep_box+0x398>
    344e:	14 c0       	rjmp	.+40     	; 0x3478 <keep_box+0x3e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3450:	6d 89       	ldd	r22, Y+21	; 0x15
    3452:	7e 89       	ldd	r23, Y+22	; 0x16
    3454:	8f 89       	ldd	r24, Y+23	; 0x17
    3456:	98 8d       	ldd	r25, Y+24	; 0x18
    3458:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    345c:	dc 01       	movw	r26, r24
    345e:	cb 01       	movw	r24, r22
    3460:	9c 8b       	std	Y+20, r25	; 0x14
    3462:	8b 8b       	std	Y+19, r24	; 0x13
    3464:	8b 89       	ldd	r24, Y+19	; 0x13
    3466:	9c 89       	ldd	r25, Y+20	; 0x14
    3468:	98 8b       	std	Y+16, r25	; 0x10
    346a:	8f 87       	std	Y+15, r24	; 0x0f
    346c:	8f 85       	ldd	r24, Y+15	; 0x0f
    346e:	98 89       	ldd	r25, Y+16	; 0x10
    3470:	01 97       	sbiw	r24, 0x01	; 1
    3472:	f1 f7       	brne	.-4      	; 0x3470 <keep_box+0x3e0>
    3474:	98 8b       	std	Y+16, r25	; 0x10
    3476:	8f 87       	std	Y+15, r24	; 0x0f
   _delay_ms(1000);
   servo_2(90);
    3478:	8a e5       	ldi	r24, 0x5A	; 90
    347a:	0e 94 c6 11 	call	0x238c	; 0x238c <servo_2>
    347e:	80 e0       	ldi	r24, 0x00	; 0
    3480:	90 e0       	ldi	r25, 0x00	; 0
    3482:	aa e7       	ldi	r26, 0x7A	; 122
    3484:	b4 e4       	ldi	r27, 0x44	; 68
    3486:	8b 87       	std	Y+11, r24	; 0x0b
    3488:	9c 87       	std	Y+12, r25	; 0x0c
    348a:	ad 87       	std	Y+13, r26	; 0x0d
    348c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    348e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3490:	7c 85       	ldd	r23, Y+12	; 0x0c
    3492:	8d 85       	ldd	r24, Y+13	; 0x0d
    3494:	9e 85       	ldd	r25, Y+14	; 0x0e
    3496:	26 e6       	ldi	r18, 0x66	; 102
    3498:	36 e6       	ldi	r19, 0x66	; 102
    349a:	46 e6       	ldi	r20, 0x66	; 102
    349c:	55 e4       	ldi	r21, 0x45	; 69
    349e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    34a2:	dc 01       	movw	r26, r24
    34a4:	cb 01       	movw	r24, r22
    34a6:	8f 83       	std	Y+7, r24	; 0x07
    34a8:	98 87       	std	Y+8, r25	; 0x08
    34aa:	a9 87       	std	Y+9, r26	; 0x09
    34ac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    34ae:	6f 81       	ldd	r22, Y+7	; 0x07
    34b0:	78 85       	ldd	r23, Y+8	; 0x08
    34b2:	89 85       	ldd	r24, Y+9	; 0x09
    34b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    34b6:	20 e0       	ldi	r18, 0x00	; 0
    34b8:	30 e0       	ldi	r19, 0x00	; 0
    34ba:	40 e8       	ldi	r20, 0x80	; 128
    34bc:	5f e3       	ldi	r21, 0x3F	; 63
    34be:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    34c2:	88 23       	and	r24, r24
    34c4:	2c f4       	brge	.+10     	; 0x34d0 <keep_box+0x440>
		__ticks = 1;
    34c6:	81 e0       	ldi	r24, 0x01	; 1
    34c8:	90 e0       	ldi	r25, 0x00	; 0
    34ca:	9e 83       	std	Y+6, r25	; 0x06
    34cc:	8d 83       	std	Y+5, r24	; 0x05
    34ce:	3f c0       	rjmp	.+126    	; 0x354e <keep_box+0x4be>
	else if (__tmp > 65535)
    34d0:	6f 81       	ldd	r22, Y+7	; 0x07
    34d2:	78 85       	ldd	r23, Y+8	; 0x08
    34d4:	89 85       	ldd	r24, Y+9	; 0x09
    34d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    34d8:	20 e0       	ldi	r18, 0x00	; 0
    34da:	3f ef       	ldi	r19, 0xFF	; 255
    34dc:	4f e7       	ldi	r20, 0x7F	; 127
    34de:	57 e4       	ldi	r21, 0x47	; 71
    34e0:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    34e4:	18 16       	cp	r1, r24
    34e6:	4c f5       	brge	.+82     	; 0x353a <keep_box+0x4aa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    34ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    34ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    34ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    34f0:	20 e0       	ldi	r18, 0x00	; 0
    34f2:	30 e0       	ldi	r19, 0x00	; 0
    34f4:	40 e2       	ldi	r20, 0x20	; 32
    34f6:	51 e4       	ldi	r21, 0x41	; 65
    34f8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    34fc:	dc 01       	movw	r26, r24
    34fe:	cb 01       	movw	r24, r22
    3500:	bc 01       	movw	r22, r24
    3502:	cd 01       	movw	r24, r26
    3504:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3508:	dc 01       	movw	r26, r24
    350a:	cb 01       	movw	r24, r22
    350c:	9e 83       	std	Y+6, r25	; 0x06
    350e:	8d 83       	std	Y+5, r24	; 0x05
    3510:	0f c0       	rjmp	.+30     	; 0x3530 <keep_box+0x4a0>
    3512:	80 e7       	ldi	r24, 0x70	; 112
    3514:	91 e0       	ldi	r25, 0x01	; 1
    3516:	9c 83       	std	Y+4, r25	; 0x04
    3518:	8b 83       	std	Y+3, r24	; 0x03
    351a:	8b 81       	ldd	r24, Y+3	; 0x03
    351c:	9c 81       	ldd	r25, Y+4	; 0x04
    351e:	01 97       	sbiw	r24, 0x01	; 1
    3520:	f1 f7       	brne	.-4      	; 0x351e <keep_box+0x48e>
    3522:	9c 83       	std	Y+4, r25	; 0x04
    3524:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3526:	8d 81       	ldd	r24, Y+5	; 0x05
    3528:	9e 81       	ldd	r25, Y+6	; 0x06
    352a:	01 97       	sbiw	r24, 0x01	; 1
    352c:	9e 83       	std	Y+6, r25	; 0x06
    352e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3530:	8d 81       	ldd	r24, Y+5	; 0x05
    3532:	9e 81       	ldd	r25, Y+6	; 0x06
    3534:	00 97       	sbiw	r24, 0x00	; 0
    3536:	69 f7       	brne	.-38     	; 0x3512 <keep_box+0x482>
    3538:	14 c0       	rjmp	.+40     	; 0x3562 <keep_box+0x4d2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    353a:	6f 81       	ldd	r22, Y+7	; 0x07
    353c:	78 85       	ldd	r23, Y+8	; 0x08
    353e:	89 85       	ldd	r24, Y+9	; 0x09
    3540:	9a 85       	ldd	r25, Y+10	; 0x0a
    3542:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3546:	dc 01       	movw	r26, r24
    3548:	cb 01       	movw	r24, r22
    354a:	9e 83       	std	Y+6, r25	; 0x06
    354c:	8d 83       	std	Y+5, r24	; 0x05
    354e:	8d 81       	ldd	r24, Y+5	; 0x05
    3550:	9e 81       	ldd	r25, Y+6	; 0x06
    3552:	9a 83       	std	Y+2, r25	; 0x02
    3554:	89 83       	std	Y+1, r24	; 0x01
    3556:	89 81       	ldd	r24, Y+1	; 0x01
    3558:	9a 81       	ldd	r25, Y+2	; 0x02
    355a:	01 97       	sbiw	r24, 0x01	; 1
    355c:	f1 f7       	brne	.-4      	; 0x355a <keep_box+0x4ca>
    355e:	9a 83       	std	Y+2, r25	; 0x02
    3560:	89 83       	std	Y+1, r24	; 0x01
   _delay_ms(1000);	


// _delay_ms(2000);
  servo_2_free();
    3562:	0e 94 71 12 	call	0x24e2	; 0x24e2 <servo_2_free>
  servo_1_free(); 
    3566:	0e 94 62 12 	call	0x24c4	; 0x24c4 <servo_1_free>
}
    356a:	ca 5b       	subi	r28, 0xBA	; 186
    356c:	df 4f       	sbci	r29, 0xFF	; 255
    356e:	0f b6       	in	r0, 0x3f	; 63
    3570:	f8 94       	cli
    3572:	de bf       	out	0x3e, r29	; 62
    3574:	0f be       	out	0x3f, r0	; 63
    3576:	cd bf       	out	0x3d, r28	; 61
    3578:	cf 91       	pop	r28
    357a:	df 91       	pop	r29
    357c:	1f 91       	pop	r17
    357e:	0f 91       	pop	r16
    3580:	08 95       	ret

00003582 <_forward>:

void _forward()
{
    3582:	df 93       	push	r29
    3584:	cf 93       	push	r28
    3586:	cd b7       	in	r28, 0x3d	; 61
    3588:	de b7       	in	r29, 0x3e	; 62
    358a:	6c 97       	sbiw	r28, 0x1c	; 28
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	cd bf       	out	0x3d, r28	; 61
	while(1)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    3596:	83 e0       	ldi	r24, 0x03	; 3
    3598:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    359c:	80 93 31 03 	sts	0x0331, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    35a0:	82 e0       	ldi	r24, 0x02	; 2
    35a2:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    35a6:	80 93 32 03 	sts	0x0332, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    35aa:	81 e0       	ldi	r24, 0x01	; 1
    35ac:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    35b0:	80 93 33 03 	sts	0x0333, r24

		flag=0;
    35b4:	10 92 30 03 	sts	0x0330, r1

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    35b8:	81 e0       	ldi	r24, 0x01	; 1
    35ba:	61 e0       	ldi	r22, 0x01	; 1
    35bc:	43 e0       	ldi	r20, 0x03	; 3
    35be:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    35c2:	81 e0       	ldi	r24, 0x01	; 1
    35c4:	65 e0       	ldi	r22, 0x05	; 5
    35c6:	42 e0       	ldi	r20, 0x02	; 2
    35c8:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	69 e0       	ldi	r22, 0x09	; 9
    35d0:	41 e0       	ldi	r20, 0x01	; 1
    35d2:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		
		

		if(Center_white_line>threshold)
    35d6:	80 91 32 03 	lds	r24, 0x0332
    35da:	28 2f       	mov	r18, r24
    35dc:	30 e0       	ldi	r19, 0x00	; 0
    35de:	80 91 00 02 	lds	r24, 0x0200
    35e2:	90 91 01 02 	lds	r25, 0x0201
    35e6:	82 17       	cp	r24, r18
    35e8:	93 07       	cpc	r25, r19
    35ea:	4c f4       	brge	.+18     	; 0x35fe <_forward+0x7c>
		{
			flag=1;
    35ec:	81 e0       	ldi	r24, 0x01	; 1
    35ee:	80 93 30 03 	sts	0x0330, r24
			forward();
    35f2:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <forward>
			velocity(150,150);
    35f6:	86 e9       	ldi	r24, 0x96	; 150
    35f8:	66 e9       	ldi	r22, 0x96	; 150
    35fa:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		}

		if((Left_white_line<threshold) && flag==0)
    35fe:	80 91 31 03 	lds	r24, 0x0331
    3602:	28 2f       	mov	r18, r24
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	80 91 00 02 	lds	r24, 0x0200
    360a:	90 91 01 02 	lds	r25, 0x0201
    360e:	28 17       	cp	r18, r24
    3610:	39 07       	cpc	r19, r25
    3612:	6c f4       	brge	.+26     	; 0x362e <_forward+0xac>
    3614:	80 91 30 03 	lds	r24, 0x0330
    3618:	88 23       	and	r24, r24
    361a:	49 f4       	brne	.+18     	; 0x362e <_forward+0xac>
		{
			flag=1;
    361c:	81 e0       	ldi	r24, 0x01	; 1
    361e:	80 93 30 03 	sts	0x0330, r24
			forward();
    3622:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <forward>
			velocity(130,50);
    3626:	82 e8       	ldi	r24, 0x82	; 130
    3628:	62 e3       	ldi	r22, 0x32	; 50
    362a:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		}

		if((Right_white_line<threshold) && flag==0)
    362e:	80 91 33 03 	lds	r24, 0x0333
    3632:	28 2f       	mov	r18, r24
    3634:	30 e0       	ldi	r19, 0x00	; 0
    3636:	80 91 00 02 	lds	r24, 0x0200
    363a:	90 91 01 02 	lds	r25, 0x0201
    363e:	28 17       	cp	r18, r24
    3640:	39 07       	cpc	r19, r25
    3642:	6c f4       	brge	.+26     	; 0x365e <_forward+0xdc>
    3644:	80 91 30 03 	lds	r24, 0x0330
    3648:	88 23       	and	r24, r24
    364a:	49 f4       	brne	.+18     	; 0x365e <_forward+0xdc>
		{
			flag=1;
    364c:	81 e0       	ldi	r24, 0x01	; 1
    364e:	80 93 30 03 	sts	0x0330, r24
			forward();
    3652:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <forward>
			velocity(50,130);
    3656:	82 e3       	ldi	r24, 0x32	; 50
    3658:	62 e8       	ldi	r22, 0x82	; 130
    365a:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		}
	
		if(Center_white_line<threshold && Left_white_line<threshold && Right_white_line<threshold)
    365e:	80 91 32 03 	lds	r24, 0x0332
    3662:	28 2f       	mov	r18, r24
    3664:	30 e0       	ldi	r19, 0x00	; 0
    3666:	80 91 00 02 	lds	r24, 0x0200
    366a:	90 91 01 02 	lds	r25, 0x0201
    366e:	28 17       	cp	r18, r24
    3670:	39 07       	cpc	r19, r25
    3672:	0c f0       	brlt	.+2      	; 0x3676 <_forward+0xf4>
    3674:	04 c1       	rjmp	.+520    	; 0x387e <_forward+0x2fc>
    3676:	80 91 31 03 	lds	r24, 0x0331
    367a:	28 2f       	mov	r18, r24
    367c:	30 e0       	ldi	r19, 0x00	; 0
    367e:	80 91 00 02 	lds	r24, 0x0200
    3682:	90 91 01 02 	lds	r25, 0x0201
    3686:	28 17       	cp	r18, r24
    3688:	39 07       	cpc	r19, r25
    368a:	0c f0       	brlt	.+2      	; 0x368e <_forward+0x10c>
    368c:	f8 c0       	rjmp	.+496    	; 0x387e <_forward+0x2fc>
    368e:	80 91 33 03 	lds	r24, 0x0333
    3692:	28 2f       	mov	r18, r24
    3694:	30 e0       	ldi	r19, 0x00	; 0
    3696:	80 91 00 02 	lds	r24, 0x0200
    369a:	90 91 01 02 	lds	r25, 0x0201
    369e:	28 17       	cp	r18, r24
    36a0:	39 07       	cpc	r19, r25
    36a2:	0c f0       	brlt	.+2      	; 0x36a6 <_forward+0x124>
    36a4:	ec c0       	rjmp	.+472    	; 0x387e <_forward+0x2fc>
		{
			
			velocity(130,50);
    36a6:	82 e8       	ldi	r24, 0x82	; 130
    36a8:	62 e3       	ldi	r22, 0x32	; 50
    36aa:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
    36ae:	80 e0       	ldi	r24, 0x00	; 0
    36b0:	90 e0       	ldi	r25, 0x00	; 0
    36b2:	a0 ea       	ldi	r26, 0xA0	; 160
    36b4:	b1 e4       	ldi	r27, 0x41	; 65
    36b6:	89 8f       	std	Y+25, r24	; 0x19
    36b8:	9a 8f       	std	Y+26, r25	; 0x1a
    36ba:	ab 8f       	std	Y+27, r26	; 0x1b
    36bc:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36be:	69 8d       	ldd	r22, Y+25	; 0x19
    36c0:	7a 8d       	ldd	r23, Y+26	; 0x1a
    36c2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    36c4:	9c 8d       	ldd	r25, Y+28	; 0x1c
    36c6:	26 e6       	ldi	r18, 0x66	; 102
    36c8:	36 e6       	ldi	r19, 0x66	; 102
    36ca:	46 e6       	ldi	r20, 0x66	; 102
    36cc:	55 e4       	ldi	r21, 0x45	; 69
    36ce:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    36d2:	dc 01       	movw	r26, r24
    36d4:	cb 01       	movw	r24, r22
    36d6:	8d 8b       	std	Y+21, r24	; 0x15
    36d8:	9e 8b       	std	Y+22, r25	; 0x16
    36da:	af 8b       	std	Y+23, r26	; 0x17
    36dc:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    36de:	6d 89       	ldd	r22, Y+21	; 0x15
    36e0:	7e 89       	ldd	r23, Y+22	; 0x16
    36e2:	8f 89       	ldd	r24, Y+23	; 0x17
    36e4:	98 8d       	ldd	r25, Y+24	; 0x18
    36e6:	20 e0       	ldi	r18, 0x00	; 0
    36e8:	30 e0       	ldi	r19, 0x00	; 0
    36ea:	40 e8       	ldi	r20, 0x80	; 128
    36ec:	5f e3       	ldi	r21, 0x3F	; 63
    36ee:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    36f2:	88 23       	and	r24, r24
    36f4:	2c f4       	brge	.+10     	; 0x3700 <_forward+0x17e>
		__ticks = 1;
    36f6:	81 e0       	ldi	r24, 0x01	; 1
    36f8:	90 e0       	ldi	r25, 0x00	; 0
    36fa:	9c 8b       	std	Y+20, r25	; 0x14
    36fc:	8b 8b       	std	Y+19, r24	; 0x13
    36fe:	3f c0       	rjmp	.+126    	; 0x377e <_forward+0x1fc>
	else if (__tmp > 65535)
    3700:	6d 89       	ldd	r22, Y+21	; 0x15
    3702:	7e 89       	ldd	r23, Y+22	; 0x16
    3704:	8f 89       	ldd	r24, Y+23	; 0x17
    3706:	98 8d       	ldd	r25, Y+24	; 0x18
    3708:	20 e0       	ldi	r18, 0x00	; 0
    370a:	3f ef       	ldi	r19, 0xFF	; 255
    370c:	4f e7       	ldi	r20, 0x7F	; 127
    370e:	57 e4       	ldi	r21, 0x47	; 71
    3710:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3714:	18 16       	cp	r1, r24
    3716:	4c f5       	brge	.+82     	; 0x376a <_forward+0x1e8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3718:	69 8d       	ldd	r22, Y+25	; 0x19
    371a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    371c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    371e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3720:	20 e0       	ldi	r18, 0x00	; 0
    3722:	30 e0       	ldi	r19, 0x00	; 0
    3724:	40 e2       	ldi	r20, 0x20	; 32
    3726:	51 e4       	ldi	r21, 0x41	; 65
    3728:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    372c:	dc 01       	movw	r26, r24
    372e:	cb 01       	movw	r24, r22
    3730:	bc 01       	movw	r22, r24
    3732:	cd 01       	movw	r24, r26
    3734:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3738:	dc 01       	movw	r26, r24
    373a:	cb 01       	movw	r24, r22
    373c:	9c 8b       	std	Y+20, r25	; 0x14
    373e:	8b 8b       	std	Y+19, r24	; 0x13
    3740:	0f c0       	rjmp	.+30     	; 0x3760 <_forward+0x1de>
    3742:	80 e7       	ldi	r24, 0x70	; 112
    3744:	91 e0       	ldi	r25, 0x01	; 1
    3746:	9a 8b       	std	Y+18, r25	; 0x12
    3748:	89 8b       	std	Y+17, r24	; 0x11
    374a:	89 89       	ldd	r24, Y+17	; 0x11
    374c:	9a 89       	ldd	r25, Y+18	; 0x12
    374e:	01 97       	sbiw	r24, 0x01	; 1
    3750:	f1 f7       	brne	.-4      	; 0x374e <_forward+0x1cc>
    3752:	9a 8b       	std	Y+18, r25	; 0x12
    3754:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3756:	8b 89       	ldd	r24, Y+19	; 0x13
    3758:	9c 89       	ldd	r25, Y+20	; 0x14
    375a:	01 97       	sbiw	r24, 0x01	; 1
    375c:	9c 8b       	std	Y+20, r25	; 0x14
    375e:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3760:	8b 89       	ldd	r24, Y+19	; 0x13
    3762:	9c 89       	ldd	r25, Y+20	; 0x14
    3764:	00 97       	sbiw	r24, 0x00	; 0
    3766:	69 f7       	brne	.-38     	; 0x3742 <_forward+0x1c0>
    3768:	14 c0       	rjmp	.+40     	; 0x3792 <_forward+0x210>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    376a:	6d 89       	ldd	r22, Y+21	; 0x15
    376c:	7e 89       	ldd	r23, Y+22	; 0x16
    376e:	8f 89       	ldd	r24, Y+23	; 0x17
    3770:	98 8d       	ldd	r25, Y+24	; 0x18
    3772:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3776:	dc 01       	movw	r26, r24
    3778:	cb 01       	movw	r24, r22
    377a:	9c 8b       	std	Y+20, r25	; 0x14
    377c:	8b 8b       	std	Y+19, r24	; 0x13
    377e:	8b 89       	ldd	r24, Y+19	; 0x13
    3780:	9c 89       	ldd	r25, Y+20	; 0x14
    3782:	98 8b       	std	Y+16, r25	; 0x10
    3784:	8f 87       	std	Y+15, r24	; 0x0f
    3786:	8f 85       	ldd	r24, Y+15	; 0x0f
    3788:	98 89       	ldd	r25, Y+16	; 0x10
    378a:	01 97       	sbiw	r24, 0x01	; 1
    378c:	f1 f7       	brne	.-4      	; 0x378a <_forward+0x208>
    378e:	98 8b       	std	Y+16, r25	; 0x10
    3790:	8f 87       	std	Y+15, r24	; 0x0f
			_delay_ms(20);

			velocity(50,130);
    3792:	82 e3       	ldi	r24, 0x32	; 50
    3794:	62 e8       	ldi	r22, 0x82	; 130
    3796:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
    379a:	80 e0       	ldi	r24, 0x00	; 0
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	a8 ec       	ldi	r26, 0xC8	; 200
    37a0:	b2 e4       	ldi	r27, 0x42	; 66
    37a2:	8b 87       	std	Y+11, r24	; 0x0b
    37a4:	9c 87       	std	Y+12, r25	; 0x0c
    37a6:	ad 87       	std	Y+13, r26	; 0x0d
    37a8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37aa:	6b 85       	ldd	r22, Y+11	; 0x0b
    37ac:	7c 85       	ldd	r23, Y+12	; 0x0c
    37ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    37b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    37b2:	26 e6       	ldi	r18, 0x66	; 102
    37b4:	36 e6       	ldi	r19, 0x66	; 102
    37b6:	46 e6       	ldi	r20, 0x66	; 102
    37b8:	55 e4       	ldi	r21, 0x45	; 69
    37ba:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    37be:	dc 01       	movw	r26, r24
    37c0:	cb 01       	movw	r24, r22
    37c2:	8f 83       	std	Y+7, r24	; 0x07
    37c4:	98 87       	std	Y+8, r25	; 0x08
    37c6:	a9 87       	std	Y+9, r26	; 0x09
    37c8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    37ca:	6f 81       	ldd	r22, Y+7	; 0x07
    37cc:	78 85       	ldd	r23, Y+8	; 0x08
    37ce:	89 85       	ldd	r24, Y+9	; 0x09
    37d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    37d2:	20 e0       	ldi	r18, 0x00	; 0
    37d4:	30 e0       	ldi	r19, 0x00	; 0
    37d6:	40 e8       	ldi	r20, 0x80	; 128
    37d8:	5f e3       	ldi	r21, 0x3F	; 63
    37da:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    37de:	88 23       	and	r24, r24
    37e0:	2c f4       	brge	.+10     	; 0x37ec <_forward+0x26a>
		__ticks = 1;
    37e2:	81 e0       	ldi	r24, 0x01	; 1
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	9e 83       	std	Y+6, r25	; 0x06
    37e8:	8d 83       	std	Y+5, r24	; 0x05
    37ea:	3f c0       	rjmp	.+126    	; 0x386a <_forward+0x2e8>
	else if (__tmp > 65535)
    37ec:	6f 81       	ldd	r22, Y+7	; 0x07
    37ee:	78 85       	ldd	r23, Y+8	; 0x08
    37f0:	89 85       	ldd	r24, Y+9	; 0x09
    37f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    37f4:	20 e0       	ldi	r18, 0x00	; 0
    37f6:	3f ef       	ldi	r19, 0xFF	; 255
    37f8:	4f e7       	ldi	r20, 0x7F	; 127
    37fa:	57 e4       	ldi	r21, 0x47	; 71
    37fc:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3800:	18 16       	cp	r1, r24
    3802:	4c f5       	brge	.+82     	; 0x3856 <_forward+0x2d4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3804:	6b 85       	ldd	r22, Y+11	; 0x0b
    3806:	7c 85       	ldd	r23, Y+12	; 0x0c
    3808:	8d 85       	ldd	r24, Y+13	; 0x0d
    380a:	9e 85       	ldd	r25, Y+14	; 0x0e
    380c:	20 e0       	ldi	r18, 0x00	; 0
    380e:	30 e0       	ldi	r19, 0x00	; 0
    3810:	40 e2       	ldi	r20, 0x20	; 32
    3812:	51 e4       	ldi	r21, 0x41	; 65
    3814:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3818:	dc 01       	movw	r26, r24
    381a:	cb 01       	movw	r24, r22
    381c:	bc 01       	movw	r22, r24
    381e:	cd 01       	movw	r24, r26
    3820:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3824:	dc 01       	movw	r26, r24
    3826:	cb 01       	movw	r24, r22
    3828:	9e 83       	std	Y+6, r25	; 0x06
    382a:	8d 83       	std	Y+5, r24	; 0x05
    382c:	0f c0       	rjmp	.+30     	; 0x384c <_forward+0x2ca>
    382e:	80 e7       	ldi	r24, 0x70	; 112
    3830:	91 e0       	ldi	r25, 0x01	; 1
    3832:	9c 83       	std	Y+4, r25	; 0x04
    3834:	8b 83       	std	Y+3, r24	; 0x03
    3836:	8b 81       	ldd	r24, Y+3	; 0x03
    3838:	9c 81       	ldd	r25, Y+4	; 0x04
    383a:	01 97       	sbiw	r24, 0x01	; 1
    383c:	f1 f7       	brne	.-4      	; 0x383a <_forward+0x2b8>
    383e:	9c 83       	std	Y+4, r25	; 0x04
    3840:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3842:	8d 81       	ldd	r24, Y+5	; 0x05
    3844:	9e 81       	ldd	r25, Y+6	; 0x06
    3846:	01 97       	sbiw	r24, 0x01	; 1
    3848:	9e 83       	std	Y+6, r25	; 0x06
    384a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    384c:	8d 81       	ldd	r24, Y+5	; 0x05
    384e:	9e 81       	ldd	r25, Y+6	; 0x06
    3850:	00 97       	sbiw	r24, 0x00	; 0
    3852:	69 f7       	brne	.-38     	; 0x382e <_forward+0x2ac>
    3854:	14 c0       	rjmp	.+40     	; 0x387e <_forward+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3856:	6f 81       	ldd	r22, Y+7	; 0x07
    3858:	78 85       	ldd	r23, Y+8	; 0x08
    385a:	89 85       	ldd	r24, Y+9	; 0x09
    385c:	9a 85       	ldd	r25, Y+10	; 0x0a
    385e:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3862:	dc 01       	movw	r26, r24
    3864:	cb 01       	movw	r24, r22
    3866:	9e 83       	std	Y+6, r25	; 0x06
    3868:	8d 83       	std	Y+5, r24	; 0x05
    386a:	8d 81       	ldd	r24, Y+5	; 0x05
    386c:	9e 81       	ldd	r25, Y+6	; 0x06
    386e:	9a 83       	std	Y+2, r25	; 0x02
    3870:	89 83       	std	Y+1, r24	; 0x01
    3872:	89 81       	ldd	r24, Y+1	; 0x01
    3874:	9a 81       	ldd	r25, Y+2	; 0x02
    3876:	01 97       	sbiw	r24, 0x01	; 1
    3878:	f1 f7       	brne	.-4      	; 0x3876 <_forward+0x2f4>
    387a:	9a 83       	std	Y+2, r25	; 0x02
    387c:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(100);

		}
		if(Center_white_line<threshold && Left_white_line<threshold && Right_white_line>threshold){
    387e:	80 91 32 03 	lds	r24, 0x0332
    3882:	28 2f       	mov	r18, r24
    3884:	30 e0       	ldi	r19, 0x00	; 0
    3886:	80 91 00 02 	lds	r24, 0x0200
    388a:	90 91 01 02 	lds	r25, 0x0201
    388e:	28 17       	cp	r18, r24
    3890:	39 07       	cpc	r19, r25
    3892:	d4 f4       	brge	.+52     	; 0x38c8 <_forward+0x346>
    3894:	80 91 31 03 	lds	r24, 0x0331
    3898:	28 2f       	mov	r18, r24
    389a:	30 e0       	ldi	r19, 0x00	; 0
    389c:	80 91 00 02 	lds	r24, 0x0200
    38a0:	90 91 01 02 	lds	r25, 0x0201
    38a4:	28 17       	cp	r18, r24
    38a6:	39 07       	cpc	r19, r25
    38a8:	7c f4       	brge	.+30     	; 0x38c8 <_forward+0x346>
    38aa:	80 91 33 03 	lds	r24, 0x0333
    38ae:	28 2f       	mov	r18, r24
    38b0:	30 e0       	ldi	r19, 0x00	; 0
    38b2:	80 91 00 02 	lds	r24, 0x0200
    38b6:	90 91 01 02 	lds	r25, 0x0201
    38ba:	82 17       	cp	r24, r18
    38bc:	93 07       	cpc	r25, r19
    38be:	24 f4       	brge	.+8      	; 0x38c8 <_forward+0x346>
		
			velocity(130,50);
    38c0:	82 e8       	ldi	r24, 0x82	; 130
    38c2:	62 e3       	ldi	r22, 0x32	; 50
    38c4:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>

		}
		if(Center_white_line>threshold && Left_white_line>threshold && Right_white_line>threshold)
    38c8:	80 91 32 03 	lds	r24, 0x0332
    38cc:	28 2f       	mov	r18, r24
    38ce:	30 e0       	ldi	r19, 0x00	; 0
    38d0:	80 91 00 02 	lds	r24, 0x0200
    38d4:	90 91 01 02 	lds	r25, 0x0201
    38d8:	82 17       	cp	r24, r18
    38da:	93 07       	cpc	r25, r19
    38dc:	0c f0       	brlt	.+2      	; 0x38e0 <_forward+0x35e>
    38de:	5b ce       	rjmp	.-842    	; 0x3596 <_forward+0x14>
    38e0:	80 91 31 03 	lds	r24, 0x0331
    38e4:	28 2f       	mov	r18, r24
    38e6:	30 e0       	ldi	r19, 0x00	; 0
    38e8:	80 91 00 02 	lds	r24, 0x0200
    38ec:	90 91 01 02 	lds	r25, 0x0201
    38f0:	82 17       	cp	r24, r18
    38f2:	93 07       	cpc	r25, r19
    38f4:	0c f0       	brlt	.+2      	; 0x38f8 <_forward+0x376>
    38f6:	4f ce       	rjmp	.-866    	; 0x3596 <_forward+0x14>
    38f8:	80 91 33 03 	lds	r24, 0x0333
    38fc:	28 2f       	mov	r18, r24
    38fe:	30 e0       	ldi	r19, 0x00	; 0
    3900:	80 91 00 02 	lds	r24, 0x0200
    3904:	90 91 01 02 	lds	r25, 0x0201
    3908:	82 17       	cp	r24, r18
    390a:	93 07       	cpc	r25, r19
    390c:	0c f0       	brlt	.+2      	; 0x3910 <_forward+0x38e>
    390e:	43 ce       	rjmp	.-890    	; 0x3596 <_forward+0x14>
		{	forward();
    3910:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <forward>
			velocity(0,0);
    3914:	80 e0       	ldi	r24, 0x00	; 0
    3916:	60 e0       	ldi	r22, 0x00	; 0
    3918:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
			count=count+1;
    391c:	80 91 2e 03 	lds	r24, 0x032E
    3920:	90 91 2f 03 	lds	r25, 0x032F
    3924:	01 96       	adiw	r24, 0x01	; 1
    3926:	90 93 2f 03 	sts	0x032F, r25
    392a:	80 93 2e 03 	sts	0x032E, r24
			lcd_string(" ");
    392e:	87 e1       	ldi	r24, 0x17	; 23
    3930:	92 e0       	ldi	r25, 0x02	; 2
    3932:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
			lcd_string(count);
    3936:	80 91 2e 03 	lds	r24, 0x032E
    393a:	90 91 2f 03 	lds	r25, 0x032F
    393e:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <lcd_string>
			return;
		}
	}
}
    3942:	6c 96       	adiw	r28, 0x1c	; 28
    3944:	0f b6       	in	r0, 0x3f	; 63
    3946:	f8 94       	cli
    3948:	de bf       	out	0x3e, r29	; 62
    394a:	0f be       	out	0x3f, r0	; 63
    394c:	cd bf       	out	0x3d, r28	; 61
    394e:	cf 91       	pop	r28
    3950:	df 91       	pop	r29
    3952:	08 95       	ret

00003954 <turn_left>:

void turn_left()
{
    3954:	df 93       	push	r29
    3956:	cf 93       	push	r28
    3958:	cd b7       	in	r28, 0x3d	; 61
    395a:	de b7       	in	r29, 0x3e	; 62
	while(true)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    395c:	83 e0       	ldi	r24, 0x03	; 3
    395e:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3962:	80 93 31 03 	sts	0x0331, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    3966:	82 e0       	ldi	r24, 0x02	; 2
    3968:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    396c:	80 93 32 03 	sts	0x0332, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    3970:	81 e0       	ldi	r24, 0x01	; 1
    3972:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3976:	80 93 33 03 	sts	0x0333, r24

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    397a:	81 e0       	ldi	r24, 0x01	; 1
    397c:	61 e0       	ldi	r22, 0x01	; 1
    397e:	43 e0       	ldi	r20, 0x03	; 3
    3980:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    3984:	81 e0       	ldi	r24, 0x01	; 1
    3986:	65 e0       	ldi	r22, 0x05	; 5
    3988:	42 e0       	ldi	r20, 0x02	; 2
    398a:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    398e:	81 e0       	ldi	r24, 0x01	; 1
    3990:	69 e0       	ldi	r22, 0x09	; 9
    3992:	41 e0       	ldi	r20, 0x01	; 1
    3994:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		

		soft_left();
    3998:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <soft_left>
		velocity(0, 30);
    399c:	80 e0       	ldi	r24, 0x00	; 0
    399e:	6e e1       	ldi	r22, 0x1E	; 30
    39a0:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		if (Left_white_line>threshold)
    39a4:	80 91 31 03 	lds	r24, 0x0331
    39a8:	28 2f       	mov	r18, r24
    39aa:	30 e0       	ldi	r19, 0x00	; 0
    39ac:	80 91 00 02 	lds	r24, 0x0200
    39b0:	90 91 01 02 	lds	r25, 0x0201
    39b4:	82 17       	cp	r24, r18
    39b6:	93 07       	cpc	r25, r19
    39b8:	8c f6       	brge	.-94     	; 0x395c <turn_left+0x8>
		{
			velocity(0,0);
    39ba:	80 e0       	ldi	r24, 0x00	; 0
    39bc:	60 e0       	ldi	r22, 0x00	; 0
    39be:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
			return;
		}
		else
			continue;
	}
}
    39c2:	cf 91       	pop	r28
    39c4:	df 91       	pop	r29
    39c6:	08 95       	ret

000039c8 <turn_right>:

void turn_right()
{
    39c8:	df 93       	push	r29
    39ca:	cf 93       	push	r28
    39cc:	cd b7       	in	r28, 0x3d	; 61
    39ce:	de b7       	in	r29, 0x3e	; 62
    39d0:	2e 97       	sbiw	r28, 0x0e	; 14
    39d2:	0f b6       	in	r0, 0x3f	; 63
    39d4:	f8 94       	cli
    39d6:	de bf       	out	0x3e, r29	; 62
    39d8:	0f be       	out	0x3f, r0	; 63
    39da:	cd bf       	out	0x3d, r28	; 61
	while(true)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    39dc:	83 e0       	ldi	r24, 0x03	; 3
    39de:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    39e2:	80 93 31 03 	sts	0x0331, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    39e6:	82 e0       	ldi	r24, 0x02	; 2
    39e8:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    39ec:	80 93 32 03 	sts	0x0332, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    39f6:	80 93 33 03 	sts	0x0333, r24

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    39fa:	81 e0       	ldi	r24, 0x01	; 1
    39fc:	61 e0       	ldi	r22, 0x01	; 1
    39fe:	43 e0       	ldi	r20, 0x03	; 3
    3a00:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    3a04:	81 e0       	ldi	r24, 0x01	; 1
    3a06:	65 e0       	ldi	r22, 0x05	; 5
    3a08:	42 e0       	ldi	r20, 0x02	; 2
    3a0a:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    3a0e:	81 e0       	ldi	r24, 0x01	; 1
    3a10:	69 e0       	ldi	r22, 0x09	; 9
    3a12:	41 e0       	ldi	r20, 0x01	; 1
    3a14:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		

		soft_right_2();
    3a18:	0e 94 6e 0d 	call	0x1adc	; 0x1adc <soft_right_2>
		velocity(0, 30);
    3a1c:	80 e0       	ldi	r24, 0x00	; 0
    3a1e:	6e e1       	ldi	r22, 0x1E	; 30
    3a20:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		if (Center_white_line>threshold)
    3a24:	80 91 32 03 	lds	r24, 0x0332
    3a28:	28 2f       	mov	r18, r24
    3a2a:	30 e0       	ldi	r19, 0x00	; 0
    3a2c:	80 91 00 02 	lds	r24, 0x0200
    3a30:	90 91 01 02 	lds	r25, 0x0201
    3a34:	82 17       	cp	r24, r18
    3a36:	93 07       	cpc	r25, r19
    3a38:	8c f6       	brge	.-94     	; 0x39dc <turn_right+0x14>
			continue;


	}

	stop();
    3a3a:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <stop>
    3a3e:	80 e0       	ldi	r24, 0x00	; 0
    3a40:	90 e0       	ldi	r25, 0x00	; 0
    3a42:	a0 ea       	ldi	r26, 0xA0	; 160
    3a44:	b1 e4       	ldi	r27, 0x41	; 65
    3a46:	8b 87       	std	Y+11, r24	; 0x0b
    3a48:	9c 87       	std	Y+12, r25	; 0x0c
    3a4a:	ad 87       	std	Y+13, r26	; 0x0d
    3a4c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a4e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3a50:	7c 85       	ldd	r23, Y+12	; 0x0c
    3a52:	8d 85       	ldd	r24, Y+13	; 0x0d
    3a54:	9e 85       	ldd	r25, Y+14	; 0x0e
    3a56:	26 e6       	ldi	r18, 0x66	; 102
    3a58:	36 e6       	ldi	r19, 0x66	; 102
    3a5a:	46 e6       	ldi	r20, 0x66	; 102
    3a5c:	55 e4       	ldi	r21, 0x45	; 69
    3a5e:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3a62:	dc 01       	movw	r26, r24
    3a64:	cb 01       	movw	r24, r22
    3a66:	8f 83       	std	Y+7, r24	; 0x07
    3a68:	98 87       	std	Y+8, r25	; 0x08
    3a6a:	a9 87       	std	Y+9, r26	; 0x09
    3a6c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3a6e:	6f 81       	ldd	r22, Y+7	; 0x07
    3a70:	78 85       	ldd	r23, Y+8	; 0x08
    3a72:	89 85       	ldd	r24, Y+9	; 0x09
    3a74:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a76:	20 e0       	ldi	r18, 0x00	; 0
    3a78:	30 e0       	ldi	r19, 0x00	; 0
    3a7a:	40 e8       	ldi	r20, 0x80	; 128
    3a7c:	5f e3       	ldi	r21, 0x3F	; 63
    3a7e:	0e 94 05 22 	call	0x440a	; 0x440a <__ltsf2>
    3a82:	88 23       	and	r24, r24
    3a84:	2c f4       	brge	.+10     	; 0x3a90 <turn_right+0xc8>
		__ticks = 1;
    3a86:	81 e0       	ldi	r24, 0x01	; 1
    3a88:	90 e0       	ldi	r25, 0x00	; 0
    3a8a:	9e 83       	std	Y+6, r25	; 0x06
    3a8c:	8d 83       	std	Y+5, r24	; 0x05
    3a8e:	3f c0       	rjmp	.+126    	; 0x3b0e <turn_right+0x146>
	else if (__tmp > 65535)
    3a90:	6f 81       	ldd	r22, Y+7	; 0x07
    3a92:	78 85       	ldd	r23, Y+8	; 0x08
    3a94:	89 85       	ldd	r24, Y+9	; 0x09
    3a96:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a98:	20 e0       	ldi	r18, 0x00	; 0
    3a9a:	3f ef       	ldi	r19, 0xFF	; 255
    3a9c:	4f e7       	ldi	r20, 0x7F	; 127
    3a9e:	57 e4       	ldi	r21, 0x47	; 71
    3aa0:	0e 94 a5 21 	call	0x434a	; 0x434a <__gtsf2>
    3aa4:	18 16       	cp	r1, r24
    3aa6:	4c f5       	brge	.+82     	; 0x3afa <turn_right+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3aa8:	6b 85       	ldd	r22, Y+11	; 0x0b
    3aaa:	7c 85       	ldd	r23, Y+12	; 0x0c
    3aac:	8d 85       	ldd	r24, Y+13	; 0x0d
    3aae:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ab0:	20 e0       	ldi	r18, 0x00	; 0
    3ab2:	30 e0       	ldi	r19, 0x00	; 0
    3ab4:	40 e2       	ldi	r20, 0x20	; 32
    3ab6:	51 e4       	ldi	r21, 0x41	; 65
    3ab8:	0e 94 ff 1f 	call	0x3ffe	; 0x3ffe <__mulsf3>
    3abc:	dc 01       	movw	r26, r24
    3abe:	cb 01       	movw	r24, r22
    3ac0:	bc 01       	movw	r22, r24
    3ac2:	cd 01       	movw	r24, r26
    3ac4:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3ac8:	dc 01       	movw	r26, r24
    3aca:	cb 01       	movw	r24, r22
    3acc:	9e 83       	std	Y+6, r25	; 0x06
    3ace:	8d 83       	std	Y+5, r24	; 0x05
    3ad0:	0f c0       	rjmp	.+30     	; 0x3af0 <turn_right+0x128>
    3ad2:	80 e7       	ldi	r24, 0x70	; 112
    3ad4:	91 e0       	ldi	r25, 0x01	; 1
    3ad6:	9c 83       	std	Y+4, r25	; 0x04
    3ad8:	8b 83       	std	Y+3, r24	; 0x03
    3ada:	8b 81       	ldd	r24, Y+3	; 0x03
    3adc:	9c 81       	ldd	r25, Y+4	; 0x04
    3ade:	01 97       	sbiw	r24, 0x01	; 1
    3ae0:	f1 f7       	brne	.-4      	; 0x3ade <turn_right+0x116>
    3ae2:	9c 83       	std	Y+4, r25	; 0x04
    3ae4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ae6:	8d 81       	ldd	r24, Y+5	; 0x05
    3ae8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aea:	01 97       	sbiw	r24, 0x01	; 1
    3aec:	9e 83       	std	Y+6, r25	; 0x06
    3aee:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3af0:	8d 81       	ldd	r24, Y+5	; 0x05
    3af2:	9e 81       	ldd	r25, Y+6	; 0x06
    3af4:	00 97       	sbiw	r24, 0x00	; 0
    3af6:	69 f7       	brne	.-38     	; 0x3ad2 <turn_right+0x10a>
    3af8:	14 c0       	rjmp	.+40     	; 0x3b22 <turn_right+0x15a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3afa:	6f 81       	ldd	r22, Y+7	; 0x07
    3afc:	78 85       	ldd	r23, Y+8	; 0x08
    3afe:	89 85       	ldd	r24, Y+9	; 0x09
    3b00:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b02:	0e 94 29 1e 	call	0x3c52	; 0x3c52 <__fixunssfsi>
    3b06:	dc 01       	movw	r26, r24
    3b08:	cb 01       	movw	r24, r22
    3b0a:	9e 83       	std	Y+6, r25	; 0x06
    3b0c:	8d 83       	std	Y+5, r24	; 0x05
    3b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    3b10:	9e 81       	ldd	r25, Y+6	; 0x06
    3b12:	9a 83       	std	Y+2, r25	; 0x02
    3b14:	89 83       	std	Y+1, r24	; 0x01
    3b16:	89 81       	ldd	r24, Y+1	; 0x01
    3b18:	9a 81       	ldd	r25, Y+2	; 0x02
    3b1a:	01 97       	sbiw	r24, 0x01	; 1
    3b1c:	f1 f7       	brne	.-4      	; 0x3b1a <turn_right+0x152>
    3b1e:	9a 83       	std	Y+2, r25	; 0x02
    3b20:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);

	while(true)
	{
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    3b22:	83 e0       	ldi	r24, 0x03	; 3
    3b24:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3b28:	80 93 31 03 	sts	0x0331, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    3b2c:	82 e0       	ldi	r24, 0x02	; 2
    3b2e:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3b32:	80 93 32 03 	sts	0x0332, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    3b36:	81 e0       	ldi	r24, 0x01	; 1
    3b38:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3b3c:	80 93 33 03 	sts	0x0333, r24

		print_sensor(1,1,3);	//Prints value of White Line Sensor1
    3b40:	81 e0       	ldi	r24, 0x01	; 1
    3b42:	61 e0       	ldi	r22, 0x01	; 1
    3b44:	43 e0       	ldi	r20, 0x03	; 3
    3b46:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,5,2);	//Prints Value of White Line Sensor2
    3b4a:	81 e0       	ldi	r24, 0x01	; 1
    3b4c:	65 e0       	ldi	r22, 0x05	; 5
    3b4e:	42 e0       	ldi	r20, 0x02	; 2
    3b50:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		print_sensor(1,9,1);	//Prints Value of White Line Sensor3
    3b54:	81 e0       	ldi	r24, 0x01	; 1
    3b56:	69 e0       	ldi	r22, 0x09	; 9
    3b58:	41 e0       	ldi	r20, 0x01	; 1
    3b5a:	0e 94 80 0c 	call	0x1900	; 0x1900 <print_sensor>
		

		soft_right();
    3b5e:	0e 94 5a 0d 	call	0x1ab4	; 0x1ab4 <soft_right>
		velocity(30, 0);
    3b62:	8e e1       	ldi	r24, 0x1E	; 30
    3b64:	60 e0       	ldi	r22, 0x00	; 0
    3b66:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		if (Right_white_line>threshold)
    3b6a:	80 91 33 03 	lds	r24, 0x0333
    3b6e:	28 2f       	mov	r18, r24
    3b70:	30 e0       	ldi	r19, 0x00	; 0
    3b72:	80 91 00 02 	lds	r24, 0x0200
    3b76:	90 91 01 02 	lds	r25, 0x0201
    3b7a:	82 17       	cp	r24, r18
    3b7c:	93 07       	cpc	r25, r19
    3b7e:	8c f6       	brge	.-94     	; 0x3b22 <turn_right+0x15a>
		else
			continue;


	}
}
    3b80:	2e 96       	adiw	r28, 0x0e	; 14
    3b82:	0f b6       	in	r0, 0x3f	; 63
    3b84:	f8 94       	cli
    3b86:	de bf       	out	0x3e, r29	; 62
    3b88:	0f be       	out	0x3f, r0	; 63
    3b8a:	cd bf       	out	0x3d, r28	; 61
    3b8c:	cf 91       	pop	r28
    3b8e:	df 91       	pop	r29
    3b90:	08 95       	ret

00003b92 <indicator_blocks>:
 *		// Following code.
 * 
 */
 
void indicator_blocks() 
{
    3b92:	0f 93       	push	r16
    3b94:	1f 93       	push	r17
    3b96:	df 93       	push	r29
    3b98:	cf 93       	push	r28
    3b9a:	0f 92       	push	r0
    3b9c:	0f 92       	push	r0
    3b9e:	cd b7       	in	r28, 0x3d	; 61
    3ba0:	de b7       	in	r29, 0x3e	; 62
	// TODO

	for (int i=0; i<NO_IND ;i++)
    3ba2:	1a 82       	std	Y+2, r1	; 0x02
    3ba4:	19 82       	std	Y+1, r1	; 0x01
    3ba6:	36 c0       	rjmp	.+108    	; 0x3c14 <indicator_blocks+0x82>
	{
		_forward();
    3ba8:	0e 94 c1 1a 	call	0x3582	; 0x3582 <_forward>
//		stop();
		turn_left();
    3bac:	0e 94 aa 1c 	call	0x3954	; 0x3954 <turn_left>
//		stop();
		
		iBlocks[i] = check_color();
    3bb0:	09 81       	ldd	r16, Y+1	; 0x01
    3bb2:	1a 81       	ldd	r17, Y+2	; 0x02
    3bb4:	0e 94 8f 12 	call	0x251e	; 0x251e <check_color>
    3bb8:	f8 01       	movw	r30, r16
    3bba:	e7 5b       	subi	r30, 0xB7	; 183
    3bbc:	fc 4f       	sbci	r31, 0xFC	; 252
    3bbe:	80 83       	st	Z, r24
		i++;
    3bc0:	89 81       	ldd	r24, Y+1	; 0x01
    3bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    3bc4:	01 96       	adiw	r24, 0x01	; 1
    3bc6:	9a 83       	std	Y+2, r25	; 0x02
    3bc8:	89 83       	std	Y+1, r24	; 0x01
		// Turn till middle white line sensor gets black.
		turn_right();
    3bca:	0e 94 e4 1c 	call	0x39c8	; 0x39c8 <turn_right>
		stop();
    3bce:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <stop>
		// Move Forward.
		// If proximity<20
		// stop
		iBlocks[i] = check_color();
    3bd2:	09 81       	ldd	r16, Y+1	; 0x01
    3bd4:	1a 81       	ldd	r17, Y+2	; 0x02
    3bd6:	0e 94 8f 12 	call	0x251e	; 0x251e <check_color>
    3bda:	f8 01       	movw	r30, r16
    3bdc:	e7 5b       	subi	r30, 0xB7	; 183
    3bde:	fc 4f       	sbci	r31, 0xFC	; 252
    3be0:	80 83       	st	Z, r24
		
		// Turn till middle white line sensor gets black.
		// Move Forward.
		soft_left_2();
    3be2:	0e 94 64 0d 	call	0x1ac8	; 0x1ac8 <soft_left_2>
		velocity(30, 0);
    3be6:	8e e1       	ldi	r24, 0x1E	; 30
    3be8:	60 e0       	ldi	r22, 0x00	; 0
    3bea:	0e 94 9e 0c 	call	0x193c	; 0x193c <velocity>
		while(true)
		{
			if (ADC_Conversion(2)>threshold)
    3bee:	82 e0       	ldi	r24, 0x02	; 2
    3bf0:	0e 94 46 0c 	call	0x188c	; 0x188c <ADC_Conversion>
    3bf4:	28 2f       	mov	r18, r24
    3bf6:	30 e0       	ldi	r19, 0x00	; 0
    3bf8:	80 91 00 02 	lds	r24, 0x0200
    3bfc:	90 91 01 02 	lds	r25, 0x0201
    3c00:	82 17       	cp	r24, r18
    3c02:	93 07       	cpc	r25, r19
    3c04:	a4 f7       	brge	.-24     	; 0x3bee <indicator_blocks+0x5c>
			{
				stop();
    3c06:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <stop>
 
void indicator_blocks() 
{
	// TODO

	for (int i=0; i<NO_IND ;i++)
    3c0a:	89 81       	ldd	r24, Y+1	; 0x01
    3c0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c0e:	01 96       	adiw	r24, 0x01	; 1
    3c10:	9a 83       	std	Y+2, r25	; 0x02
    3c12:	89 83       	std	Y+1, r24	; 0x01
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
    3c18:	84 30       	cpi	r24, 0x04	; 4
    3c1a:	91 05       	cpc	r25, r1
    3c1c:	2c f2       	brlt	.-118    	; 0x3ba8 <indicator_blocks+0x16>
				stop();
				break;
			}
		}
	}
}
    3c1e:	0f 90       	pop	r0
    3c20:	0f 90       	pop	r0
    3c22:	cf 91       	pop	r28
    3c24:	df 91       	pop	r29
    3c26:	1f 91       	pop	r17
    3c28:	0f 91       	pop	r16
    3c2a:	08 95       	ret

00003c2c <main>:

int main(void)
{
    3c2c:	df 93       	push	r29
    3c2e:	cf 93       	push	r28
    3c30:	cd b7       	in	r28, 0x3d	; 61
    3c32:	de b7       	in	r29, 0x3e	; 62
    init_devices();
    3c34:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <init_devices>
    lcd_set_4bit();
    3c38:	0e 94 95 00 	call	0x12a	; 0x12a <lcd_set_4bit>
    lcd_init();
    3c3c:	0e 94 94 05 	call	0xb28	; 0xb28 <lcd_init>
    color_sensor_scaling();
    3c40:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <color_sensor_scaling>
	
	indicator_blocks();
    3c44:	0e 94 c9 1d 	call	0x3b92	; 0x3b92 <indicator_blocks>
    3c48:	80 e0       	ldi	r24, 0x00	; 0
    3c4a:	90 e0       	ldi	r25, 0x00	; 0
  
}
    3c4c:	cf 91       	pop	r28
    3c4e:	df 91       	pop	r29
    3c50:	08 95       	ret

00003c52 <__fixunssfsi>:
    3c52:	ef 92       	push	r14
    3c54:	ff 92       	push	r15
    3c56:	0f 93       	push	r16
    3c58:	1f 93       	push	r17
    3c5a:	7b 01       	movw	r14, r22
    3c5c:	8c 01       	movw	r16, r24
    3c5e:	20 e0       	ldi	r18, 0x00	; 0
    3c60:	30 e0       	ldi	r19, 0x00	; 0
    3c62:	40 e0       	ldi	r20, 0x00	; 0
    3c64:	5f e4       	ldi	r21, 0x4F	; 79
    3c66:	0e 94 d5 21 	call	0x43aa	; 0x43aa <__gesf2>
    3c6a:	88 23       	and	r24, r24
    3c6c:	8c f0       	brlt	.+34     	; 0x3c90 <__fixunssfsi+0x3e>
    3c6e:	c8 01       	movw	r24, r16
    3c70:	b7 01       	movw	r22, r14
    3c72:	20 e0       	ldi	r18, 0x00	; 0
    3c74:	30 e0       	ldi	r19, 0x00	; 0
    3c76:	40 e0       	ldi	r20, 0x00	; 0
    3c78:	5f e4       	ldi	r21, 0x4F	; 79
    3c7a:	0e 94 a1 1f 	call	0x3f42	; 0x3f42 <__subsf3>
    3c7e:	0e 94 35 22 	call	0x446a	; 0x446a <__fixsfsi>
    3c82:	9b 01       	movw	r18, r22
    3c84:	ac 01       	movw	r20, r24
    3c86:	20 50       	subi	r18, 0x00	; 0
    3c88:	30 40       	sbci	r19, 0x00	; 0
    3c8a:	40 40       	sbci	r20, 0x00	; 0
    3c8c:	50 48       	sbci	r21, 0x80	; 128
    3c8e:	06 c0       	rjmp	.+12     	; 0x3c9c <__fixunssfsi+0x4a>
    3c90:	c8 01       	movw	r24, r16
    3c92:	b7 01       	movw	r22, r14
    3c94:	0e 94 35 22 	call	0x446a	; 0x446a <__fixsfsi>
    3c98:	9b 01       	movw	r18, r22
    3c9a:	ac 01       	movw	r20, r24
    3c9c:	b9 01       	movw	r22, r18
    3c9e:	ca 01       	movw	r24, r20
    3ca0:	1f 91       	pop	r17
    3ca2:	0f 91       	pop	r16
    3ca4:	ff 90       	pop	r15
    3ca6:	ef 90       	pop	r14
    3ca8:	08 95       	ret

00003caa <_fpadd_parts>:
    3caa:	a0 e0       	ldi	r26, 0x00	; 0
    3cac:	b0 e0       	ldi	r27, 0x00	; 0
    3cae:	eb e5       	ldi	r30, 0x5B	; 91
    3cb0:	fe e1       	ldi	r31, 0x1E	; 30
    3cb2:	0c 94 0b 25 	jmp	0x4a16	; 0x4a16 <__prologue_saves__>
    3cb6:	dc 01       	movw	r26, r24
    3cb8:	2b 01       	movw	r4, r22
    3cba:	fa 01       	movw	r30, r20
    3cbc:	9c 91       	ld	r25, X
    3cbe:	92 30       	cpi	r25, 0x02	; 2
    3cc0:	08 f4       	brcc	.+2      	; 0x3cc4 <_fpadd_parts+0x1a>
    3cc2:	39 c1       	rjmp	.+626    	; 0x3f36 <_fpadd_parts+0x28c>
    3cc4:	eb 01       	movw	r28, r22
    3cc6:	88 81       	ld	r24, Y
    3cc8:	82 30       	cpi	r24, 0x02	; 2
    3cca:	08 f4       	brcc	.+2      	; 0x3cce <_fpadd_parts+0x24>
    3ccc:	33 c1       	rjmp	.+614    	; 0x3f34 <_fpadd_parts+0x28a>
    3cce:	94 30       	cpi	r25, 0x04	; 4
    3cd0:	69 f4       	brne	.+26     	; 0x3cec <_fpadd_parts+0x42>
    3cd2:	84 30       	cpi	r24, 0x04	; 4
    3cd4:	09 f0       	breq	.+2      	; 0x3cd8 <_fpadd_parts+0x2e>
    3cd6:	2f c1       	rjmp	.+606    	; 0x3f36 <_fpadd_parts+0x28c>
    3cd8:	11 96       	adiw	r26, 0x01	; 1
    3cda:	9c 91       	ld	r25, X
    3cdc:	11 97       	sbiw	r26, 0x01	; 1
    3cde:	89 81       	ldd	r24, Y+1	; 0x01
    3ce0:	98 17       	cp	r25, r24
    3ce2:	09 f4       	brne	.+2      	; 0x3ce6 <_fpadd_parts+0x3c>
    3ce4:	28 c1       	rjmp	.+592    	; 0x3f36 <_fpadd_parts+0x28c>
    3ce6:	a9 e1       	ldi	r26, 0x19	; 25
    3ce8:	b2 e0       	ldi	r27, 0x02	; 2
    3cea:	25 c1       	rjmp	.+586    	; 0x3f36 <_fpadd_parts+0x28c>
    3cec:	84 30       	cpi	r24, 0x04	; 4
    3cee:	09 f4       	brne	.+2      	; 0x3cf2 <_fpadd_parts+0x48>
    3cf0:	21 c1       	rjmp	.+578    	; 0x3f34 <_fpadd_parts+0x28a>
    3cf2:	82 30       	cpi	r24, 0x02	; 2
    3cf4:	a9 f4       	brne	.+42     	; 0x3d20 <_fpadd_parts+0x76>
    3cf6:	92 30       	cpi	r25, 0x02	; 2
    3cf8:	09 f0       	breq	.+2      	; 0x3cfc <_fpadd_parts+0x52>
    3cfa:	1d c1       	rjmp	.+570    	; 0x3f36 <_fpadd_parts+0x28c>
    3cfc:	9a 01       	movw	r18, r20
    3cfe:	ad 01       	movw	r20, r26
    3d00:	88 e0       	ldi	r24, 0x08	; 8
    3d02:	ea 01       	movw	r28, r20
    3d04:	09 90       	ld	r0, Y+
    3d06:	ae 01       	movw	r20, r28
    3d08:	e9 01       	movw	r28, r18
    3d0a:	09 92       	st	Y+, r0
    3d0c:	9e 01       	movw	r18, r28
    3d0e:	81 50       	subi	r24, 0x01	; 1
    3d10:	c1 f7       	brne	.-16     	; 0x3d02 <_fpadd_parts+0x58>
    3d12:	e2 01       	movw	r28, r4
    3d14:	89 81       	ldd	r24, Y+1	; 0x01
    3d16:	11 96       	adiw	r26, 0x01	; 1
    3d18:	9c 91       	ld	r25, X
    3d1a:	89 23       	and	r24, r25
    3d1c:	81 83       	std	Z+1, r24	; 0x01
    3d1e:	08 c1       	rjmp	.+528    	; 0x3f30 <_fpadd_parts+0x286>
    3d20:	92 30       	cpi	r25, 0x02	; 2
    3d22:	09 f4       	brne	.+2      	; 0x3d26 <_fpadd_parts+0x7c>
    3d24:	07 c1       	rjmp	.+526    	; 0x3f34 <_fpadd_parts+0x28a>
    3d26:	12 96       	adiw	r26, 0x02	; 2
    3d28:	2d 90       	ld	r2, X+
    3d2a:	3c 90       	ld	r3, X
    3d2c:	13 97       	sbiw	r26, 0x03	; 3
    3d2e:	eb 01       	movw	r28, r22
    3d30:	8a 81       	ldd	r24, Y+2	; 0x02
    3d32:	9b 81       	ldd	r25, Y+3	; 0x03
    3d34:	14 96       	adiw	r26, 0x04	; 4
    3d36:	ad 90       	ld	r10, X+
    3d38:	bd 90       	ld	r11, X+
    3d3a:	cd 90       	ld	r12, X+
    3d3c:	dc 90       	ld	r13, X
    3d3e:	17 97       	sbiw	r26, 0x07	; 7
    3d40:	ec 80       	ldd	r14, Y+4	; 0x04
    3d42:	fd 80       	ldd	r15, Y+5	; 0x05
    3d44:	0e 81       	ldd	r16, Y+6	; 0x06
    3d46:	1f 81       	ldd	r17, Y+7	; 0x07
    3d48:	91 01       	movw	r18, r2
    3d4a:	28 1b       	sub	r18, r24
    3d4c:	39 0b       	sbc	r19, r25
    3d4e:	b9 01       	movw	r22, r18
    3d50:	37 ff       	sbrs	r19, 7
    3d52:	04 c0       	rjmp	.+8      	; 0x3d5c <_fpadd_parts+0xb2>
    3d54:	66 27       	eor	r22, r22
    3d56:	77 27       	eor	r23, r23
    3d58:	62 1b       	sub	r22, r18
    3d5a:	73 0b       	sbc	r23, r19
    3d5c:	60 32       	cpi	r22, 0x20	; 32
    3d5e:	71 05       	cpc	r23, r1
    3d60:	0c f0       	brlt	.+2      	; 0x3d64 <_fpadd_parts+0xba>
    3d62:	61 c0       	rjmp	.+194    	; 0x3e26 <_fpadd_parts+0x17c>
    3d64:	12 16       	cp	r1, r18
    3d66:	13 06       	cpc	r1, r19
    3d68:	6c f5       	brge	.+90     	; 0x3dc4 <_fpadd_parts+0x11a>
    3d6a:	37 01       	movw	r6, r14
    3d6c:	48 01       	movw	r8, r16
    3d6e:	06 2e       	mov	r0, r22
    3d70:	04 c0       	rjmp	.+8      	; 0x3d7a <_fpadd_parts+0xd0>
    3d72:	96 94       	lsr	r9
    3d74:	87 94       	ror	r8
    3d76:	77 94       	ror	r7
    3d78:	67 94       	ror	r6
    3d7a:	0a 94       	dec	r0
    3d7c:	d2 f7       	brpl	.-12     	; 0x3d72 <_fpadd_parts+0xc8>
    3d7e:	21 e0       	ldi	r18, 0x01	; 1
    3d80:	30 e0       	ldi	r19, 0x00	; 0
    3d82:	40 e0       	ldi	r20, 0x00	; 0
    3d84:	50 e0       	ldi	r21, 0x00	; 0
    3d86:	04 c0       	rjmp	.+8      	; 0x3d90 <_fpadd_parts+0xe6>
    3d88:	22 0f       	add	r18, r18
    3d8a:	33 1f       	adc	r19, r19
    3d8c:	44 1f       	adc	r20, r20
    3d8e:	55 1f       	adc	r21, r21
    3d90:	6a 95       	dec	r22
    3d92:	d2 f7       	brpl	.-12     	; 0x3d88 <_fpadd_parts+0xde>
    3d94:	21 50       	subi	r18, 0x01	; 1
    3d96:	30 40       	sbci	r19, 0x00	; 0
    3d98:	40 40       	sbci	r20, 0x00	; 0
    3d9a:	50 40       	sbci	r21, 0x00	; 0
    3d9c:	2e 21       	and	r18, r14
    3d9e:	3f 21       	and	r19, r15
    3da0:	40 23       	and	r20, r16
    3da2:	51 23       	and	r21, r17
    3da4:	21 15       	cp	r18, r1
    3da6:	31 05       	cpc	r19, r1
    3da8:	41 05       	cpc	r20, r1
    3daa:	51 05       	cpc	r21, r1
    3dac:	21 f0       	breq	.+8      	; 0x3db6 <_fpadd_parts+0x10c>
    3dae:	21 e0       	ldi	r18, 0x01	; 1
    3db0:	30 e0       	ldi	r19, 0x00	; 0
    3db2:	40 e0       	ldi	r20, 0x00	; 0
    3db4:	50 e0       	ldi	r21, 0x00	; 0
    3db6:	79 01       	movw	r14, r18
    3db8:	8a 01       	movw	r16, r20
    3dba:	e6 28       	or	r14, r6
    3dbc:	f7 28       	or	r15, r7
    3dbe:	08 29       	or	r16, r8
    3dc0:	19 29       	or	r17, r9
    3dc2:	3c c0       	rjmp	.+120    	; 0x3e3c <_fpadd_parts+0x192>
    3dc4:	23 2b       	or	r18, r19
    3dc6:	d1 f1       	breq	.+116    	; 0x3e3c <_fpadd_parts+0x192>
    3dc8:	26 0e       	add	r2, r22
    3dca:	37 1e       	adc	r3, r23
    3dcc:	35 01       	movw	r6, r10
    3dce:	46 01       	movw	r8, r12
    3dd0:	06 2e       	mov	r0, r22
    3dd2:	04 c0       	rjmp	.+8      	; 0x3ddc <_fpadd_parts+0x132>
    3dd4:	96 94       	lsr	r9
    3dd6:	87 94       	ror	r8
    3dd8:	77 94       	ror	r7
    3dda:	67 94       	ror	r6
    3ddc:	0a 94       	dec	r0
    3dde:	d2 f7       	brpl	.-12     	; 0x3dd4 <_fpadd_parts+0x12a>
    3de0:	21 e0       	ldi	r18, 0x01	; 1
    3de2:	30 e0       	ldi	r19, 0x00	; 0
    3de4:	40 e0       	ldi	r20, 0x00	; 0
    3de6:	50 e0       	ldi	r21, 0x00	; 0
    3de8:	04 c0       	rjmp	.+8      	; 0x3df2 <_fpadd_parts+0x148>
    3dea:	22 0f       	add	r18, r18
    3dec:	33 1f       	adc	r19, r19
    3dee:	44 1f       	adc	r20, r20
    3df0:	55 1f       	adc	r21, r21
    3df2:	6a 95       	dec	r22
    3df4:	d2 f7       	brpl	.-12     	; 0x3dea <_fpadd_parts+0x140>
    3df6:	21 50       	subi	r18, 0x01	; 1
    3df8:	30 40       	sbci	r19, 0x00	; 0
    3dfa:	40 40       	sbci	r20, 0x00	; 0
    3dfc:	50 40       	sbci	r21, 0x00	; 0
    3dfe:	2a 21       	and	r18, r10
    3e00:	3b 21       	and	r19, r11
    3e02:	4c 21       	and	r20, r12
    3e04:	5d 21       	and	r21, r13
    3e06:	21 15       	cp	r18, r1
    3e08:	31 05       	cpc	r19, r1
    3e0a:	41 05       	cpc	r20, r1
    3e0c:	51 05       	cpc	r21, r1
    3e0e:	21 f0       	breq	.+8      	; 0x3e18 <_fpadd_parts+0x16e>
    3e10:	21 e0       	ldi	r18, 0x01	; 1
    3e12:	30 e0       	ldi	r19, 0x00	; 0
    3e14:	40 e0       	ldi	r20, 0x00	; 0
    3e16:	50 e0       	ldi	r21, 0x00	; 0
    3e18:	59 01       	movw	r10, r18
    3e1a:	6a 01       	movw	r12, r20
    3e1c:	a6 28       	or	r10, r6
    3e1e:	b7 28       	or	r11, r7
    3e20:	c8 28       	or	r12, r8
    3e22:	d9 28       	or	r13, r9
    3e24:	0b c0       	rjmp	.+22     	; 0x3e3c <_fpadd_parts+0x192>
    3e26:	82 15       	cp	r24, r2
    3e28:	93 05       	cpc	r25, r3
    3e2a:	2c f0       	brlt	.+10     	; 0x3e36 <_fpadd_parts+0x18c>
    3e2c:	1c 01       	movw	r2, r24
    3e2e:	aa 24       	eor	r10, r10
    3e30:	bb 24       	eor	r11, r11
    3e32:	65 01       	movw	r12, r10
    3e34:	03 c0       	rjmp	.+6      	; 0x3e3c <_fpadd_parts+0x192>
    3e36:	ee 24       	eor	r14, r14
    3e38:	ff 24       	eor	r15, r15
    3e3a:	87 01       	movw	r16, r14
    3e3c:	11 96       	adiw	r26, 0x01	; 1
    3e3e:	9c 91       	ld	r25, X
    3e40:	d2 01       	movw	r26, r4
    3e42:	11 96       	adiw	r26, 0x01	; 1
    3e44:	8c 91       	ld	r24, X
    3e46:	98 17       	cp	r25, r24
    3e48:	09 f4       	brne	.+2      	; 0x3e4c <_fpadd_parts+0x1a2>
    3e4a:	45 c0       	rjmp	.+138    	; 0x3ed6 <_fpadd_parts+0x22c>
    3e4c:	99 23       	and	r25, r25
    3e4e:	39 f0       	breq	.+14     	; 0x3e5e <_fpadd_parts+0x1b4>
    3e50:	a8 01       	movw	r20, r16
    3e52:	97 01       	movw	r18, r14
    3e54:	2a 19       	sub	r18, r10
    3e56:	3b 09       	sbc	r19, r11
    3e58:	4c 09       	sbc	r20, r12
    3e5a:	5d 09       	sbc	r21, r13
    3e5c:	06 c0       	rjmp	.+12     	; 0x3e6a <_fpadd_parts+0x1c0>
    3e5e:	a6 01       	movw	r20, r12
    3e60:	95 01       	movw	r18, r10
    3e62:	2e 19       	sub	r18, r14
    3e64:	3f 09       	sbc	r19, r15
    3e66:	40 0b       	sbc	r20, r16
    3e68:	51 0b       	sbc	r21, r17
    3e6a:	57 fd       	sbrc	r21, 7
    3e6c:	08 c0       	rjmp	.+16     	; 0x3e7e <_fpadd_parts+0x1d4>
    3e6e:	11 82       	std	Z+1, r1	; 0x01
    3e70:	33 82       	std	Z+3, r3	; 0x03
    3e72:	22 82       	std	Z+2, r2	; 0x02
    3e74:	24 83       	std	Z+4, r18	; 0x04
    3e76:	35 83       	std	Z+5, r19	; 0x05
    3e78:	46 83       	std	Z+6, r20	; 0x06
    3e7a:	57 83       	std	Z+7, r21	; 0x07
    3e7c:	1d c0       	rjmp	.+58     	; 0x3eb8 <_fpadd_parts+0x20e>
    3e7e:	81 e0       	ldi	r24, 0x01	; 1
    3e80:	81 83       	std	Z+1, r24	; 0x01
    3e82:	33 82       	std	Z+3, r3	; 0x03
    3e84:	22 82       	std	Z+2, r2	; 0x02
    3e86:	88 27       	eor	r24, r24
    3e88:	99 27       	eor	r25, r25
    3e8a:	dc 01       	movw	r26, r24
    3e8c:	82 1b       	sub	r24, r18
    3e8e:	93 0b       	sbc	r25, r19
    3e90:	a4 0b       	sbc	r26, r20
    3e92:	b5 0b       	sbc	r27, r21
    3e94:	84 83       	std	Z+4, r24	; 0x04
    3e96:	95 83       	std	Z+5, r25	; 0x05
    3e98:	a6 83       	std	Z+6, r26	; 0x06
    3e9a:	b7 83       	std	Z+7, r27	; 0x07
    3e9c:	0d c0       	rjmp	.+26     	; 0x3eb8 <_fpadd_parts+0x20e>
    3e9e:	22 0f       	add	r18, r18
    3ea0:	33 1f       	adc	r19, r19
    3ea2:	44 1f       	adc	r20, r20
    3ea4:	55 1f       	adc	r21, r21
    3ea6:	24 83       	std	Z+4, r18	; 0x04
    3ea8:	35 83       	std	Z+5, r19	; 0x05
    3eaa:	46 83       	std	Z+6, r20	; 0x06
    3eac:	57 83       	std	Z+7, r21	; 0x07
    3eae:	82 81       	ldd	r24, Z+2	; 0x02
    3eb0:	93 81       	ldd	r25, Z+3	; 0x03
    3eb2:	01 97       	sbiw	r24, 0x01	; 1
    3eb4:	93 83       	std	Z+3, r25	; 0x03
    3eb6:	82 83       	std	Z+2, r24	; 0x02
    3eb8:	24 81       	ldd	r18, Z+4	; 0x04
    3eba:	35 81       	ldd	r19, Z+5	; 0x05
    3ebc:	46 81       	ldd	r20, Z+6	; 0x06
    3ebe:	57 81       	ldd	r21, Z+7	; 0x07
    3ec0:	da 01       	movw	r26, r20
    3ec2:	c9 01       	movw	r24, r18
    3ec4:	01 97       	sbiw	r24, 0x01	; 1
    3ec6:	a1 09       	sbc	r26, r1
    3ec8:	b1 09       	sbc	r27, r1
    3eca:	8f 5f       	subi	r24, 0xFF	; 255
    3ecc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ece:	af 4f       	sbci	r26, 0xFF	; 255
    3ed0:	bf 43       	sbci	r27, 0x3F	; 63
    3ed2:	28 f3       	brcs	.-54     	; 0x3e9e <_fpadd_parts+0x1f4>
    3ed4:	0b c0       	rjmp	.+22     	; 0x3eec <_fpadd_parts+0x242>
    3ed6:	91 83       	std	Z+1, r25	; 0x01
    3ed8:	33 82       	std	Z+3, r3	; 0x03
    3eda:	22 82       	std	Z+2, r2	; 0x02
    3edc:	ea 0c       	add	r14, r10
    3ede:	fb 1c       	adc	r15, r11
    3ee0:	0c 1d       	adc	r16, r12
    3ee2:	1d 1d       	adc	r17, r13
    3ee4:	e4 82       	std	Z+4, r14	; 0x04
    3ee6:	f5 82       	std	Z+5, r15	; 0x05
    3ee8:	06 83       	std	Z+6, r16	; 0x06
    3eea:	17 83       	std	Z+7, r17	; 0x07
    3eec:	83 e0       	ldi	r24, 0x03	; 3
    3eee:	80 83       	st	Z, r24
    3ef0:	24 81       	ldd	r18, Z+4	; 0x04
    3ef2:	35 81       	ldd	r19, Z+5	; 0x05
    3ef4:	46 81       	ldd	r20, Z+6	; 0x06
    3ef6:	57 81       	ldd	r21, Z+7	; 0x07
    3ef8:	57 ff       	sbrs	r21, 7
    3efa:	1a c0       	rjmp	.+52     	; 0x3f30 <_fpadd_parts+0x286>
    3efc:	c9 01       	movw	r24, r18
    3efe:	aa 27       	eor	r26, r26
    3f00:	97 fd       	sbrc	r25, 7
    3f02:	a0 95       	com	r26
    3f04:	ba 2f       	mov	r27, r26
    3f06:	81 70       	andi	r24, 0x01	; 1
    3f08:	90 70       	andi	r25, 0x00	; 0
    3f0a:	a0 70       	andi	r26, 0x00	; 0
    3f0c:	b0 70       	andi	r27, 0x00	; 0
    3f0e:	56 95       	lsr	r21
    3f10:	47 95       	ror	r20
    3f12:	37 95       	ror	r19
    3f14:	27 95       	ror	r18
    3f16:	82 2b       	or	r24, r18
    3f18:	93 2b       	or	r25, r19
    3f1a:	a4 2b       	or	r26, r20
    3f1c:	b5 2b       	or	r27, r21
    3f1e:	84 83       	std	Z+4, r24	; 0x04
    3f20:	95 83       	std	Z+5, r25	; 0x05
    3f22:	a6 83       	std	Z+6, r26	; 0x06
    3f24:	b7 83       	std	Z+7, r27	; 0x07
    3f26:	82 81       	ldd	r24, Z+2	; 0x02
    3f28:	93 81       	ldd	r25, Z+3	; 0x03
    3f2a:	01 96       	adiw	r24, 0x01	; 1
    3f2c:	93 83       	std	Z+3, r25	; 0x03
    3f2e:	82 83       	std	Z+2, r24	; 0x02
    3f30:	df 01       	movw	r26, r30
    3f32:	01 c0       	rjmp	.+2      	; 0x3f36 <_fpadd_parts+0x28c>
    3f34:	d2 01       	movw	r26, r4
    3f36:	cd 01       	movw	r24, r26
    3f38:	cd b7       	in	r28, 0x3d	; 61
    3f3a:	de b7       	in	r29, 0x3e	; 62
    3f3c:	e2 e1       	ldi	r30, 0x12	; 18
    3f3e:	0c 94 27 25 	jmp	0x4a4e	; 0x4a4e <__epilogue_restores__>

00003f42 <__subsf3>:
    3f42:	a0 e2       	ldi	r26, 0x20	; 32
    3f44:	b0 e0       	ldi	r27, 0x00	; 0
    3f46:	e7 ea       	ldi	r30, 0xA7	; 167
    3f48:	ff e1       	ldi	r31, 0x1F	; 31
    3f4a:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__prologue_saves__+0x18>
    3f4e:	69 83       	std	Y+1, r22	; 0x01
    3f50:	7a 83       	std	Y+2, r23	; 0x02
    3f52:	8b 83       	std	Y+3, r24	; 0x03
    3f54:	9c 83       	std	Y+4, r25	; 0x04
    3f56:	2d 83       	std	Y+5, r18	; 0x05
    3f58:	3e 83       	std	Y+6, r19	; 0x06
    3f5a:	4f 83       	std	Y+7, r20	; 0x07
    3f5c:	58 87       	std	Y+8, r21	; 0x08
    3f5e:	e9 e0       	ldi	r30, 0x09	; 9
    3f60:	ee 2e       	mov	r14, r30
    3f62:	f1 2c       	mov	r15, r1
    3f64:	ec 0e       	add	r14, r28
    3f66:	fd 1e       	adc	r15, r29
    3f68:	ce 01       	movw	r24, r28
    3f6a:	01 96       	adiw	r24, 0x01	; 1
    3f6c:	b7 01       	movw	r22, r14
    3f6e:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    3f72:	8e 01       	movw	r16, r28
    3f74:	0f 5e       	subi	r16, 0xEF	; 239
    3f76:	1f 4f       	sbci	r17, 0xFF	; 255
    3f78:	ce 01       	movw	r24, r28
    3f7a:	05 96       	adiw	r24, 0x05	; 5
    3f7c:	b8 01       	movw	r22, r16
    3f7e:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    3f82:	8a 89       	ldd	r24, Y+18	; 0x12
    3f84:	91 e0       	ldi	r25, 0x01	; 1
    3f86:	89 27       	eor	r24, r25
    3f88:	8a 8b       	std	Y+18, r24	; 0x12
    3f8a:	c7 01       	movw	r24, r14
    3f8c:	b8 01       	movw	r22, r16
    3f8e:	ae 01       	movw	r20, r28
    3f90:	47 5e       	subi	r20, 0xE7	; 231
    3f92:	5f 4f       	sbci	r21, 0xFF	; 255
    3f94:	0e 94 55 1e 	call	0x3caa	; 0x3caa <_fpadd_parts>
    3f98:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__pack_f>
    3f9c:	a0 96       	adiw	r28, 0x20	; 32
    3f9e:	e6 e0       	ldi	r30, 0x06	; 6
    3fa0:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__epilogue_restores__+0x18>

00003fa4 <__addsf3>:
    3fa4:	a0 e2       	ldi	r26, 0x20	; 32
    3fa6:	b0 e0       	ldi	r27, 0x00	; 0
    3fa8:	e8 ed       	ldi	r30, 0xD8	; 216
    3faa:	ff e1       	ldi	r31, 0x1F	; 31
    3fac:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__prologue_saves__+0x18>
    3fb0:	69 83       	std	Y+1, r22	; 0x01
    3fb2:	7a 83       	std	Y+2, r23	; 0x02
    3fb4:	8b 83       	std	Y+3, r24	; 0x03
    3fb6:	9c 83       	std	Y+4, r25	; 0x04
    3fb8:	2d 83       	std	Y+5, r18	; 0x05
    3fba:	3e 83       	std	Y+6, r19	; 0x06
    3fbc:	4f 83       	std	Y+7, r20	; 0x07
    3fbe:	58 87       	std	Y+8, r21	; 0x08
    3fc0:	f9 e0       	ldi	r31, 0x09	; 9
    3fc2:	ef 2e       	mov	r14, r31
    3fc4:	f1 2c       	mov	r15, r1
    3fc6:	ec 0e       	add	r14, r28
    3fc8:	fd 1e       	adc	r15, r29
    3fca:	ce 01       	movw	r24, r28
    3fcc:	01 96       	adiw	r24, 0x01	; 1
    3fce:	b7 01       	movw	r22, r14
    3fd0:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    3fd4:	8e 01       	movw	r16, r28
    3fd6:	0f 5e       	subi	r16, 0xEF	; 239
    3fd8:	1f 4f       	sbci	r17, 0xFF	; 255
    3fda:	ce 01       	movw	r24, r28
    3fdc:	05 96       	adiw	r24, 0x05	; 5
    3fde:	b8 01       	movw	r22, r16
    3fe0:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    3fe4:	c7 01       	movw	r24, r14
    3fe6:	b8 01       	movw	r22, r16
    3fe8:	ae 01       	movw	r20, r28
    3fea:	47 5e       	subi	r20, 0xE7	; 231
    3fec:	5f 4f       	sbci	r21, 0xFF	; 255
    3fee:	0e 94 55 1e 	call	0x3caa	; 0x3caa <_fpadd_parts>
    3ff2:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__pack_f>
    3ff6:	a0 96       	adiw	r28, 0x20	; 32
    3ff8:	e6 e0       	ldi	r30, 0x06	; 6
    3ffa:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__epilogue_restores__+0x18>

00003ffe <__mulsf3>:
    3ffe:	a0 e2       	ldi	r26, 0x20	; 32
    4000:	b0 e0       	ldi	r27, 0x00	; 0
    4002:	e5 e0       	ldi	r30, 0x05	; 5
    4004:	f0 e2       	ldi	r31, 0x20	; 32
    4006:	0c 94 0b 25 	jmp	0x4a16	; 0x4a16 <__prologue_saves__>
    400a:	69 83       	std	Y+1, r22	; 0x01
    400c:	7a 83       	std	Y+2, r23	; 0x02
    400e:	8b 83       	std	Y+3, r24	; 0x03
    4010:	9c 83       	std	Y+4, r25	; 0x04
    4012:	2d 83       	std	Y+5, r18	; 0x05
    4014:	3e 83       	std	Y+6, r19	; 0x06
    4016:	4f 83       	std	Y+7, r20	; 0x07
    4018:	58 87       	std	Y+8, r21	; 0x08
    401a:	ce 01       	movw	r24, r28
    401c:	01 96       	adiw	r24, 0x01	; 1
    401e:	be 01       	movw	r22, r28
    4020:	67 5f       	subi	r22, 0xF7	; 247
    4022:	7f 4f       	sbci	r23, 0xFF	; 255
    4024:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    4028:	ce 01       	movw	r24, r28
    402a:	05 96       	adiw	r24, 0x05	; 5
    402c:	be 01       	movw	r22, r28
    402e:	6f 5e       	subi	r22, 0xEF	; 239
    4030:	7f 4f       	sbci	r23, 0xFF	; 255
    4032:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    4036:	99 85       	ldd	r25, Y+9	; 0x09
    4038:	92 30       	cpi	r25, 0x02	; 2
    403a:	88 f0       	brcs	.+34     	; 0x405e <__mulsf3+0x60>
    403c:	89 89       	ldd	r24, Y+17	; 0x11
    403e:	82 30       	cpi	r24, 0x02	; 2
    4040:	c8 f0       	brcs	.+50     	; 0x4074 <__mulsf3+0x76>
    4042:	94 30       	cpi	r25, 0x04	; 4
    4044:	19 f4       	brne	.+6      	; 0x404c <__mulsf3+0x4e>
    4046:	82 30       	cpi	r24, 0x02	; 2
    4048:	51 f4       	brne	.+20     	; 0x405e <__mulsf3+0x60>
    404a:	04 c0       	rjmp	.+8      	; 0x4054 <__mulsf3+0x56>
    404c:	84 30       	cpi	r24, 0x04	; 4
    404e:	29 f4       	brne	.+10     	; 0x405a <__mulsf3+0x5c>
    4050:	92 30       	cpi	r25, 0x02	; 2
    4052:	81 f4       	brne	.+32     	; 0x4074 <__mulsf3+0x76>
    4054:	89 e1       	ldi	r24, 0x19	; 25
    4056:	92 e0       	ldi	r25, 0x02	; 2
    4058:	c6 c0       	rjmp	.+396    	; 0x41e6 <__mulsf3+0x1e8>
    405a:	92 30       	cpi	r25, 0x02	; 2
    405c:	49 f4       	brne	.+18     	; 0x4070 <__mulsf3+0x72>
    405e:	20 e0       	ldi	r18, 0x00	; 0
    4060:	9a 85       	ldd	r25, Y+10	; 0x0a
    4062:	8a 89       	ldd	r24, Y+18	; 0x12
    4064:	98 13       	cpse	r25, r24
    4066:	21 e0       	ldi	r18, 0x01	; 1
    4068:	2a 87       	std	Y+10, r18	; 0x0a
    406a:	ce 01       	movw	r24, r28
    406c:	09 96       	adiw	r24, 0x09	; 9
    406e:	bb c0       	rjmp	.+374    	; 0x41e6 <__mulsf3+0x1e8>
    4070:	82 30       	cpi	r24, 0x02	; 2
    4072:	49 f4       	brne	.+18     	; 0x4086 <__mulsf3+0x88>
    4074:	20 e0       	ldi	r18, 0x00	; 0
    4076:	9a 85       	ldd	r25, Y+10	; 0x0a
    4078:	8a 89       	ldd	r24, Y+18	; 0x12
    407a:	98 13       	cpse	r25, r24
    407c:	21 e0       	ldi	r18, 0x01	; 1
    407e:	2a 8b       	std	Y+18, r18	; 0x12
    4080:	ce 01       	movw	r24, r28
    4082:	41 96       	adiw	r24, 0x11	; 17
    4084:	b0 c0       	rjmp	.+352    	; 0x41e6 <__mulsf3+0x1e8>
    4086:	2d 84       	ldd	r2, Y+13	; 0x0d
    4088:	3e 84       	ldd	r3, Y+14	; 0x0e
    408a:	4f 84       	ldd	r4, Y+15	; 0x0f
    408c:	58 88       	ldd	r5, Y+16	; 0x10
    408e:	6d 88       	ldd	r6, Y+21	; 0x15
    4090:	7e 88       	ldd	r7, Y+22	; 0x16
    4092:	8f 88       	ldd	r8, Y+23	; 0x17
    4094:	98 8c       	ldd	r9, Y+24	; 0x18
    4096:	ee 24       	eor	r14, r14
    4098:	ff 24       	eor	r15, r15
    409a:	87 01       	movw	r16, r14
    409c:	aa 24       	eor	r10, r10
    409e:	bb 24       	eor	r11, r11
    40a0:	65 01       	movw	r12, r10
    40a2:	40 e0       	ldi	r20, 0x00	; 0
    40a4:	50 e0       	ldi	r21, 0x00	; 0
    40a6:	60 e0       	ldi	r22, 0x00	; 0
    40a8:	70 e0       	ldi	r23, 0x00	; 0
    40aa:	e0 e0       	ldi	r30, 0x00	; 0
    40ac:	f0 e0       	ldi	r31, 0x00	; 0
    40ae:	c1 01       	movw	r24, r2
    40b0:	81 70       	andi	r24, 0x01	; 1
    40b2:	90 70       	andi	r25, 0x00	; 0
    40b4:	89 2b       	or	r24, r25
    40b6:	e9 f0       	breq	.+58     	; 0x40f2 <__mulsf3+0xf4>
    40b8:	e6 0c       	add	r14, r6
    40ba:	f7 1c       	adc	r15, r7
    40bc:	08 1d       	adc	r16, r8
    40be:	19 1d       	adc	r17, r9
    40c0:	9a 01       	movw	r18, r20
    40c2:	ab 01       	movw	r20, r22
    40c4:	2a 0d       	add	r18, r10
    40c6:	3b 1d       	adc	r19, r11
    40c8:	4c 1d       	adc	r20, r12
    40ca:	5d 1d       	adc	r21, r13
    40cc:	80 e0       	ldi	r24, 0x00	; 0
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	a0 e0       	ldi	r26, 0x00	; 0
    40d2:	b0 e0       	ldi	r27, 0x00	; 0
    40d4:	e6 14       	cp	r14, r6
    40d6:	f7 04       	cpc	r15, r7
    40d8:	08 05       	cpc	r16, r8
    40da:	19 05       	cpc	r17, r9
    40dc:	20 f4       	brcc	.+8      	; 0x40e6 <__mulsf3+0xe8>
    40de:	81 e0       	ldi	r24, 0x01	; 1
    40e0:	90 e0       	ldi	r25, 0x00	; 0
    40e2:	a0 e0       	ldi	r26, 0x00	; 0
    40e4:	b0 e0       	ldi	r27, 0x00	; 0
    40e6:	ba 01       	movw	r22, r20
    40e8:	a9 01       	movw	r20, r18
    40ea:	48 0f       	add	r20, r24
    40ec:	59 1f       	adc	r21, r25
    40ee:	6a 1f       	adc	r22, r26
    40f0:	7b 1f       	adc	r23, r27
    40f2:	aa 0c       	add	r10, r10
    40f4:	bb 1c       	adc	r11, r11
    40f6:	cc 1c       	adc	r12, r12
    40f8:	dd 1c       	adc	r13, r13
    40fa:	97 fe       	sbrs	r9, 7
    40fc:	08 c0       	rjmp	.+16     	; 0x410e <__mulsf3+0x110>
    40fe:	81 e0       	ldi	r24, 0x01	; 1
    4100:	90 e0       	ldi	r25, 0x00	; 0
    4102:	a0 e0       	ldi	r26, 0x00	; 0
    4104:	b0 e0       	ldi	r27, 0x00	; 0
    4106:	a8 2a       	or	r10, r24
    4108:	b9 2a       	or	r11, r25
    410a:	ca 2a       	or	r12, r26
    410c:	db 2a       	or	r13, r27
    410e:	31 96       	adiw	r30, 0x01	; 1
    4110:	e0 32       	cpi	r30, 0x20	; 32
    4112:	f1 05       	cpc	r31, r1
    4114:	49 f0       	breq	.+18     	; 0x4128 <__mulsf3+0x12a>
    4116:	66 0c       	add	r6, r6
    4118:	77 1c       	adc	r7, r7
    411a:	88 1c       	adc	r8, r8
    411c:	99 1c       	adc	r9, r9
    411e:	56 94       	lsr	r5
    4120:	47 94       	ror	r4
    4122:	37 94       	ror	r3
    4124:	27 94       	ror	r2
    4126:	c3 cf       	rjmp	.-122    	; 0x40ae <__mulsf3+0xb0>
    4128:	fa 85       	ldd	r31, Y+10	; 0x0a
    412a:	ea 89       	ldd	r30, Y+18	; 0x12
    412c:	2b 89       	ldd	r18, Y+19	; 0x13
    412e:	3c 89       	ldd	r19, Y+20	; 0x14
    4130:	8b 85       	ldd	r24, Y+11	; 0x0b
    4132:	9c 85       	ldd	r25, Y+12	; 0x0c
    4134:	28 0f       	add	r18, r24
    4136:	39 1f       	adc	r19, r25
    4138:	2e 5f       	subi	r18, 0xFE	; 254
    413a:	3f 4f       	sbci	r19, 0xFF	; 255
    413c:	17 c0       	rjmp	.+46     	; 0x416c <__mulsf3+0x16e>
    413e:	ca 01       	movw	r24, r20
    4140:	81 70       	andi	r24, 0x01	; 1
    4142:	90 70       	andi	r25, 0x00	; 0
    4144:	89 2b       	or	r24, r25
    4146:	61 f0       	breq	.+24     	; 0x4160 <__mulsf3+0x162>
    4148:	16 95       	lsr	r17
    414a:	07 95       	ror	r16
    414c:	f7 94       	ror	r15
    414e:	e7 94       	ror	r14
    4150:	80 e0       	ldi	r24, 0x00	; 0
    4152:	90 e0       	ldi	r25, 0x00	; 0
    4154:	a0 e0       	ldi	r26, 0x00	; 0
    4156:	b0 e8       	ldi	r27, 0x80	; 128
    4158:	e8 2a       	or	r14, r24
    415a:	f9 2a       	or	r15, r25
    415c:	0a 2b       	or	r16, r26
    415e:	1b 2b       	or	r17, r27
    4160:	76 95       	lsr	r23
    4162:	67 95       	ror	r22
    4164:	57 95       	ror	r21
    4166:	47 95       	ror	r20
    4168:	2f 5f       	subi	r18, 0xFF	; 255
    416a:	3f 4f       	sbci	r19, 0xFF	; 255
    416c:	77 fd       	sbrc	r23, 7
    416e:	e7 cf       	rjmp	.-50     	; 0x413e <__mulsf3+0x140>
    4170:	0c c0       	rjmp	.+24     	; 0x418a <__mulsf3+0x18c>
    4172:	44 0f       	add	r20, r20
    4174:	55 1f       	adc	r21, r21
    4176:	66 1f       	adc	r22, r22
    4178:	77 1f       	adc	r23, r23
    417a:	17 fd       	sbrc	r17, 7
    417c:	41 60       	ori	r20, 0x01	; 1
    417e:	ee 0c       	add	r14, r14
    4180:	ff 1c       	adc	r15, r15
    4182:	00 1f       	adc	r16, r16
    4184:	11 1f       	adc	r17, r17
    4186:	21 50       	subi	r18, 0x01	; 1
    4188:	30 40       	sbci	r19, 0x00	; 0
    418a:	40 30       	cpi	r20, 0x00	; 0
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	59 07       	cpc	r21, r25
    4190:	90 e0       	ldi	r25, 0x00	; 0
    4192:	69 07       	cpc	r22, r25
    4194:	90 e4       	ldi	r25, 0x40	; 64
    4196:	79 07       	cpc	r23, r25
    4198:	60 f3       	brcs	.-40     	; 0x4172 <__mulsf3+0x174>
    419a:	2b 8f       	std	Y+27, r18	; 0x1b
    419c:	3c 8f       	std	Y+28, r19	; 0x1c
    419e:	db 01       	movw	r26, r22
    41a0:	ca 01       	movw	r24, r20
    41a2:	8f 77       	andi	r24, 0x7F	; 127
    41a4:	90 70       	andi	r25, 0x00	; 0
    41a6:	a0 70       	andi	r26, 0x00	; 0
    41a8:	b0 70       	andi	r27, 0x00	; 0
    41aa:	80 34       	cpi	r24, 0x40	; 64
    41ac:	91 05       	cpc	r25, r1
    41ae:	a1 05       	cpc	r26, r1
    41b0:	b1 05       	cpc	r27, r1
    41b2:	61 f4       	brne	.+24     	; 0x41cc <__mulsf3+0x1ce>
    41b4:	47 fd       	sbrc	r20, 7
    41b6:	0a c0       	rjmp	.+20     	; 0x41cc <__mulsf3+0x1ce>
    41b8:	e1 14       	cp	r14, r1
    41ba:	f1 04       	cpc	r15, r1
    41bc:	01 05       	cpc	r16, r1
    41be:	11 05       	cpc	r17, r1
    41c0:	29 f0       	breq	.+10     	; 0x41cc <__mulsf3+0x1ce>
    41c2:	40 5c       	subi	r20, 0xC0	; 192
    41c4:	5f 4f       	sbci	r21, 0xFF	; 255
    41c6:	6f 4f       	sbci	r22, 0xFF	; 255
    41c8:	7f 4f       	sbci	r23, 0xFF	; 255
    41ca:	40 78       	andi	r20, 0x80	; 128
    41cc:	1a 8e       	std	Y+26, r1	; 0x1a
    41ce:	fe 17       	cp	r31, r30
    41d0:	11 f0       	breq	.+4      	; 0x41d6 <__mulsf3+0x1d8>
    41d2:	81 e0       	ldi	r24, 0x01	; 1
    41d4:	8a 8f       	std	Y+26, r24	; 0x1a
    41d6:	4d 8f       	std	Y+29, r20	; 0x1d
    41d8:	5e 8f       	std	Y+30, r21	; 0x1e
    41da:	6f 8f       	std	Y+31, r22	; 0x1f
    41dc:	78 a3       	std	Y+32, r23	; 0x20
    41de:	83 e0       	ldi	r24, 0x03	; 3
    41e0:	89 8f       	std	Y+25, r24	; 0x19
    41e2:	ce 01       	movw	r24, r28
    41e4:	49 96       	adiw	r24, 0x19	; 25
    41e6:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__pack_f>
    41ea:	a0 96       	adiw	r28, 0x20	; 32
    41ec:	e2 e1       	ldi	r30, 0x12	; 18
    41ee:	0c 94 27 25 	jmp	0x4a4e	; 0x4a4e <__epilogue_restores__>

000041f2 <__divsf3>:
    41f2:	a8 e1       	ldi	r26, 0x18	; 24
    41f4:	b0 e0       	ldi	r27, 0x00	; 0
    41f6:	ef ef       	ldi	r30, 0xFF	; 255
    41f8:	f0 e2       	ldi	r31, 0x20	; 32
    41fa:	0c 94 13 25 	jmp	0x4a26	; 0x4a26 <__prologue_saves__+0x10>
    41fe:	69 83       	std	Y+1, r22	; 0x01
    4200:	7a 83       	std	Y+2, r23	; 0x02
    4202:	8b 83       	std	Y+3, r24	; 0x03
    4204:	9c 83       	std	Y+4, r25	; 0x04
    4206:	2d 83       	std	Y+5, r18	; 0x05
    4208:	3e 83       	std	Y+6, r19	; 0x06
    420a:	4f 83       	std	Y+7, r20	; 0x07
    420c:	58 87       	std	Y+8, r21	; 0x08
    420e:	b9 e0       	ldi	r27, 0x09	; 9
    4210:	eb 2e       	mov	r14, r27
    4212:	f1 2c       	mov	r15, r1
    4214:	ec 0e       	add	r14, r28
    4216:	fd 1e       	adc	r15, r29
    4218:	ce 01       	movw	r24, r28
    421a:	01 96       	adiw	r24, 0x01	; 1
    421c:	b7 01       	movw	r22, r14
    421e:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    4222:	8e 01       	movw	r16, r28
    4224:	0f 5e       	subi	r16, 0xEF	; 239
    4226:	1f 4f       	sbci	r17, 0xFF	; 255
    4228:	ce 01       	movw	r24, r28
    422a:	05 96       	adiw	r24, 0x05	; 5
    422c:	b8 01       	movw	r22, r16
    422e:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    4232:	29 85       	ldd	r18, Y+9	; 0x09
    4234:	22 30       	cpi	r18, 0x02	; 2
    4236:	08 f4       	brcc	.+2      	; 0x423a <__divsf3+0x48>
    4238:	7e c0       	rjmp	.+252    	; 0x4336 <__divsf3+0x144>
    423a:	39 89       	ldd	r19, Y+17	; 0x11
    423c:	32 30       	cpi	r19, 0x02	; 2
    423e:	10 f4       	brcc	.+4      	; 0x4244 <__divsf3+0x52>
    4240:	b8 01       	movw	r22, r16
    4242:	7c c0       	rjmp	.+248    	; 0x433c <__divsf3+0x14a>
    4244:	8a 85       	ldd	r24, Y+10	; 0x0a
    4246:	9a 89       	ldd	r25, Y+18	; 0x12
    4248:	89 27       	eor	r24, r25
    424a:	8a 87       	std	Y+10, r24	; 0x0a
    424c:	24 30       	cpi	r18, 0x04	; 4
    424e:	11 f0       	breq	.+4      	; 0x4254 <__divsf3+0x62>
    4250:	22 30       	cpi	r18, 0x02	; 2
    4252:	31 f4       	brne	.+12     	; 0x4260 <__divsf3+0x6e>
    4254:	23 17       	cp	r18, r19
    4256:	09 f0       	breq	.+2      	; 0x425a <__divsf3+0x68>
    4258:	6e c0       	rjmp	.+220    	; 0x4336 <__divsf3+0x144>
    425a:	69 e1       	ldi	r22, 0x19	; 25
    425c:	72 e0       	ldi	r23, 0x02	; 2
    425e:	6e c0       	rjmp	.+220    	; 0x433c <__divsf3+0x14a>
    4260:	34 30       	cpi	r19, 0x04	; 4
    4262:	39 f4       	brne	.+14     	; 0x4272 <__divsf3+0x80>
    4264:	1d 86       	std	Y+13, r1	; 0x0d
    4266:	1e 86       	std	Y+14, r1	; 0x0e
    4268:	1f 86       	std	Y+15, r1	; 0x0f
    426a:	18 8a       	std	Y+16, r1	; 0x10
    426c:	1c 86       	std	Y+12, r1	; 0x0c
    426e:	1b 86       	std	Y+11, r1	; 0x0b
    4270:	04 c0       	rjmp	.+8      	; 0x427a <__divsf3+0x88>
    4272:	32 30       	cpi	r19, 0x02	; 2
    4274:	21 f4       	brne	.+8      	; 0x427e <__divsf3+0x8c>
    4276:	84 e0       	ldi	r24, 0x04	; 4
    4278:	89 87       	std	Y+9, r24	; 0x09
    427a:	b7 01       	movw	r22, r14
    427c:	5f c0       	rjmp	.+190    	; 0x433c <__divsf3+0x14a>
    427e:	2b 85       	ldd	r18, Y+11	; 0x0b
    4280:	3c 85       	ldd	r19, Y+12	; 0x0c
    4282:	8b 89       	ldd	r24, Y+19	; 0x13
    4284:	9c 89       	ldd	r25, Y+20	; 0x14
    4286:	28 1b       	sub	r18, r24
    4288:	39 0b       	sbc	r19, r25
    428a:	3c 87       	std	Y+12, r19	; 0x0c
    428c:	2b 87       	std	Y+11, r18	; 0x0b
    428e:	ed 84       	ldd	r14, Y+13	; 0x0d
    4290:	fe 84       	ldd	r15, Y+14	; 0x0e
    4292:	0f 85       	ldd	r16, Y+15	; 0x0f
    4294:	18 89       	ldd	r17, Y+16	; 0x10
    4296:	ad 88       	ldd	r10, Y+21	; 0x15
    4298:	be 88       	ldd	r11, Y+22	; 0x16
    429a:	cf 88       	ldd	r12, Y+23	; 0x17
    429c:	d8 8c       	ldd	r13, Y+24	; 0x18
    429e:	ea 14       	cp	r14, r10
    42a0:	fb 04       	cpc	r15, r11
    42a2:	0c 05       	cpc	r16, r12
    42a4:	1d 05       	cpc	r17, r13
    42a6:	40 f4       	brcc	.+16     	; 0x42b8 <__divsf3+0xc6>
    42a8:	ee 0c       	add	r14, r14
    42aa:	ff 1c       	adc	r15, r15
    42ac:	00 1f       	adc	r16, r16
    42ae:	11 1f       	adc	r17, r17
    42b0:	21 50       	subi	r18, 0x01	; 1
    42b2:	30 40       	sbci	r19, 0x00	; 0
    42b4:	3c 87       	std	Y+12, r19	; 0x0c
    42b6:	2b 87       	std	Y+11, r18	; 0x0b
    42b8:	20 e0       	ldi	r18, 0x00	; 0
    42ba:	30 e0       	ldi	r19, 0x00	; 0
    42bc:	40 e0       	ldi	r20, 0x00	; 0
    42be:	50 e0       	ldi	r21, 0x00	; 0
    42c0:	80 e0       	ldi	r24, 0x00	; 0
    42c2:	90 e0       	ldi	r25, 0x00	; 0
    42c4:	a0 e0       	ldi	r26, 0x00	; 0
    42c6:	b0 e4       	ldi	r27, 0x40	; 64
    42c8:	60 e0       	ldi	r22, 0x00	; 0
    42ca:	70 e0       	ldi	r23, 0x00	; 0
    42cc:	ea 14       	cp	r14, r10
    42ce:	fb 04       	cpc	r15, r11
    42d0:	0c 05       	cpc	r16, r12
    42d2:	1d 05       	cpc	r17, r13
    42d4:	40 f0       	brcs	.+16     	; 0x42e6 <__divsf3+0xf4>
    42d6:	28 2b       	or	r18, r24
    42d8:	39 2b       	or	r19, r25
    42da:	4a 2b       	or	r20, r26
    42dc:	5b 2b       	or	r21, r27
    42de:	ea 18       	sub	r14, r10
    42e0:	fb 08       	sbc	r15, r11
    42e2:	0c 09       	sbc	r16, r12
    42e4:	1d 09       	sbc	r17, r13
    42e6:	b6 95       	lsr	r27
    42e8:	a7 95       	ror	r26
    42ea:	97 95       	ror	r25
    42ec:	87 95       	ror	r24
    42ee:	ee 0c       	add	r14, r14
    42f0:	ff 1c       	adc	r15, r15
    42f2:	00 1f       	adc	r16, r16
    42f4:	11 1f       	adc	r17, r17
    42f6:	6f 5f       	subi	r22, 0xFF	; 255
    42f8:	7f 4f       	sbci	r23, 0xFF	; 255
    42fa:	6f 31       	cpi	r22, 0x1F	; 31
    42fc:	71 05       	cpc	r23, r1
    42fe:	31 f7       	brne	.-52     	; 0x42cc <__divsf3+0xda>
    4300:	da 01       	movw	r26, r20
    4302:	c9 01       	movw	r24, r18
    4304:	8f 77       	andi	r24, 0x7F	; 127
    4306:	90 70       	andi	r25, 0x00	; 0
    4308:	a0 70       	andi	r26, 0x00	; 0
    430a:	b0 70       	andi	r27, 0x00	; 0
    430c:	80 34       	cpi	r24, 0x40	; 64
    430e:	91 05       	cpc	r25, r1
    4310:	a1 05       	cpc	r26, r1
    4312:	b1 05       	cpc	r27, r1
    4314:	61 f4       	brne	.+24     	; 0x432e <__divsf3+0x13c>
    4316:	27 fd       	sbrc	r18, 7
    4318:	0a c0       	rjmp	.+20     	; 0x432e <__divsf3+0x13c>
    431a:	e1 14       	cp	r14, r1
    431c:	f1 04       	cpc	r15, r1
    431e:	01 05       	cpc	r16, r1
    4320:	11 05       	cpc	r17, r1
    4322:	29 f0       	breq	.+10     	; 0x432e <__divsf3+0x13c>
    4324:	20 5c       	subi	r18, 0xC0	; 192
    4326:	3f 4f       	sbci	r19, 0xFF	; 255
    4328:	4f 4f       	sbci	r20, 0xFF	; 255
    432a:	5f 4f       	sbci	r21, 0xFF	; 255
    432c:	20 78       	andi	r18, 0x80	; 128
    432e:	2d 87       	std	Y+13, r18	; 0x0d
    4330:	3e 87       	std	Y+14, r19	; 0x0e
    4332:	4f 87       	std	Y+15, r20	; 0x0f
    4334:	58 8b       	std	Y+16, r21	; 0x10
    4336:	be 01       	movw	r22, r28
    4338:	67 5f       	subi	r22, 0xF7	; 247
    433a:	7f 4f       	sbci	r23, 0xFF	; 255
    433c:	cb 01       	movw	r24, r22
    433e:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__pack_f>
    4342:	68 96       	adiw	r28, 0x18	; 24
    4344:	ea e0       	ldi	r30, 0x0A	; 10
    4346:	0c 94 2f 25 	jmp	0x4a5e	; 0x4a5e <__epilogue_restores__+0x10>

0000434a <__gtsf2>:
    434a:	a8 e1       	ldi	r26, 0x18	; 24
    434c:	b0 e0       	ldi	r27, 0x00	; 0
    434e:	eb ea       	ldi	r30, 0xAB	; 171
    4350:	f1 e2       	ldi	r31, 0x21	; 33
    4352:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__prologue_saves__+0x18>
    4356:	69 83       	std	Y+1, r22	; 0x01
    4358:	7a 83       	std	Y+2, r23	; 0x02
    435a:	8b 83       	std	Y+3, r24	; 0x03
    435c:	9c 83       	std	Y+4, r25	; 0x04
    435e:	2d 83       	std	Y+5, r18	; 0x05
    4360:	3e 83       	std	Y+6, r19	; 0x06
    4362:	4f 83       	std	Y+7, r20	; 0x07
    4364:	58 87       	std	Y+8, r21	; 0x08
    4366:	89 e0       	ldi	r24, 0x09	; 9
    4368:	e8 2e       	mov	r14, r24
    436a:	f1 2c       	mov	r15, r1
    436c:	ec 0e       	add	r14, r28
    436e:	fd 1e       	adc	r15, r29
    4370:	ce 01       	movw	r24, r28
    4372:	01 96       	adiw	r24, 0x01	; 1
    4374:	b7 01       	movw	r22, r14
    4376:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    437a:	8e 01       	movw	r16, r28
    437c:	0f 5e       	subi	r16, 0xEF	; 239
    437e:	1f 4f       	sbci	r17, 0xFF	; 255
    4380:	ce 01       	movw	r24, r28
    4382:	05 96       	adiw	r24, 0x05	; 5
    4384:	b8 01       	movw	r22, r16
    4386:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    438a:	89 85       	ldd	r24, Y+9	; 0x09
    438c:	82 30       	cpi	r24, 0x02	; 2
    438e:	40 f0       	brcs	.+16     	; 0x43a0 <__gtsf2+0x56>
    4390:	89 89       	ldd	r24, Y+17	; 0x11
    4392:	82 30       	cpi	r24, 0x02	; 2
    4394:	28 f0       	brcs	.+10     	; 0x43a0 <__gtsf2+0x56>
    4396:	c7 01       	movw	r24, r14
    4398:	b8 01       	movw	r22, r16
    439a:	0e 94 9e 24 	call	0x493c	; 0x493c <__fpcmp_parts_f>
    439e:	01 c0       	rjmp	.+2      	; 0x43a2 <__gtsf2+0x58>
    43a0:	8f ef       	ldi	r24, 0xFF	; 255
    43a2:	68 96       	adiw	r28, 0x18	; 24
    43a4:	e6 e0       	ldi	r30, 0x06	; 6
    43a6:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__epilogue_restores__+0x18>

000043aa <__gesf2>:
    43aa:	a8 e1       	ldi	r26, 0x18	; 24
    43ac:	b0 e0       	ldi	r27, 0x00	; 0
    43ae:	eb ed       	ldi	r30, 0xDB	; 219
    43b0:	f1 e2       	ldi	r31, 0x21	; 33
    43b2:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__prologue_saves__+0x18>
    43b6:	69 83       	std	Y+1, r22	; 0x01
    43b8:	7a 83       	std	Y+2, r23	; 0x02
    43ba:	8b 83       	std	Y+3, r24	; 0x03
    43bc:	9c 83       	std	Y+4, r25	; 0x04
    43be:	2d 83       	std	Y+5, r18	; 0x05
    43c0:	3e 83       	std	Y+6, r19	; 0x06
    43c2:	4f 83       	std	Y+7, r20	; 0x07
    43c4:	58 87       	std	Y+8, r21	; 0x08
    43c6:	89 e0       	ldi	r24, 0x09	; 9
    43c8:	e8 2e       	mov	r14, r24
    43ca:	f1 2c       	mov	r15, r1
    43cc:	ec 0e       	add	r14, r28
    43ce:	fd 1e       	adc	r15, r29
    43d0:	ce 01       	movw	r24, r28
    43d2:	01 96       	adiw	r24, 0x01	; 1
    43d4:	b7 01       	movw	r22, r14
    43d6:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    43da:	8e 01       	movw	r16, r28
    43dc:	0f 5e       	subi	r16, 0xEF	; 239
    43de:	1f 4f       	sbci	r17, 0xFF	; 255
    43e0:	ce 01       	movw	r24, r28
    43e2:	05 96       	adiw	r24, 0x05	; 5
    43e4:	b8 01       	movw	r22, r16
    43e6:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    43ea:	89 85       	ldd	r24, Y+9	; 0x09
    43ec:	82 30       	cpi	r24, 0x02	; 2
    43ee:	40 f0       	brcs	.+16     	; 0x4400 <__gesf2+0x56>
    43f0:	89 89       	ldd	r24, Y+17	; 0x11
    43f2:	82 30       	cpi	r24, 0x02	; 2
    43f4:	28 f0       	brcs	.+10     	; 0x4400 <__gesf2+0x56>
    43f6:	c7 01       	movw	r24, r14
    43f8:	b8 01       	movw	r22, r16
    43fa:	0e 94 9e 24 	call	0x493c	; 0x493c <__fpcmp_parts_f>
    43fe:	01 c0       	rjmp	.+2      	; 0x4402 <__gesf2+0x58>
    4400:	8f ef       	ldi	r24, 0xFF	; 255
    4402:	68 96       	adiw	r28, 0x18	; 24
    4404:	e6 e0       	ldi	r30, 0x06	; 6
    4406:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__epilogue_restores__+0x18>

0000440a <__ltsf2>:
    440a:	a8 e1       	ldi	r26, 0x18	; 24
    440c:	b0 e0       	ldi	r27, 0x00	; 0
    440e:	eb e0       	ldi	r30, 0x0B	; 11
    4410:	f2 e2       	ldi	r31, 0x22	; 34
    4412:	0c 94 17 25 	jmp	0x4a2e	; 0x4a2e <__prologue_saves__+0x18>
    4416:	69 83       	std	Y+1, r22	; 0x01
    4418:	7a 83       	std	Y+2, r23	; 0x02
    441a:	8b 83       	std	Y+3, r24	; 0x03
    441c:	9c 83       	std	Y+4, r25	; 0x04
    441e:	2d 83       	std	Y+5, r18	; 0x05
    4420:	3e 83       	std	Y+6, r19	; 0x06
    4422:	4f 83       	std	Y+7, r20	; 0x07
    4424:	58 87       	std	Y+8, r21	; 0x08
    4426:	89 e0       	ldi	r24, 0x09	; 9
    4428:	e8 2e       	mov	r14, r24
    442a:	f1 2c       	mov	r15, r1
    442c:	ec 0e       	add	r14, r28
    442e:	fd 1e       	adc	r15, r29
    4430:	ce 01       	movw	r24, r28
    4432:	01 96       	adiw	r24, 0x01	; 1
    4434:	b7 01       	movw	r22, r14
    4436:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    443a:	8e 01       	movw	r16, r28
    443c:	0f 5e       	subi	r16, 0xEF	; 239
    443e:	1f 4f       	sbci	r17, 0xFF	; 255
    4440:	ce 01       	movw	r24, r28
    4442:	05 96       	adiw	r24, 0x05	; 5
    4444:	b8 01       	movw	r22, r16
    4446:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    444a:	89 85       	ldd	r24, Y+9	; 0x09
    444c:	82 30       	cpi	r24, 0x02	; 2
    444e:	40 f0       	brcs	.+16     	; 0x4460 <__ltsf2+0x56>
    4450:	89 89       	ldd	r24, Y+17	; 0x11
    4452:	82 30       	cpi	r24, 0x02	; 2
    4454:	28 f0       	brcs	.+10     	; 0x4460 <__ltsf2+0x56>
    4456:	c7 01       	movw	r24, r14
    4458:	b8 01       	movw	r22, r16
    445a:	0e 94 9e 24 	call	0x493c	; 0x493c <__fpcmp_parts_f>
    445e:	01 c0       	rjmp	.+2      	; 0x4462 <__ltsf2+0x58>
    4460:	81 e0       	ldi	r24, 0x01	; 1
    4462:	68 96       	adiw	r28, 0x18	; 24
    4464:	e6 e0       	ldi	r30, 0x06	; 6
    4466:	0c 94 33 25 	jmp	0x4a66	; 0x4a66 <__epilogue_restores__+0x18>

0000446a <__fixsfsi>:
    446a:	ac e0       	ldi	r26, 0x0C	; 12
    446c:	b0 e0       	ldi	r27, 0x00	; 0
    446e:	eb e3       	ldi	r30, 0x3B	; 59
    4470:	f2 e2       	ldi	r31, 0x22	; 34
    4472:	0c 94 1b 25 	jmp	0x4a36	; 0x4a36 <__prologue_saves__+0x20>
    4476:	69 83       	std	Y+1, r22	; 0x01
    4478:	7a 83       	std	Y+2, r23	; 0x02
    447a:	8b 83       	std	Y+3, r24	; 0x03
    447c:	9c 83       	std	Y+4, r25	; 0x04
    447e:	ce 01       	movw	r24, r28
    4480:	01 96       	adiw	r24, 0x01	; 1
    4482:	be 01       	movw	r22, r28
    4484:	6b 5f       	subi	r22, 0xFB	; 251
    4486:	7f 4f       	sbci	r23, 0xFF	; 255
    4488:	0e 94 26 24 	call	0x484c	; 0x484c <__unpack_f>
    448c:	8d 81       	ldd	r24, Y+5	; 0x05
    448e:	82 30       	cpi	r24, 0x02	; 2
    4490:	61 f1       	breq	.+88     	; 0x44ea <__fixsfsi+0x80>
    4492:	82 30       	cpi	r24, 0x02	; 2
    4494:	50 f1       	brcs	.+84     	; 0x44ea <__fixsfsi+0x80>
    4496:	84 30       	cpi	r24, 0x04	; 4
    4498:	21 f4       	brne	.+8      	; 0x44a2 <__fixsfsi+0x38>
    449a:	8e 81       	ldd	r24, Y+6	; 0x06
    449c:	88 23       	and	r24, r24
    449e:	51 f1       	breq	.+84     	; 0x44f4 <__fixsfsi+0x8a>
    44a0:	2e c0       	rjmp	.+92     	; 0x44fe <__fixsfsi+0x94>
    44a2:	2f 81       	ldd	r18, Y+7	; 0x07
    44a4:	38 85       	ldd	r19, Y+8	; 0x08
    44a6:	37 fd       	sbrc	r19, 7
    44a8:	20 c0       	rjmp	.+64     	; 0x44ea <__fixsfsi+0x80>
    44aa:	6e 81       	ldd	r22, Y+6	; 0x06
    44ac:	2f 31       	cpi	r18, 0x1F	; 31
    44ae:	31 05       	cpc	r19, r1
    44b0:	1c f0       	brlt	.+6      	; 0x44b8 <__fixsfsi+0x4e>
    44b2:	66 23       	and	r22, r22
    44b4:	f9 f0       	breq	.+62     	; 0x44f4 <__fixsfsi+0x8a>
    44b6:	23 c0       	rjmp	.+70     	; 0x44fe <__fixsfsi+0x94>
    44b8:	8e e1       	ldi	r24, 0x1E	; 30
    44ba:	90 e0       	ldi	r25, 0x00	; 0
    44bc:	82 1b       	sub	r24, r18
    44be:	93 0b       	sbc	r25, r19
    44c0:	29 85       	ldd	r18, Y+9	; 0x09
    44c2:	3a 85       	ldd	r19, Y+10	; 0x0a
    44c4:	4b 85       	ldd	r20, Y+11	; 0x0b
    44c6:	5c 85       	ldd	r21, Y+12	; 0x0c
    44c8:	04 c0       	rjmp	.+8      	; 0x44d2 <__fixsfsi+0x68>
    44ca:	56 95       	lsr	r21
    44cc:	47 95       	ror	r20
    44ce:	37 95       	ror	r19
    44d0:	27 95       	ror	r18
    44d2:	8a 95       	dec	r24
    44d4:	d2 f7       	brpl	.-12     	; 0x44ca <__fixsfsi+0x60>
    44d6:	66 23       	and	r22, r22
    44d8:	b1 f0       	breq	.+44     	; 0x4506 <__fixsfsi+0x9c>
    44da:	50 95       	com	r21
    44dc:	40 95       	com	r20
    44de:	30 95       	com	r19
    44e0:	21 95       	neg	r18
    44e2:	3f 4f       	sbci	r19, 0xFF	; 255
    44e4:	4f 4f       	sbci	r20, 0xFF	; 255
    44e6:	5f 4f       	sbci	r21, 0xFF	; 255
    44e8:	0e c0       	rjmp	.+28     	; 0x4506 <__fixsfsi+0x9c>
    44ea:	20 e0       	ldi	r18, 0x00	; 0
    44ec:	30 e0       	ldi	r19, 0x00	; 0
    44ee:	40 e0       	ldi	r20, 0x00	; 0
    44f0:	50 e0       	ldi	r21, 0x00	; 0
    44f2:	09 c0       	rjmp	.+18     	; 0x4506 <__fixsfsi+0x9c>
    44f4:	2f ef       	ldi	r18, 0xFF	; 255
    44f6:	3f ef       	ldi	r19, 0xFF	; 255
    44f8:	4f ef       	ldi	r20, 0xFF	; 255
    44fa:	5f e7       	ldi	r21, 0x7F	; 127
    44fc:	04 c0       	rjmp	.+8      	; 0x4506 <__fixsfsi+0x9c>
    44fe:	20 e0       	ldi	r18, 0x00	; 0
    4500:	30 e0       	ldi	r19, 0x00	; 0
    4502:	40 e0       	ldi	r20, 0x00	; 0
    4504:	50 e8       	ldi	r21, 0x80	; 128
    4506:	b9 01       	movw	r22, r18
    4508:	ca 01       	movw	r24, r20
    450a:	2c 96       	adiw	r28, 0x0c	; 12
    450c:	e2 e0       	ldi	r30, 0x02	; 2
    450e:	0c 94 37 25 	jmp	0x4a6e	; 0x4a6e <__epilogue_restores__+0x20>

00004512 <__floatunsisf>:
    4512:	a8 e0       	ldi	r26, 0x08	; 8
    4514:	b0 e0       	ldi	r27, 0x00	; 0
    4516:	ef e8       	ldi	r30, 0x8F	; 143
    4518:	f2 e2       	ldi	r31, 0x22	; 34
    451a:	0c 94 13 25 	jmp	0x4a26	; 0x4a26 <__prologue_saves__+0x10>
    451e:	7b 01       	movw	r14, r22
    4520:	8c 01       	movw	r16, r24
    4522:	61 15       	cp	r22, r1
    4524:	71 05       	cpc	r23, r1
    4526:	81 05       	cpc	r24, r1
    4528:	91 05       	cpc	r25, r1
    452a:	19 f4       	brne	.+6      	; 0x4532 <__floatunsisf+0x20>
    452c:	82 e0       	ldi	r24, 0x02	; 2
    452e:	89 83       	std	Y+1, r24	; 0x01
    4530:	60 c0       	rjmp	.+192    	; 0x45f2 <__floatunsisf+0xe0>
    4532:	83 e0       	ldi	r24, 0x03	; 3
    4534:	89 83       	std	Y+1, r24	; 0x01
    4536:	8e e1       	ldi	r24, 0x1E	; 30
    4538:	c8 2e       	mov	r12, r24
    453a:	d1 2c       	mov	r13, r1
    453c:	dc 82       	std	Y+4, r13	; 0x04
    453e:	cb 82       	std	Y+3, r12	; 0x03
    4540:	ed 82       	std	Y+5, r14	; 0x05
    4542:	fe 82       	std	Y+6, r15	; 0x06
    4544:	0f 83       	std	Y+7, r16	; 0x07
    4546:	18 87       	std	Y+8, r17	; 0x08
    4548:	c8 01       	movw	r24, r16
    454a:	b7 01       	movw	r22, r14
    454c:	0e 94 02 23 	call	0x4604	; 0x4604 <__clzsi2>
    4550:	fc 01       	movw	r30, r24
    4552:	31 97       	sbiw	r30, 0x01	; 1
    4554:	f7 ff       	sbrs	r31, 7
    4556:	3b c0       	rjmp	.+118    	; 0x45ce <__floatunsisf+0xbc>
    4558:	22 27       	eor	r18, r18
    455a:	33 27       	eor	r19, r19
    455c:	2e 1b       	sub	r18, r30
    455e:	3f 0b       	sbc	r19, r31
    4560:	57 01       	movw	r10, r14
    4562:	68 01       	movw	r12, r16
    4564:	02 2e       	mov	r0, r18
    4566:	04 c0       	rjmp	.+8      	; 0x4570 <__floatunsisf+0x5e>
    4568:	d6 94       	lsr	r13
    456a:	c7 94       	ror	r12
    456c:	b7 94       	ror	r11
    456e:	a7 94       	ror	r10
    4570:	0a 94       	dec	r0
    4572:	d2 f7       	brpl	.-12     	; 0x4568 <__floatunsisf+0x56>
    4574:	40 e0       	ldi	r20, 0x00	; 0
    4576:	50 e0       	ldi	r21, 0x00	; 0
    4578:	60 e0       	ldi	r22, 0x00	; 0
    457a:	70 e0       	ldi	r23, 0x00	; 0
    457c:	81 e0       	ldi	r24, 0x01	; 1
    457e:	90 e0       	ldi	r25, 0x00	; 0
    4580:	a0 e0       	ldi	r26, 0x00	; 0
    4582:	b0 e0       	ldi	r27, 0x00	; 0
    4584:	04 c0       	rjmp	.+8      	; 0x458e <__floatunsisf+0x7c>
    4586:	88 0f       	add	r24, r24
    4588:	99 1f       	adc	r25, r25
    458a:	aa 1f       	adc	r26, r26
    458c:	bb 1f       	adc	r27, r27
    458e:	2a 95       	dec	r18
    4590:	d2 f7       	brpl	.-12     	; 0x4586 <__floatunsisf+0x74>
    4592:	01 97       	sbiw	r24, 0x01	; 1
    4594:	a1 09       	sbc	r26, r1
    4596:	b1 09       	sbc	r27, r1
    4598:	8e 21       	and	r24, r14
    459a:	9f 21       	and	r25, r15
    459c:	a0 23       	and	r26, r16
    459e:	b1 23       	and	r27, r17
    45a0:	00 97       	sbiw	r24, 0x00	; 0
    45a2:	a1 05       	cpc	r26, r1
    45a4:	b1 05       	cpc	r27, r1
    45a6:	21 f0       	breq	.+8      	; 0x45b0 <__floatunsisf+0x9e>
    45a8:	41 e0       	ldi	r20, 0x01	; 1
    45aa:	50 e0       	ldi	r21, 0x00	; 0
    45ac:	60 e0       	ldi	r22, 0x00	; 0
    45ae:	70 e0       	ldi	r23, 0x00	; 0
    45b0:	4a 29       	or	r20, r10
    45b2:	5b 29       	or	r21, r11
    45b4:	6c 29       	or	r22, r12
    45b6:	7d 29       	or	r23, r13
    45b8:	4d 83       	std	Y+5, r20	; 0x05
    45ba:	5e 83       	std	Y+6, r21	; 0x06
    45bc:	6f 83       	std	Y+7, r22	; 0x07
    45be:	78 87       	std	Y+8, r23	; 0x08
    45c0:	8e e1       	ldi	r24, 0x1E	; 30
    45c2:	90 e0       	ldi	r25, 0x00	; 0
    45c4:	8e 1b       	sub	r24, r30
    45c6:	9f 0b       	sbc	r25, r31
    45c8:	9c 83       	std	Y+4, r25	; 0x04
    45ca:	8b 83       	std	Y+3, r24	; 0x03
    45cc:	12 c0       	rjmp	.+36     	; 0x45f2 <__floatunsisf+0xe0>
    45ce:	30 97       	sbiw	r30, 0x00	; 0
    45d0:	81 f0       	breq	.+32     	; 0x45f2 <__floatunsisf+0xe0>
    45d2:	0e 2e       	mov	r0, r30
    45d4:	04 c0       	rjmp	.+8      	; 0x45de <__floatunsisf+0xcc>
    45d6:	ee 0c       	add	r14, r14
    45d8:	ff 1c       	adc	r15, r15
    45da:	00 1f       	adc	r16, r16
    45dc:	11 1f       	adc	r17, r17
    45de:	0a 94       	dec	r0
    45e0:	d2 f7       	brpl	.-12     	; 0x45d6 <__floatunsisf+0xc4>
    45e2:	ed 82       	std	Y+5, r14	; 0x05
    45e4:	fe 82       	std	Y+6, r15	; 0x06
    45e6:	0f 83       	std	Y+7, r16	; 0x07
    45e8:	18 87       	std	Y+8, r17	; 0x08
    45ea:	ce 1a       	sub	r12, r30
    45ec:	df 0a       	sbc	r13, r31
    45ee:	dc 82       	std	Y+4, r13	; 0x04
    45f0:	cb 82       	std	Y+3, r12	; 0x03
    45f2:	1a 82       	std	Y+2, r1	; 0x02
    45f4:	ce 01       	movw	r24, r28
    45f6:	01 96       	adiw	r24, 0x01	; 1
    45f8:	0e 94 51 23 	call	0x46a2	; 0x46a2 <__pack_f>
    45fc:	28 96       	adiw	r28, 0x08	; 8
    45fe:	ea e0       	ldi	r30, 0x0A	; 10
    4600:	0c 94 2f 25 	jmp	0x4a5e	; 0x4a5e <__epilogue_restores__+0x10>

00004604 <__clzsi2>:
    4604:	ef 92       	push	r14
    4606:	ff 92       	push	r15
    4608:	0f 93       	push	r16
    460a:	1f 93       	push	r17
    460c:	7b 01       	movw	r14, r22
    460e:	8c 01       	movw	r16, r24
    4610:	80 e0       	ldi	r24, 0x00	; 0
    4612:	e8 16       	cp	r14, r24
    4614:	80 e0       	ldi	r24, 0x00	; 0
    4616:	f8 06       	cpc	r15, r24
    4618:	81 e0       	ldi	r24, 0x01	; 1
    461a:	08 07       	cpc	r16, r24
    461c:	80 e0       	ldi	r24, 0x00	; 0
    461e:	18 07       	cpc	r17, r24
    4620:	88 f4       	brcc	.+34     	; 0x4644 <__clzsi2+0x40>
    4622:	8f ef       	ldi	r24, 0xFF	; 255
    4624:	e8 16       	cp	r14, r24
    4626:	f1 04       	cpc	r15, r1
    4628:	01 05       	cpc	r16, r1
    462a:	11 05       	cpc	r17, r1
    462c:	31 f0       	breq	.+12     	; 0x463a <__clzsi2+0x36>
    462e:	28 f0       	brcs	.+10     	; 0x463a <__clzsi2+0x36>
    4630:	88 e0       	ldi	r24, 0x08	; 8
    4632:	90 e0       	ldi	r25, 0x00	; 0
    4634:	a0 e0       	ldi	r26, 0x00	; 0
    4636:	b0 e0       	ldi	r27, 0x00	; 0
    4638:	17 c0       	rjmp	.+46     	; 0x4668 <__clzsi2+0x64>
    463a:	80 e0       	ldi	r24, 0x00	; 0
    463c:	90 e0       	ldi	r25, 0x00	; 0
    463e:	a0 e0       	ldi	r26, 0x00	; 0
    4640:	b0 e0       	ldi	r27, 0x00	; 0
    4642:	12 c0       	rjmp	.+36     	; 0x4668 <__clzsi2+0x64>
    4644:	80 e0       	ldi	r24, 0x00	; 0
    4646:	e8 16       	cp	r14, r24
    4648:	80 e0       	ldi	r24, 0x00	; 0
    464a:	f8 06       	cpc	r15, r24
    464c:	80 e0       	ldi	r24, 0x00	; 0
    464e:	08 07       	cpc	r16, r24
    4650:	81 e0       	ldi	r24, 0x01	; 1
    4652:	18 07       	cpc	r17, r24
    4654:	28 f0       	brcs	.+10     	; 0x4660 <__clzsi2+0x5c>
    4656:	88 e1       	ldi	r24, 0x18	; 24
    4658:	90 e0       	ldi	r25, 0x00	; 0
    465a:	a0 e0       	ldi	r26, 0x00	; 0
    465c:	b0 e0       	ldi	r27, 0x00	; 0
    465e:	04 c0       	rjmp	.+8      	; 0x4668 <__clzsi2+0x64>
    4660:	80 e1       	ldi	r24, 0x10	; 16
    4662:	90 e0       	ldi	r25, 0x00	; 0
    4664:	a0 e0       	ldi	r26, 0x00	; 0
    4666:	b0 e0       	ldi	r27, 0x00	; 0
    4668:	20 e2       	ldi	r18, 0x20	; 32
    466a:	30 e0       	ldi	r19, 0x00	; 0
    466c:	40 e0       	ldi	r20, 0x00	; 0
    466e:	50 e0       	ldi	r21, 0x00	; 0
    4670:	28 1b       	sub	r18, r24
    4672:	39 0b       	sbc	r19, r25
    4674:	4a 0b       	sbc	r20, r26
    4676:	5b 0b       	sbc	r21, r27
    4678:	04 c0       	rjmp	.+8      	; 0x4682 <__clzsi2+0x7e>
    467a:	16 95       	lsr	r17
    467c:	07 95       	ror	r16
    467e:	f7 94       	ror	r15
    4680:	e7 94       	ror	r14
    4682:	8a 95       	dec	r24
    4684:	d2 f7       	brpl	.-12     	; 0x467a <__clzsi2+0x76>
    4686:	f7 01       	movw	r30, r14
    4688:	ef 5d       	subi	r30, 0xDF	; 223
    468a:	fd 4f       	sbci	r31, 0xFD	; 253
    468c:	80 81       	ld	r24, Z
    468e:	28 1b       	sub	r18, r24
    4690:	31 09       	sbc	r19, r1
    4692:	41 09       	sbc	r20, r1
    4694:	51 09       	sbc	r21, r1
    4696:	c9 01       	movw	r24, r18
    4698:	1f 91       	pop	r17
    469a:	0f 91       	pop	r16
    469c:	ff 90       	pop	r15
    469e:	ef 90       	pop	r14
    46a0:	08 95       	ret

000046a2 <__pack_f>:
    46a2:	df 92       	push	r13
    46a4:	ef 92       	push	r14
    46a6:	ff 92       	push	r15
    46a8:	0f 93       	push	r16
    46aa:	1f 93       	push	r17
    46ac:	fc 01       	movw	r30, r24
    46ae:	e4 80       	ldd	r14, Z+4	; 0x04
    46b0:	f5 80       	ldd	r15, Z+5	; 0x05
    46b2:	06 81       	ldd	r16, Z+6	; 0x06
    46b4:	17 81       	ldd	r17, Z+7	; 0x07
    46b6:	d1 80       	ldd	r13, Z+1	; 0x01
    46b8:	80 81       	ld	r24, Z
    46ba:	82 30       	cpi	r24, 0x02	; 2
    46bc:	48 f4       	brcc	.+18     	; 0x46d0 <__pack_f+0x2e>
    46be:	80 e0       	ldi	r24, 0x00	; 0
    46c0:	90 e0       	ldi	r25, 0x00	; 0
    46c2:	a0 e1       	ldi	r26, 0x10	; 16
    46c4:	b0 e0       	ldi	r27, 0x00	; 0
    46c6:	e8 2a       	or	r14, r24
    46c8:	f9 2a       	or	r15, r25
    46ca:	0a 2b       	or	r16, r26
    46cc:	1b 2b       	or	r17, r27
    46ce:	a5 c0       	rjmp	.+330    	; 0x481a <__pack_f+0x178>
    46d0:	84 30       	cpi	r24, 0x04	; 4
    46d2:	09 f4       	brne	.+2      	; 0x46d6 <__pack_f+0x34>
    46d4:	9f c0       	rjmp	.+318    	; 0x4814 <__pack_f+0x172>
    46d6:	82 30       	cpi	r24, 0x02	; 2
    46d8:	21 f4       	brne	.+8      	; 0x46e2 <__pack_f+0x40>
    46da:	ee 24       	eor	r14, r14
    46dc:	ff 24       	eor	r15, r15
    46de:	87 01       	movw	r16, r14
    46e0:	05 c0       	rjmp	.+10     	; 0x46ec <__pack_f+0x4a>
    46e2:	e1 14       	cp	r14, r1
    46e4:	f1 04       	cpc	r15, r1
    46e6:	01 05       	cpc	r16, r1
    46e8:	11 05       	cpc	r17, r1
    46ea:	19 f4       	brne	.+6      	; 0x46f2 <__pack_f+0x50>
    46ec:	e0 e0       	ldi	r30, 0x00	; 0
    46ee:	f0 e0       	ldi	r31, 0x00	; 0
    46f0:	96 c0       	rjmp	.+300    	; 0x481e <__pack_f+0x17c>
    46f2:	62 81       	ldd	r22, Z+2	; 0x02
    46f4:	73 81       	ldd	r23, Z+3	; 0x03
    46f6:	9f ef       	ldi	r25, 0xFF	; 255
    46f8:	62 38       	cpi	r22, 0x82	; 130
    46fa:	79 07       	cpc	r23, r25
    46fc:	0c f0       	brlt	.+2      	; 0x4700 <__pack_f+0x5e>
    46fe:	5b c0       	rjmp	.+182    	; 0x47b6 <__pack_f+0x114>
    4700:	22 e8       	ldi	r18, 0x82	; 130
    4702:	3f ef       	ldi	r19, 0xFF	; 255
    4704:	26 1b       	sub	r18, r22
    4706:	37 0b       	sbc	r19, r23
    4708:	2a 31       	cpi	r18, 0x1A	; 26
    470a:	31 05       	cpc	r19, r1
    470c:	2c f0       	brlt	.+10     	; 0x4718 <__pack_f+0x76>
    470e:	20 e0       	ldi	r18, 0x00	; 0
    4710:	30 e0       	ldi	r19, 0x00	; 0
    4712:	40 e0       	ldi	r20, 0x00	; 0
    4714:	50 e0       	ldi	r21, 0x00	; 0
    4716:	2a c0       	rjmp	.+84     	; 0x476c <__pack_f+0xca>
    4718:	b8 01       	movw	r22, r16
    471a:	a7 01       	movw	r20, r14
    471c:	02 2e       	mov	r0, r18
    471e:	04 c0       	rjmp	.+8      	; 0x4728 <__pack_f+0x86>
    4720:	76 95       	lsr	r23
    4722:	67 95       	ror	r22
    4724:	57 95       	ror	r21
    4726:	47 95       	ror	r20
    4728:	0a 94       	dec	r0
    472a:	d2 f7       	brpl	.-12     	; 0x4720 <__pack_f+0x7e>
    472c:	81 e0       	ldi	r24, 0x01	; 1
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	a0 e0       	ldi	r26, 0x00	; 0
    4732:	b0 e0       	ldi	r27, 0x00	; 0
    4734:	04 c0       	rjmp	.+8      	; 0x473e <__pack_f+0x9c>
    4736:	88 0f       	add	r24, r24
    4738:	99 1f       	adc	r25, r25
    473a:	aa 1f       	adc	r26, r26
    473c:	bb 1f       	adc	r27, r27
    473e:	2a 95       	dec	r18
    4740:	d2 f7       	brpl	.-12     	; 0x4736 <__pack_f+0x94>
    4742:	01 97       	sbiw	r24, 0x01	; 1
    4744:	a1 09       	sbc	r26, r1
    4746:	b1 09       	sbc	r27, r1
    4748:	8e 21       	and	r24, r14
    474a:	9f 21       	and	r25, r15
    474c:	a0 23       	and	r26, r16
    474e:	b1 23       	and	r27, r17
    4750:	00 97       	sbiw	r24, 0x00	; 0
    4752:	a1 05       	cpc	r26, r1
    4754:	b1 05       	cpc	r27, r1
    4756:	21 f0       	breq	.+8      	; 0x4760 <__pack_f+0xbe>
    4758:	81 e0       	ldi	r24, 0x01	; 1
    475a:	90 e0       	ldi	r25, 0x00	; 0
    475c:	a0 e0       	ldi	r26, 0x00	; 0
    475e:	b0 e0       	ldi	r27, 0x00	; 0
    4760:	9a 01       	movw	r18, r20
    4762:	ab 01       	movw	r20, r22
    4764:	28 2b       	or	r18, r24
    4766:	39 2b       	or	r19, r25
    4768:	4a 2b       	or	r20, r26
    476a:	5b 2b       	or	r21, r27
    476c:	da 01       	movw	r26, r20
    476e:	c9 01       	movw	r24, r18
    4770:	8f 77       	andi	r24, 0x7F	; 127
    4772:	90 70       	andi	r25, 0x00	; 0
    4774:	a0 70       	andi	r26, 0x00	; 0
    4776:	b0 70       	andi	r27, 0x00	; 0
    4778:	80 34       	cpi	r24, 0x40	; 64
    477a:	91 05       	cpc	r25, r1
    477c:	a1 05       	cpc	r26, r1
    477e:	b1 05       	cpc	r27, r1
    4780:	39 f4       	brne	.+14     	; 0x4790 <__pack_f+0xee>
    4782:	27 ff       	sbrs	r18, 7
    4784:	09 c0       	rjmp	.+18     	; 0x4798 <__pack_f+0xf6>
    4786:	20 5c       	subi	r18, 0xC0	; 192
    4788:	3f 4f       	sbci	r19, 0xFF	; 255
    478a:	4f 4f       	sbci	r20, 0xFF	; 255
    478c:	5f 4f       	sbci	r21, 0xFF	; 255
    478e:	04 c0       	rjmp	.+8      	; 0x4798 <__pack_f+0xf6>
    4790:	21 5c       	subi	r18, 0xC1	; 193
    4792:	3f 4f       	sbci	r19, 0xFF	; 255
    4794:	4f 4f       	sbci	r20, 0xFF	; 255
    4796:	5f 4f       	sbci	r21, 0xFF	; 255
    4798:	e0 e0       	ldi	r30, 0x00	; 0
    479a:	f0 e0       	ldi	r31, 0x00	; 0
    479c:	20 30       	cpi	r18, 0x00	; 0
    479e:	a0 e0       	ldi	r26, 0x00	; 0
    47a0:	3a 07       	cpc	r19, r26
    47a2:	a0 e0       	ldi	r26, 0x00	; 0
    47a4:	4a 07       	cpc	r20, r26
    47a6:	a0 e4       	ldi	r26, 0x40	; 64
    47a8:	5a 07       	cpc	r21, r26
    47aa:	10 f0       	brcs	.+4      	; 0x47b0 <__pack_f+0x10e>
    47ac:	e1 e0       	ldi	r30, 0x01	; 1
    47ae:	f0 e0       	ldi	r31, 0x00	; 0
    47b0:	79 01       	movw	r14, r18
    47b2:	8a 01       	movw	r16, r20
    47b4:	27 c0       	rjmp	.+78     	; 0x4804 <__pack_f+0x162>
    47b6:	60 38       	cpi	r22, 0x80	; 128
    47b8:	71 05       	cpc	r23, r1
    47ba:	64 f5       	brge	.+88     	; 0x4814 <__pack_f+0x172>
    47bc:	fb 01       	movw	r30, r22
    47be:	e1 58       	subi	r30, 0x81	; 129
    47c0:	ff 4f       	sbci	r31, 0xFF	; 255
    47c2:	d8 01       	movw	r26, r16
    47c4:	c7 01       	movw	r24, r14
    47c6:	8f 77       	andi	r24, 0x7F	; 127
    47c8:	90 70       	andi	r25, 0x00	; 0
    47ca:	a0 70       	andi	r26, 0x00	; 0
    47cc:	b0 70       	andi	r27, 0x00	; 0
    47ce:	80 34       	cpi	r24, 0x40	; 64
    47d0:	91 05       	cpc	r25, r1
    47d2:	a1 05       	cpc	r26, r1
    47d4:	b1 05       	cpc	r27, r1
    47d6:	39 f4       	brne	.+14     	; 0x47e6 <__pack_f+0x144>
    47d8:	e7 fe       	sbrs	r14, 7
    47da:	0d c0       	rjmp	.+26     	; 0x47f6 <__pack_f+0x154>
    47dc:	80 e4       	ldi	r24, 0x40	; 64
    47de:	90 e0       	ldi	r25, 0x00	; 0
    47e0:	a0 e0       	ldi	r26, 0x00	; 0
    47e2:	b0 e0       	ldi	r27, 0x00	; 0
    47e4:	04 c0       	rjmp	.+8      	; 0x47ee <__pack_f+0x14c>
    47e6:	8f e3       	ldi	r24, 0x3F	; 63
    47e8:	90 e0       	ldi	r25, 0x00	; 0
    47ea:	a0 e0       	ldi	r26, 0x00	; 0
    47ec:	b0 e0       	ldi	r27, 0x00	; 0
    47ee:	e8 0e       	add	r14, r24
    47f0:	f9 1e       	adc	r15, r25
    47f2:	0a 1f       	adc	r16, r26
    47f4:	1b 1f       	adc	r17, r27
    47f6:	17 ff       	sbrs	r17, 7
    47f8:	05 c0       	rjmp	.+10     	; 0x4804 <__pack_f+0x162>
    47fa:	16 95       	lsr	r17
    47fc:	07 95       	ror	r16
    47fe:	f7 94       	ror	r15
    4800:	e7 94       	ror	r14
    4802:	31 96       	adiw	r30, 0x01	; 1
    4804:	87 e0       	ldi	r24, 0x07	; 7
    4806:	16 95       	lsr	r17
    4808:	07 95       	ror	r16
    480a:	f7 94       	ror	r15
    480c:	e7 94       	ror	r14
    480e:	8a 95       	dec	r24
    4810:	d1 f7       	brne	.-12     	; 0x4806 <__pack_f+0x164>
    4812:	05 c0       	rjmp	.+10     	; 0x481e <__pack_f+0x17c>
    4814:	ee 24       	eor	r14, r14
    4816:	ff 24       	eor	r15, r15
    4818:	87 01       	movw	r16, r14
    481a:	ef ef       	ldi	r30, 0xFF	; 255
    481c:	f0 e0       	ldi	r31, 0x00	; 0
    481e:	6e 2f       	mov	r22, r30
    4820:	67 95       	ror	r22
    4822:	66 27       	eor	r22, r22
    4824:	67 95       	ror	r22
    4826:	90 2f       	mov	r25, r16
    4828:	9f 77       	andi	r25, 0x7F	; 127
    482a:	d7 94       	ror	r13
    482c:	dd 24       	eor	r13, r13
    482e:	d7 94       	ror	r13
    4830:	8e 2f       	mov	r24, r30
    4832:	86 95       	lsr	r24
    4834:	49 2f       	mov	r20, r25
    4836:	46 2b       	or	r20, r22
    4838:	58 2f       	mov	r21, r24
    483a:	5d 29       	or	r21, r13
    483c:	b7 01       	movw	r22, r14
    483e:	ca 01       	movw	r24, r20
    4840:	1f 91       	pop	r17
    4842:	0f 91       	pop	r16
    4844:	ff 90       	pop	r15
    4846:	ef 90       	pop	r14
    4848:	df 90       	pop	r13
    484a:	08 95       	ret

0000484c <__unpack_f>:
    484c:	fc 01       	movw	r30, r24
    484e:	db 01       	movw	r26, r22
    4850:	40 81       	ld	r20, Z
    4852:	51 81       	ldd	r21, Z+1	; 0x01
    4854:	22 81       	ldd	r18, Z+2	; 0x02
    4856:	62 2f       	mov	r22, r18
    4858:	6f 77       	andi	r22, 0x7F	; 127
    485a:	70 e0       	ldi	r23, 0x00	; 0
    485c:	22 1f       	adc	r18, r18
    485e:	22 27       	eor	r18, r18
    4860:	22 1f       	adc	r18, r18
    4862:	93 81       	ldd	r25, Z+3	; 0x03
    4864:	89 2f       	mov	r24, r25
    4866:	88 0f       	add	r24, r24
    4868:	82 2b       	or	r24, r18
    486a:	28 2f       	mov	r18, r24
    486c:	30 e0       	ldi	r19, 0x00	; 0
    486e:	99 1f       	adc	r25, r25
    4870:	99 27       	eor	r25, r25
    4872:	99 1f       	adc	r25, r25
    4874:	11 96       	adiw	r26, 0x01	; 1
    4876:	9c 93       	st	X, r25
    4878:	11 97       	sbiw	r26, 0x01	; 1
    487a:	21 15       	cp	r18, r1
    487c:	31 05       	cpc	r19, r1
    487e:	a9 f5       	brne	.+106    	; 0x48ea <__unpack_f+0x9e>
    4880:	41 15       	cp	r20, r1
    4882:	51 05       	cpc	r21, r1
    4884:	61 05       	cpc	r22, r1
    4886:	71 05       	cpc	r23, r1
    4888:	11 f4       	brne	.+4      	; 0x488e <__unpack_f+0x42>
    488a:	82 e0       	ldi	r24, 0x02	; 2
    488c:	37 c0       	rjmp	.+110    	; 0x48fc <__unpack_f+0xb0>
    488e:	82 e8       	ldi	r24, 0x82	; 130
    4890:	9f ef       	ldi	r25, 0xFF	; 255
    4892:	13 96       	adiw	r26, 0x03	; 3
    4894:	9c 93       	st	X, r25
    4896:	8e 93       	st	-X, r24
    4898:	12 97       	sbiw	r26, 0x02	; 2
    489a:	9a 01       	movw	r18, r20
    489c:	ab 01       	movw	r20, r22
    489e:	67 e0       	ldi	r22, 0x07	; 7
    48a0:	22 0f       	add	r18, r18
    48a2:	33 1f       	adc	r19, r19
    48a4:	44 1f       	adc	r20, r20
    48a6:	55 1f       	adc	r21, r21
    48a8:	6a 95       	dec	r22
    48aa:	d1 f7       	brne	.-12     	; 0x48a0 <__unpack_f+0x54>
    48ac:	83 e0       	ldi	r24, 0x03	; 3
    48ae:	8c 93       	st	X, r24
    48b0:	0d c0       	rjmp	.+26     	; 0x48cc <__unpack_f+0x80>
    48b2:	22 0f       	add	r18, r18
    48b4:	33 1f       	adc	r19, r19
    48b6:	44 1f       	adc	r20, r20
    48b8:	55 1f       	adc	r21, r21
    48ba:	12 96       	adiw	r26, 0x02	; 2
    48bc:	8d 91       	ld	r24, X+
    48be:	9c 91       	ld	r25, X
    48c0:	13 97       	sbiw	r26, 0x03	; 3
    48c2:	01 97       	sbiw	r24, 0x01	; 1
    48c4:	13 96       	adiw	r26, 0x03	; 3
    48c6:	9c 93       	st	X, r25
    48c8:	8e 93       	st	-X, r24
    48ca:	12 97       	sbiw	r26, 0x02	; 2
    48cc:	20 30       	cpi	r18, 0x00	; 0
    48ce:	80 e0       	ldi	r24, 0x00	; 0
    48d0:	38 07       	cpc	r19, r24
    48d2:	80 e0       	ldi	r24, 0x00	; 0
    48d4:	48 07       	cpc	r20, r24
    48d6:	80 e4       	ldi	r24, 0x40	; 64
    48d8:	58 07       	cpc	r21, r24
    48da:	58 f3       	brcs	.-42     	; 0x48b2 <__unpack_f+0x66>
    48dc:	14 96       	adiw	r26, 0x04	; 4
    48de:	2d 93       	st	X+, r18
    48e0:	3d 93       	st	X+, r19
    48e2:	4d 93       	st	X+, r20
    48e4:	5c 93       	st	X, r21
    48e6:	17 97       	sbiw	r26, 0x07	; 7
    48e8:	08 95       	ret
    48ea:	2f 3f       	cpi	r18, 0xFF	; 255
    48ec:	31 05       	cpc	r19, r1
    48ee:	79 f4       	brne	.+30     	; 0x490e <__unpack_f+0xc2>
    48f0:	41 15       	cp	r20, r1
    48f2:	51 05       	cpc	r21, r1
    48f4:	61 05       	cpc	r22, r1
    48f6:	71 05       	cpc	r23, r1
    48f8:	19 f4       	brne	.+6      	; 0x4900 <__unpack_f+0xb4>
    48fa:	84 e0       	ldi	r24, 0x04	; 4
    48fc:	8c 93       	st	X, r24
    48fe:	08 95       	ret
    4900:	64 ff       	sbrs	r22, 4
    4902:	03 c0       	rjmp	.+6      	; 0x490a <__unpack_f+0xbe>
    4904:	81 e0       	ldi	r24, 0x01	; 1
    4906:	8c 93       	st	X, r24
    4908:	12 c0       	rjmp	.+36     	; 0x492e <__unpack_f+0xe2>
    490a:	1c 92       	st	X, r1
    490c:	10 c0       	rjmp	.+32     	; 0x492e <__unpack_f+0xe2>
    490e:	2f 57       	subi	r18, 0x7F	; 127
    4910:	30 40       	sbci	r19, 0x00	; 0
    4912:	13 96       	adiw	r26, 0x03	; 3
    4914:	3c 93       	st	X, r19
    4916:	2e 93       	st	-X, r18
    4918:	12 97       	sbiw	r26, 0x02	; 2
    491a:	83 e0       	ldi	r24, 0x03	; 3
    491c:	8c 93       	st	X, r24
    491e:	87 e0       	ldi	r24, 0x07	; 7
    4920:	44 0f       	add	r20, r20
    4922:	55 1f       	adc	r21, r21
    4924:	66 1f       	adc	r22, r22
    4926:	77 1f       	adc	r23, r23
    4928:	8a 95       	dec	r24
    492a:	d1 f7       	brne	.-12     	; 0x4920 <__unpack_f+0xd4>
    492c:	70 64       	ori	r23, 0x40	; 64
    492e:	14 96       	adiw	r26, 0x04	; 4
    4930:	4d 93       	st	X+, r20
    4932:	5d 93       	st	X+, r21
    4934:	6d 93       	st	X+, r22
    4936:	7c 93       	st	X, r23
    4938:	17 97       	sbiw	r26, 0x07	; 7
    493a:	08 95       	ret

0000493c <__fpcmp_parts_f>:
    493c:	1f 93       	push	r17
    493e:	dc 01       	movw	r26, r24
    4940:	fb 01       	movw	r30, r22
    4942:	9c 91       	ld	r25, X
    4944:	92 30       	cpi	r25, 0x02	; 2
    4946:	08 f4       	brcc	.+2      	; 0x494a <__fpcmp_parts_f+0xe>
    4948:	47 c0       	rjmp	.+142    	; 0x49d8 <__fpcmp_parts_f+0x9c>
    494a:	80 81       	ld	r24, Z
    494c:	82 30       	cpi	r24, 0x02	; 2
    494e:	08 f4       	brcc	.+2      	; 0x4952 <__fpcmp_parts_f+0x16>
    4950:	43 c0       	rjmp	.+134    	; 0x49d8 <__fpcmp_parts_f+0x9c>
    4952:	94 30       	cpi	r25, 0x04	; 4
    4954:	51 f4       	brne	.+20     	; 0x496a <__fpcmp_parts_f+0x2e>
    4956:	11 96       	adiw	r26, 0x01	; 1
    4958:	1c 91       	ld	r17, X
    495a:	84 30       	cpi	r24, 0x04	; 4
    495c:	99 f5       	brne	.+102    	; 0x49c4 <__fpcmp_parts_f+0x88>
    495e:	81 81       	ldd	r24, Z+1	; 0x01
    4960:	68 2f       	mov	r22, r24
    4962:	70 e0       	ldi	r23, 0x00	; 0
    4964:	61 1b       	sub	r22, r17
    4966:	71 09       	sbc	r23, r1
    4968:	3f c0       	rjmp	.+126    	; 0x49e8 <__fpcmp_parts_f+0xac>
    496a:	84 30       	cpi	r24, 0x04	; 4
    496c:	21 f0       	breq	.+8      	; 0x4976 <__fpcmp_parts_f+0x3a>
    496e:	92 30       	cpi	r25, 0x02	; 2
    4970:	31 f4       	brne	.+12     	; 0x497e <__fpcmp_parts_f+0x42>
    4972:	82 30       	cpi	r24, 0x02	; 2
    4974:	b9 f1       	breq	.+110    	; 0x49e4 <__fpcmp_parts_f+0xa8>
    4976:	81 81       	ldd	r24, Z+1	; 0x01
    4978:	88 23       	and	r24, r24
    497a:	89 f1       	breq	.+98     	; 0x49de <__fpcmp_parts_f+0xa2>
    497c:	2d c0       	rjmp	.+90     	; 0x49d8 <__fpcmp_parts_f+0x9c>
    497e:	11 96       	adiw	r26, 0x01	; 1
    4980:	1c 91       	ld	r17, X
    4982:	11 97       	sbiw	r26, 0x01	; 1
    4984:	82 30       	cpi	r24, 0x02	; 2
    4986:	f1 f0       	breq	.+60     	; 0x49c4 <__fpcmp_parts_f+0x88>
    4988:	81 81       	ldd	r24, Z+1	; 0x01
    498a:	18 17       	cp	r17, r24
    498c:	d9 f4       	brne	.+54     	; 0x49c4 <__fpcmp_parts_f+0x88>
    498e:	12 96       	adiw	r26, 0x02	; 2
    4990:	2d 91       	ld	r18, X+
    4992:	3c 91       	ld	r19, X
    4994:	13 97       	sbiw	r26, 0x03	; 3
    4996:	82 81       	ldd	r24, Z+2	; 0x02
    4998:	93 81       	ldd	r25, Z+3	; 0x03
    499a:	82 17       	cp	r24, r18
    499c:	93 07       	cpc	r25, r19
    499e:	94 f0       	brlt	.+36     	; 0x49c4 <__fpcmp_parts_f+0x88>
    49a0:	28 17       	cp	r18, r24
    49a2:	39 07       	cpc	r19, r25
    49a4:	bc f0       	brlt	.+46     	; 0x49d4 <__fpcmp_parts_f+0x98>
    49a6:	14 96       	adiw	r26, 0x04	; 4
    49a8:	8d 91       	ld	r24, X+
    49aa:	9d 91       	ld	r25, X+
    49ac:	0d 90       	ld	r0, X+
    49ae:	bc 91       	ld	r27, X
    49b0:	a0 2d       	mov	r26, r0
    49b2:	24 81       	ldd	r18, Z+4	; 0x04
    49b4:	35 81       	ldd	r19, Z+5	; 0x05
    49b6:	46 81       	ldd	r20, Z+6	; 0x06
    49b8:	57 81       	ldd	r21, Z+7	; 0x07
    49ba:	28 17       	cp	r18, r24
    49bc:	39 07       	cpc	r19, r25
    49be:	4a 07       	cpc	r20, r26
    49c0:	5b 07       	cpc	r21, r27
    49c2:	18 f4       	brcc	.+6      	; 0x49ca <__fpcmp_parts_f+0x8e>
    49c4:	11 23       	and	r17, r17
    49c6:	41 f0       	breq	.+16     	; 0x49d8 <__fpcmp_parts_f+0x9c>
    49c8:	0a c0       	rjmp	.+20     	; 0x49de <__fpcmp_parts_f+0xa2>
    49ca:	82 17       	cp	r24, r18
    49cc:	93 07       	cpc	r25, r19
    49ce:	a4 07       	cpc	r26, r20
    49d0:	b5 07       	cpc	r27, r21
    49d2:	40 f4       	brcc	.+16     	; 0x49e4 <__fpcmp_parts_f+0xa8>
    49d4:	11 23       	and	r17, r17
    49d6:	19 f0       	breq	.+6      	; 0x49de <__fpcmp_parts_f+0xa2>
    49d8:	61 e0       	ldi	r22, 0x01	; 1
    49da:	70 e0       	ldi	r23, 0x00	; 0
    49dc:	05 c0       	rjmp	.+10     	; 0x49e8 <__fpcmp_parts_f+0xac>
    49de:	6f ef       	ldi	r22, 0xFF	; 255
    49e0:	7f ef       	ldi	r23, 0xFF	; 255
    49e2:	02 c0       	rjmp	.+4      	; 0x49e8 <__fpcmp_parts_f+0xac>
    49e4:	60 e0       	ldi	r22, 0x00	; 0
    49e6:	70 e0       	ldi	r23, 0x00	; 0
    49e8:	cb 01       	movw	r24, r22
    49ea:	1f 91       	pop	r17
    49ec:	08 95       	ret

000049ee <__udivmodhi4>:
    49ee:	aa 1b       	sub	r26, r26
    49f0:	bb 1b       	sub	r27, r27
    49f2:	51 e1       	ldi	r21, 0x11	; 17
    49f4:	07 c0       	rjmp	.+14     	; 0x4a04 <__udivmodhi4_ep>

000049f6 <__udivmodhi4_loop>:
    49f6:	aa 1f       	adc	r26, r26
    49f8:	bb 1f       	adc	r27, r27
    49fa:	a6 17       	cp	r26, r22
    49fc:	b7 07       	cpc	r27, r23
    49fe:	10 f0       	brcs	.+4      	; 0x4a04 <__udivmodhi4_ep>
    4a00:	a6 1b       	sub	r26, r22
    4a02:	b7 0b       	sbc	r27, r23

00004a04 <__udivmodhi4_ep>:
    4a04:	88 1f       	adc	r24, r24
    4a06:	99 1f       	adc	r25, r25
    4a08:	5a 95       	dec	r21
    4a0a:	a9 f7       	brne	.-22     	; 0x49f6 <__udivmodhi4_loop>
    4a0c:	80 95       	com	r24
    4a0e:	90 95       	com	r25
    4a10:	bc 01       	movw	r22, r24
    4a12:	cd 01       	movw	r24, r26
    4a14:	08 95       	ret

00004a16 <__prologue_saves__>:
    4a16:	2f 92       	push	r2
    4a18:	3f 92       	push	r3
    4a1a:	4f 92       	push	r4
    4a1c:	5f 92       	push	r5
    4a1e:	6f 92       	push	r6
    4a20:	7f 92       	push	r7
    4a22:	8f 92       	push	r8
    4a24:	9f 92       	push	r9
    4a26:	af 92       	push	r10
    4a28:	bf 92       	push	r11
    4a2a:	cf 92       	push	r12
    4a2c:	df 92       	push	r13
    4a2e:	ef 92       	push	r14
    4a30:	ff 92       	push	r15
    4a32:	0f 93       	push	r16
    4a34:	1f 93       	push	r17
    4a36:	cf 93       	push	r28
    4a38:	df 93       	push	r29
    4a3a:	cd b7       	in	r28, 0x3d	; 61
    4a3c:	de b7       	in	r29, 0x3e	; 62
    4a3e:	ca 1b       	sub	r28, r26
    4a40:	db 0b       	sbc	r29, r27
    4a42:	0f b6       	in	r0, 0x3f	; 63
    4a44:	f8 94       	cli
    4a46:	de bf       	out	0x3e, r29	; 62
    4a48:	0f be       	out	0x3f, r0	; 63
    4a4a:	cd bf       	out	0x3d, r28	; 61
    4a4c:	19 94       	eijmp

00004a4e <__epilogue_restores__>:
    4a4e:	2a 88       	ldd	r2, Y+18	; 0x12
    4a50:	39 88       	ldd	r3, Y+17	; 0x11
    4a52:	48 88       	ldd	r4, Y+16	; 0x10
    4a54:	5f 84       	ldd	r5, Y+15	; 0x0f
    4a56:	6e 84       	ldd	r6, Y+14	; 0x0e
    4a58:	7d 84       	ldd	r7, Y+13	; 0x0d
    4a5a:	8c 84       	ldd	r8, Y+12	; 0x0c
    4a5c:	9b 84       	ldd	r9, Y+11	; 0x0b
    4a5e:	aa 84       	ldd	r10, Y+10	; 0x0a
    4a60:	b9 84       	ldd	r11, Y+9	; 0x09
    4a62:	c8 84       	ldd	r12, Y+8	; 0x08
    4a64:	df 80       	ldd	r13, Y+7	; 0x07
    4a66:	ee 80       	ldd	r14, Y+6	; 0x06
    4a68:	fd 80       	ldd	r15, Y+5	; 0x05
    4a6a:	0c 81       	ldd	r16, Y+4	; 0x04
    4a6c:	1b 81       	ldd	r17, Y+3	; 0x03
    4a6e:	aa 81       	ldd	r26, Y+2	; 0x02
    4a70:	b9 81       	ldd	r27, Y+1	; 0x01
    4a72:	ce 0f       	add	r28, r30
    4a74:	d1 1d       	adc	r29, r1
    4a76:	0f b6       	in	r0, 0x3f	; 63
    4a78:	f8 94       	cli
    4a7a:	de bf       	out	0x3e, r29	; 62
    4a7c:	0f be       	out	0x3f, r0	; 63
    4a7e:	cd bf       	out	0x3d, r28	; 61
    4a80:	ed 01       	movw	r28, r26
    4a82:	08 95       	ret

00004a84 <_exit>:
    4a84:	f8 94       	cli

00004a86 <__stop_program>:
    4a86:	ff cf       	rjmp	.-2      	; 0x4a86 <__stop_program>
